(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }
        g.bitshares_js = f();
    }
})(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw ((f.code = "MODULE_NOT_FOUND"), f);
                }
                var l = (n[o] = {exports: {}});
                t[o][0].call(
                    l.exports,
                    function(e) {
                        var n = t[o][1][e];
                        return s(n ? n : e);
                    },
                    l,
                    l.exports,
                    e,
                    t,
                    n,
                    r
                );
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    })(
        {
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/browser.js": [
                function(require, module, exports) {
                    "use strict";

                    module.exports = {
                        PrivateKey: require("./ecc/src/PrivateKey"),
                        PublicKey: require("./ecc/src/PublicKey"),
                        Signature: require("./ecc/src/signature"),
                        key: require("./ecc/src/KeyUtils"),
                        TransactionBuilder: require("./chain/src/TransactionBuilder"),
                        Login: require("./chain/src/AccountLogin"),
                        bitshares_ws: require("bitsharesjs-ws")
                    };
                },
                {
                    "./chain/src/AccountLogin":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/AccountLogin.js",
                    "./chain/src/TransactionBuilder":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/TransactionBuilder.js",
                    "./ecc/src/KeyUtils":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/KeyUtils.js",
                    "./ecc/src/PrivateKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PrivateKey.js",
                    "./ecc/src/PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    "./ecc/src/signature":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/signature.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/AccountLogin.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    var _PrivateKey = require("../../ecc/src/PrivateKey");

                    var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

                    var _KeyUtils = require("../../ecc/src/KeyUtils");

                    var _KeyUtils2 = _interopRequireDefault(_KeyUtils);

                    var _state = require("./state");

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    var _keyCachePriv = {};
                    var _keyCachePub = {};

                    var AccountLogin = (function() {
                        function AccountLogin() {
                            _classCallCheck(this, AccountLogin);

                            var state = {
                                loggedIn: false,
                                roles: ["active", "owner", "memo"]
                            };
                            this.get = (0, _state.get)(state);
                            this.set = (0, _state.set)(state);

                            this.subs = {};
                        }

                        AccountLogin.prototype.addSubscription = function addSubscription(
                            cb
                        ) {
                            this.subs[cb] = cb;
                        };

                        AccountLogin.prototype.setRoles = function setRoles(
                            roles
                        ) {
                            this.set("roles", roles);
                        };

                        AccountLogin.prototype.generateKeys = function generateKeys(
                            accountName,
                            password,
                            roles,
                            prefix
                        ) {
                            var start = new Date().getTime();
                            if (!accountName || !password) {
                                throw new Error(
                                    "Account name or password required"
                                );
                            }
                            if (password.length < 12) {
                                throw new Error(
                                    "Password must have at least 12 characters"
                                );
                            }

                            var privKeys = {};
                            var pubKeys = {};

                            (roles || this.get("roles")).forEach(function(
                                role
                            ) {
                                var seed = accountName + role + password;
                                var pkey = _keyCachePriv[seed]
                                    ? _keyCachePriv[seed]
                                    : _PrivateKey2.default.fromSeed(
                                          _KeyUtils2.default.normalize_brainKey(
                                              seed
                                          )
                                      );
                                _keyCachePriv[seed] = pkey;

                                privKeys[role] = pkey;
                                pubKeys[role] = _keyCachePub[seed]
                                    ? _keyCachePub[seed]
                                    : pkey.toPublicKey().toString(prefix);

                                _keyCachePub[seed] = pubKeys[role];
                            });

                            return {privKeys: privKeys, pubKeys: pubKeys};
                        };

                        AccountLogin.prototype.checkKeys = function checkKeys(
                            _ref
                        ) {
                            var _this = this;

                            var accountName = _ref.accountName,
                                password = _ref.password,
                                auths = _ref.auths;

                            if (!accountName || !password || !auths) {
                                throw new Error("checkKeys: Missing inputs");
                            }
                            var hasKey = false;

                            var _loop = function _loop(role) {
                                var _generateKeys = _this.generateKeys(
                                        accountName,
                                        password,
                                        [role]
                                    ),
                                    privKeys = _generateKeys.privKeys,
                                    pubKeys = _generateKeys.pubKeys;

                                auths[role].forEach(function(key) {
                                    if (key[0] === pubKeys[role]) {
                                        hasKey = true;
                                        _this.set(role, {
                                            priv: privKeys[role],
                                            pub: pubKeys[role]
                                        });
                                    }
                                });
                            };

                            for (var role in auths) {
                                _loop(role);
                            }

                            if (hasKey) {
                                this.set("name", accountName);
                            }

                            this.set("loggedIn", hasKey);

                            return hasKey;
                        };

                        AccountLogin.prototype.signTransaction = function signTransaction(
                            tr
                        ) {
                            var _this2 = this;

                            var myKeys = {};
                            var hasKey = false;

                            this.get("roles").forEach(function(role) {
                                var myKey = _this2.get(role);
                                if (myKey) {
                                    hasKey = true;
                                    console.log("adding signer:", myKey.pub);
                                    tr.add_signer(myKey.priv, myKey.pub);
                                }
                            });

                            if (!hasKey) {
                                throw new Error(
                                    "You do not have any private keys to sign this transaction"
                                );
                            }
                        };

                        return AccountLogin;
                    })();

                    var accountLogin = new AccountLogin();

                    exports.default = accountLogin;
                    module.exports = exports["default"];
                },
                {
                    "../../ecc/src/KeyUtils":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/KeyUtils.js",
                    "../../ecc/src/PrivateKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PrivateKey.js",
                    "./state":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/state.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ChainTypes.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    var ChainTypes = {};

                    ChainTypes.reserved_spaces = {
                        relative_protocol_ids: 0,
                        protocol_ids: 1,
                        implementation_ids: 2
                    };

                    ChainTypes.object_type = {
                        null: 0,
                        base: 1,
                        account: 2,
                        asset: 3,
                        force_settlement: 4,
                        committee_member: 5,
                        witness: 6,
                        limit_order: 7,
                        call_order: 8,
                        custom: 9,
                        proposal: 10,
                        operation_history: 11,
                        withdraw_permission: 12,
                        vesting_balance: 13,
                        worker: 14,
                        balance: 15
                    };

                    ChainTypes.impl_object_type = {
                        global_property: 0,
                        dynamic_global_property: 1,
                        index_meta: 2,
                        asset_dynamic_data: 3,
                        asset_bitasset_data: 4,
                        account_balance: 5,
                        account_statistics: 6,
                        transaction: 7,
                        block_summary: 8,
                        account_transaction_history: 9,
                        blinded_balance: 10,
                        chain_property: 11,
                        witness_schedule: 12,
                        budget_record: 13
                    };

                    ChainTypes.vote_type = {
                        committee: 0,
                        witness: 1,
                        worker: 2
                    };

                    ChainTypes.operations = {
                        transfer: 0,
                        limit_order_create: 1,
                        limit_order_cancel: 2,
                        call_order_update: 3,
                        fill_order: 4,
                        account_create: 5,
                        account_update: 6,
                        account_whitelist: 7,
                        account_upgrade: 8,
                        account_transfer: 9,
                        asset_create: 10,
                        asset_update: 11,
                        asset_update_bitasset: 12,
                        asset_update_feed_producers: 13,
                        asset_issue: 14,
                        asset_reserve: 15,
                        asset_fund_fee_pool: 16,
                        asset_settle: 17,
                        asset_global_settle: 18,
                        asset_publish_feed: 19,
                        witness_create: 20,
                        witness_update: 21,
                        proposal_create: 22,
                        proposal_update: 23,
                        proposal_delete: 24,
                        withdraw_permission_create: 25,
                        withdraw_permission_update: 26,
                        withdraw_permission_claim: 27,
                        withdraw_permission_delete: 28,
                        committee_member_create: 29,
                        committee_member_update: 30,
                        committee_member_update_global_parameters: 31,
                        vesting_balance_create: 32,
                        vesting_balance_withdraw: 33,
                        worker_create: 34,
                        custom: 35,
                        assert: 36,
                        balance_claim: 37,
                        override_transfer: 38,
                        transfer_to_blind: 39,
                        blind_transfer: 40,
                        transfer_from_blind: 41,
                        asset_settle_cancel: 42,
                        asset_claim_fees: 43
                    };

                    exports.default = ChainTypes;
                    module.exports = exports["default"];
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ObjectId.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    var _bytebuffer = require("bytebuffer");

                    var _SerializerValidation = require("../../serializer/src/SerializerValidation");

                    var _SerializerValidation2 = _interopRequireDefault(
                        _SerializerValidation
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    var DB_MAX_INSTANCE_ID = _bytebuffer.Long.fromNumber(
                        Math.pow(2, 48) - 1
                    );

                    var ObjectId = (function() {
                        function ObjectId(space, type, instance) {
                            _classCallCheck(this, ObjectId);

                            this.space = space;
                            this.type = type;
                            this.instance = instance;
                            var instance_string = this.instance.toString();
                            var _ObjectId =
                                this.space +
                                "." +
                                this.type +
                                "." +
                                instance_string;
                            if (
                                !_SerializerValidation2.default.is_digits(
                                    instance_string
                                )
                            ) {
                                throw new ("Invalid object id " + _ObjectId)();
                            }
                        }

                        ObjectId.fromString = function fromString(value) {
                            if (
                                value.space !== undefined &&
                                value.type !== undefined &&
                                value.instance !== undefined
                            ) {
                                return value;
                            }

                            var params = _SerializerValidation2.default.require_match(
                                /^([0-9]+)\.([0-9]+)\.([0-9]+)$/,
                                _SerializerValidation2.default.required(
                                    value,
                                    "ObjectId"
                                ),
                                "ObjectId"
                            );
                            return new ObjectId(
                                parseInt(params[1]),
                                parseInt(params[2]),
                                _bytebuffer.Long.fromString(params[3])
                            );
                        };

                        ObjectId.fromLong = function fromLong(long) {
                            var space = long.shiftRight(56).toInt();
                            var type = long.shiftRight(48).toInt() & 0x00ff;
                            var instance = long.and(DB_MAX_INSTANCE_ID);
                            return new ObjectId(space, type, instance);
                        };

                        ObjectId.fromByteBuffer = function fromByteBuffer(b) {
                            return ObjectId.fromLong(b.readUint64());
                        };

                        ObjectId.prototype.toLong = function toLong() {
                            return _bytebuffer.Long.fromNumber(this.space)
                                .shiftLeft(56)
                                .or(
                                    _bytebuffer.Long.fromNumber(this.type)
                                        .shiftLeft(48)
                                        .or(this.instance)
                                );
                        };

                        ObjectId.prototype.appendByteBuffer = function appendByteBuffer(
                            b
                        ) {
                            return b.writeUint64(this.toLong());
                        };

                        ObjectId.prototype.toString = function toString() {
                            return (
                                this.space +
                                "." +
                                this.type +
                                "." +
                                this.instance.toString()
                            );
                        };

                        return ObjectId;
                    })();

                    exports.default = ObjectId;
                    module.exports = exports["default"];
                },
                {
                    "../../serializer/src/SerializerValidation":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/SerializerValidation.js",
                    bytebuffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bytebuffer/dist/bytebuffer.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/TransactionBuilder.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _ecc = require("../../ecc");

                        var _serializer = require("../../serializer");

                        var _bitsharesjsWs = require("bitsharesjs-ws");

                        var _ChainTypes = require("./ChainTypes");

                        var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var head_block_time_string, committee_min_review;

                        var TransactionBuilder = (function() {
                            function TransactionBuilder() {
                                _classCallCheck(this, TransactionBuilder);

                                this.ref_block_num = 0;
                                this.ref_block_prefix = 0;
                                this.expiration = 0;
                                this.operations = [];
                                this.signatures = [];
                                this.signer_private_keys = [];

                                // semi-private method bindings
                                this._broadcast = _broadcast.bind(this);
                            }

                            /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */

                            TransactionBuilder.prototype.add_type_operation = function add_type_operation(
                                name,
                                operation
                            ) {
                                this.add_operation(
                                    this.get_type_operation(name, operation)
                                );
                                return;
                            };

                            /**
        This does it all: set fees, finalize, sign, and broadcast (if wanted).
         @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
         @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
         @arg {boolean} [broadcast = false]
    */

                            TransactionBuilder.prototype.process_transaction = function process_transaction(
                                cwallet
                            ) {
                                var _this = this;

                                var signer_pubkeys =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : null;
                                var broadcast =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : false;

                                var wallet_object =
                                    cwallet.wallet.wallet_object;
                                if (
                                    _bitsharesjsWs.Apis.instance().chain_id !==
                                    wallet_object.get("chain_id")
                                )
                                    return Promise.reject(
                                        "Mismatched chain_id; expecting " +
                                            wallet_object.get("chain_id") +
                                            ", but got " +
                                            _bitsharesjsWs.Apis.instance()
                                                .chain_id
                                    );

                                return this.set_required_fees().then(
                                    function() {
                                        var signer_pubkeys_added = {};
                                        if (signer_pubkeys) {
                                            // Balance claims are by address, only the private
                                            // key holder can know about these additional
                                            // potential keys.
                                            var pubkeys = cwallet.getPubkeys_having_PrivateKey(
                                                signer_pubkeys
                                            );
                                            if (!pubkeys.length)
                                                throw new Error(
                                                    "Missing signing key"
                                                );

                                            for (
                                                var _iterator = pubkeys,
                                                    _isArray = Array.isArray(
                                                        _iterator
                                                    ),
                                                    _i = 0,
                                                    _iterator = _isArray
                                                        ? _iterator
                                                        : _iterator[
                                                              Symbol.iterator
                                                          ]();
                                                ;

                                            ) {
                                                var _ref;

                                                if (_isArray) {
                                                    if (_i >= _iterator.length)
                                                        break;
                                                    _ref = _iterator[_i++];
                                                } else {
                                                    _i = _iterator.next();
                                                    if (_i.done) break;
                                                    _ref = _i.value;
                                                }

                                                var pubkey_string = _ref;

                                                var private_key = cwallet.getPrivateKey(
                                                    pubkey_string
                                                );
                                                _this.add_signer(
                                                    private_key,
                                                    pubkey_string
                                                );
                                                signer_pubkeys_added[
                                                    pubkey_string
                                                ] = true;
                                            }
                                        }

                                        return _this
                                            .get_potential_signatures()
                                            .then(function(_ref2) {
                                                var pubkeys = _ref2.pubkeys,
                                                    addys = _ref2.addys;

                                                var my_pubkeys = cwallet.getPubkeys_having_PrivateKey(
                                                    pubkeys,
                                                    addys
                                                );

                                                //{//Testing only, don't send All public keys!
                                                //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
                                                //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
                                                //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
                                                //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
                                                //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
                                                //}

                                                return _this
                                                    .get_required_signatures(
                                                        my_pubkeys
                                                    )
                                                    .then(function(
                                                        required_pubkeys
                                                    ) {
                                                        for (
                                                            var _iterator2 = required_pubkeys,
                                                                _isArray2 = Array.isArray(
                                                                    _iterator2
                                                                ),
                                                                _i2 = 0,
                                                                _iterator2 = _isArray2
                                                                    ? _iterator2
                                                                    : _iterator2[
                                                                          Symbol
                                                                              .iterator
                                                                      ]();
                                                            ;

                                                        ) {
                                                            var _ref3;

                                                            if (_isArray2) {
                                                                if (
                                                                    _i2 >=
                                                                    _iterator2.length
                                                                )
                                                                    break;
                                                                _ref3 =
                                                                    _iterator2[
                                                                        _i2++
                                                                    ];
                                                            } else {
                                                                _i2 = _iterator2.next();
                                                                if (_i2.done)
                                                                    break;
                                                                _ref3 =
                                                                    _i2.value;
                                                            }

                                                            var _pubkey_string = _ref3;

                                                            if (
                                                                signer_pubkeys_added[
                                                                    _pubkey_string
                                                                ]
                                                            )
                                                                continue;
                                                            var private_key = cwallet.getPrivateKey(
                                                                _pubkey_string
                                                            );
                                                            if (!private_key)
                                                                // This should not happen, get_required_signatures will only
                                                                // returned keys from my_pubkeys
                                                                throw new Error(
                                                                    "Missing signing key for " +
                                                                        _pubkey_string
                                                                );
                                                            _this.add_signer(
                                                                private_key,
                                                                _pubkey_string
                                                            );
                                                        }
                                                    });
                                            })
                                            .then(function() {
                                                return broadcast
                                                    ? _this.broadcast()
                                                    : _this.serialize();
                                            });
                                    }
                                );
                            };

                            /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */

                            TransactionBuilder.prototype.finalize = function finalize() {
                                var _this2 = this;

                                return new Promise(function(resolve, reject) {
                                    if (_this2.tr_buffer) {
                                        throw new Error("already finalized");
                                    }

                                    resolve(
                                        _bitsharesjsWs.Apis.instance()
                                            .db_api()
                                            .exec("get_objects", [["2.1.0"]])
                                            .then(function(r) {
                                                head_block_time_string =
                                                    r[0].time;
                                                if (_this2.expiration === 0)
                                                    _this2.expiration =
                                                        base_expiration_sec() +
                                                        _bitsharesjsWs
                                                            .ChainConfig
                                                            .expire_in_secs;
                                                _this2.ref_block_num =
                                                    r[0].head_block_number &
                                                    0xffff;
                                                _this2.ref_block_prefix = new Buffer(
                                                    r[0].head_block_id,
                                                    "hex"
                                                ).readUInt32LE(4);
                                                //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                                                var iterable =
                                                    _this2.operations;
                                                for (
                                                    var i = 0, op;
                                                    i < iterable.length;
                                                    i++
                                                ) {
                                                    op = iterable[i];
                                                    if (op[1]["finalize"]) {
                                                        op[1].finalize();
                                                    }
                                                }
                                                _this2.tr_buffer = _serializer.ops.transaction.toBuffer(
                                                    _this2
                                                );
                                            })
                                    );
                                });
                            };

                            /** @return {string} hex transaction ID */

                            TransactionBuilder.prototype.id = function id() {
                                if (!this.tr_buffer) {
                                    throw new Error("not finalized");
                                }
                                return _ecc.hash
                                    .sha256(this.tr_buffer)
                                    .toString("hex")
                                    .substring(0, 40);
                            };

                            /**
        Typically one will use {@link this.add_type_operation} instead.
        @arg {array} operation - [operation_id, operation]
    */

                            TransactionBuilder.prototype.add_operation = function add_operation(
                                operation
                            ) {
                                if (this.tr_buffer) {
                                    throw new Error("already finalized");
                                }
                                (0, _assert2.default)(operation, "operation");
                                if (!Array.isArray(operation)) {
                                    throw new Error(
                                        "Expecting array [operation_id, operation]"
                                    );
                                }
                                this.operations.push(operation);
                                return;
                            };

                            TransactionBuilder.prototype.get_type_operation = function get_type_operation(
                                name,
                                operation
                            ) {
                                if (this.tr_buffer) {
                                    throw new Error("already finalized");
                                }
                                (0, _assert2.default)(name, "name");
                                (0, _assert2.default)(operation, "operation");
                                var _type = _serializer.ops[name];
                                (0, _assert2.default)(
                                    _type,
                                    "Unknown operation " + name
                                );
                                var operation_id =
                                    _ChainTypes2.default.operations[
                                        _type.operation_name
                                    ];
                                if (operation_id === undefined) {
                                    throw new Error(
                                        "unknown operation: " +
                                            _type.operation_name
                                    );
                                }
                                if (!operation.fee) {
                                    operation.fee = {amount: 0, asset_id: 0};
                                }
                                if (name === "proposal_create") {
                                    /*
            * Proposals involving the committee account require a review
            * period to be set, look for them here
            */
                                    var requiresReview = false,
                                        extraReview = 0;
                                    operation.proposed_ops.forEach(function(
                                        op
                                    ) {
                                        var COMMITTE_ACCOUNT = 0;
                                        var key = void 0;

                                        switch (op.op[0]) {
                                            case 0:
                                                // transfer
                                                key = "from";
                                                break;

                                            case 6: //account_update
                                            case 17:
                                                // asset_settle
                                                key = "account";
                                                break;

                                            case 10: // asset_create
                                            case 11: // asset_update
                                            case 12: // asset_update_bitasset
                                            case 13: // asset_update_feed_producers
                                            case 14: // asset_issue
                                            case 18: // asset_global_settle
                                            case 43:
                                                // asset_claim_fees
                                                key = "issuer";
                                                break;

                                            case 15:
                                                // asset_reserve
                                                key = "payer";
                                                break;

                                            case 16:
                                                // asset_fund_fee_pool
                                                key = "from_account";
                                                break;

                                            case 22: // proposal_create
                                            case 23: // proposal_update
                                            case 24:
                                                // proposal_delete
                                                key = "fee_paying_account";
                                                break;

                                            case 31:
                                                // committee_member_update_global_parameters
                                                requiresReview = true;
                                                extraReview = 60 * 60 * 24 * 13; // Make the review period 2 weeks total
                                                break;
                                        }
                                        if (
                                            key in op.op[1] &&
                                            op.op[1][key] === COMMITTE_ACCOUNT
                                        ) {
                                            requiresReview = true;
                                        }
                                    });
                                    operation.expiration_time ||
                                        (operation.expiration_time =
                                            base_expiration_sec() +
                                            _bitsharesjsWs.ChainConfig
                                                .expire_in_secs_proposal);
                                    if (requiresReview) {
                                        operation.review_period_seconds =
                                            extraReview +
                                            Math.max(
                                                committee_min_review,
                                                24 * 60 * 60 ||
                                                    _bitsharesjsWs.ChainConfig
                                                        .review_in_secs_committee
                                            );
                                        /*
                * Expiration time must be at least equal to
                * now + review_period_seconds, so we add one hour to make sure
                */
                                        operation.expiration_time +=
                                            60 * 60 + extraReview;
                                    }
                                }
                                var operation_instance = _type.fromObject(
                                    operation
                                );
                                return [operation_id, operation_instance];
                            };

                            /* optional: fetch the current head block */

                            TransactionBuilder.prototype.update_head_block = function update_head_block() {
                                return Promise.all([
                                    _bitsharesjsWs.Apis.instance()
                                        .db_api()
                                        .exec("get_objects", [["2.0.0"]]),
                                    _bitsharesjsWs.Apis.instance()
                                        .db_api()
                                        .exec("get_objects", [["2.1.0"]])
                                ]).then(function(res) {
                                    var g = res[0],
                                        r = res[1];

                                    head_block_time_string = r[0].time;
                                    committee_min_review =
                                        g[0].parameters
                                            .committee_proposal_review_period;
                                });
                            };

                            /** optional: there is a deafult expiration */

                            TransactionBuilder.prototype.set_expire_seconds = function set_expire_seconds(
                                sec
                            ) {
                                if (this.tr_buffer) {
                                    throw new Error("already finalized");
                                }
                                return (this.expiration =
                                    base_expiration_sec() + sec);
                            };

                            /* Wraps this transaction in a proposal_create transaction */

                            TransactionBuilder.prototype.propose = function propose(
                                proposal_create_options
                            ) {
                                if (this.tr_buffer) {
                                    throw new Error("already finalized");
                                }
                                if (!this.operations.length) {
                                    throw new Error("add operation first");
                                }

                                (0, _assert2.default)(
                                    proposal_create_options,
                                    "proposal_create_options"
                                );
                                (0, _assert2.default)(
                                    proposal_create_options.fee_paying_account,
                                    "proposal_create_options.fee_paying_account"
                                );

                                var proposed_ops = this.operations.map(function(
                                    op
                                ) {
                                    return {op: op};
                                });

                                this.operations = [];
                                this.signatures = [];
                                this.signer_private_keys = [];
                                proposal_create_options.proposed_ops = proposed_ops;
                                this.add_type_operation(
                                    "proposal_create",
                                    proposal_create_options
                                );
                                return this;
                            };

                            TransactionBuilder.prototype.has_proposed_operation = function has_proposed_operation() {
                                var hasProposed = false;
                                for (
                                    var i = 0;
                                    i < this.operations.length;
                                    i++
                                ) {
                                    if (
                                        "proposed_ops" in this.operations[i][1]
                                    ) {
                                        hasProposed = true;
                                        break;
                                    }
                                }

                                return hasProposed;
                            };

                            /** optional: the fees can be obtained from the witness node */

                            TransactionBuilder.prototype.set_required_fees = function set_required_fees(
                                asset_id,
                                removeDuplicates
                            ) {
                                var _this3 = this;

                                if (this.tr_buffer) {
                                    throw new Error("already finalized");
                                }
                                if (!this.operations.length) {
                                    throw new Error("add operations first");
                                }

                                function isProposal(op) {
                                    return op[0] === 22;
                                }

                                var operations = [];
                                var proposed_ops = [];
                                var feeAssets = [];
                                var proposalFeeAssets = [];
                                var potentialDuplicates = {};
                                function getDuplicateOriginalIndex(op, index) {
                                    var key = getOperationKey(op);
                                    var duplicate = potentialDuplicates[key];
                                    if (!!duplicate) {
                                        if (duplicate.original === index)
                                            return index;
                                        else if (
                                            duplicate.duplicates.indexOf(
                                                index
                                            ) !== -1
                                        ) {
                                            return duplicate.original;
                                        }
                                    }
                                }
                                function getOperationKey(op) {
                                    var key = null;
                                    switch (op[0]) {
                                        case 0:
                                            // transfer
                                            var memoDummy = new Array(
                                                op[1].memo.message.length + 1
                                            ).join("a");
                                            key =
                                                op[0] +
                                                "_" +
                                                op[1].amount.asset_id +
                                                "_" +
                                                memoDummy;
                                            break;
                                        default:
                                    }
                                    return key;
                                }
                                for (
                                    var i = 0, op;
                                    i < this.operations.length;
                                    i++
                                ) {
                                    op = this.operations[i];
                                    var opObject = _serializer.ops.operation.toObject(
                                        op
                                    );
                                    var isDuplicate = false;
                                    if (removeDuplicates) {
                                        var key = getOperationKey(opObject);
                                        if (key) {
                                            if (!potentialDuplicates[key])
                                                potentialDuplicates[key] = {
                                                    original: i,
                                                    duplicates: []
                                                };
                                            else {
                                                potentialDuplicates[
                                                    key
                                                ].duplicates.push(i);
                                                isDuplicate = true;
                                            }
                                        }
                                    }
                                    /*
            * If the operation creates a proposal, we should check the fee pool
            * of the suggested proposal fee assets to prevent users from creating
            * proposals that will most likely fail due to empty fee pools
            */
                                    if (isProposal(op)) {
                                        op[1].proposed_ops.forEach(function(
                                            prop
                                        ) {
                                            // console.log("proposed op", prop.op[1].fee);
                                            proposed_ops.push(prop);
                                            if (
                                                proposalFeeAssets.indexOf(
                                                    prop.op[1].fee.asset_id
                                                ) === -1
                                            )
                                                proposalFeeAssets.push(
                                                    "1.3." +
                                                        prop.op[1].fee.asset_id
                                                );
                                        });
                                    }
                                    if (!isDuplicate) {
                                        operations.push(opObject);
                                        if (
                                            feeAssets.indexOf(
                                                operations[i][1].fee.asset_id
                                            ) === -1
                                        )
                                            feeAssets.push(
                                                operations[i][1].fee.asset_id
                                            );
                                    }
                                }

                                if (!asset_id) {
                                    var op1_fee = operations[0][1].fee;
                                    if (op1_fee && op1_fee.asset_id !== null) {
                                        asset_id = op1_fee.asset_id;
                                    } else {
                                        asset_id = "1.3.0";
                                    }
                                }

                                var promises = [];
                                promises.push(
                                    Promise.all(
                                        feeAssets.map(function(id) {
                                            return _bitsharesjsWs.Apis.instance()
                                                .db_api()
                                                .exec("get_required_fees", [
                                                    operations,
                                                    id
                                                ]);
                                        })
                                    ).catch(function(err) {
                                        console.error(
                                            "get_required_fees API error: ",
                                            err.message
                                        );
                                    })
                                );

                                /*
        * Add the proposal fee asset ids to feeAssets here to fetch their
        * dynamic objects without calling get_required_fees with them as well
        */
                                if (proposalFeeAssets.length) {
                                    proposalFeeAssets.forEach(function(id) {
                                        if (feeAssets.indexOf(id) === -1)
                                            feeAssets.push(id);
                                    });
                                }

                                if (
                                    feeAssets.length > 1 ||
                                    feeAssets[0] !== "1.3.0"
                                ) {
                                    /*
            * If we're paying with any assets other than CORE, we need to fetch
            * the dynamic asset object and check the fee pool of those assets.
            * The dynamic asset object id is equal to the asset id but with
            * 2.3.x instead of 1.3.x
            */
                                    var dynamicObjectIds = feeAssets.map(
                                        function(a) {
                                            return a.replace(/^1\./, "2.");
                                        }
                                    );
                                    promises.push(
                                        _bitsharesjsWs.Apis.instance()
                                            .db_api()
                                            .exec("get_required_fees", [
                                                operations,
                                                "1.3.0"
                                            ])
                                    );
                                    promises.push(
                                        _bitsharesjsWs.Apis.instance()
                                            .db_api()
                                            .exec("get_objects", [
                                                dynamicObjectIds
                                            ])
                                    );
                                }

                                return Promise.all(promises).then(function(
                                    results
                                ) {
                                    /*
            * allFees and coreFees are arrays containg fee amounts grouped by
            * asset and for each operation in operations
            */
                                    var allFees = results[0],
                                        coreFees = results[1],
                                        dynamicObjects = results[2];
                                    /*
            * If one of the desired fee assets has an invalid core exchange rate
            * get_required_signatures will fail and the result for all assets
            * will be undefined, if so we just default to coreFees
            */

                                    if (allFees === undefined) {
                                        allFees = coreFees;
                                    }
                                    /*
            * If the only desired fee asset is CORE, coreFees are not fetched
            * but are equal to allFees
            */
                                    if (!coreFees) {
                                        coreFees = allFees[0];
                                    }

                                    /* Create a map of fees and proposal fees by asset id */
                                    var feesByAsset = {};
                                    var proposalFeesByAsset = {};
                                    allFees.forEach(function(feeSet) {
                                        var filteredFeeSet = feeSet.map(
                                            function(f) {
                                                if (Array.isArray(f)) {
                                                    // This operation includes a proposal
                                                    proposalFeesByAsset[
                                                        f[1][0].asset_id
                                                    ] =
                                                        f[1];
                                                    return f[0];
                                                }
                                                return f;
                                            }
                                        );
                                        var currentAssetId =
                                            filteredFeeSet[0].asset_id;

                                        feesByAsset[
                                            currentAssetId
                                        ] = filteredFeeSet;
                                    }, {});

                                    /* Create a map of fee pools by asset id*/
                                    var feePoolMap = !!dynamicObjects
                                        ? dynamicObjects.reduce(function(
                                              map,
                                              object
                                          ) {
                                              map[
                                                  object.id.replace(
                                                      /^2\./,
                                                      "1."
                                                  )
                                              ] = object;
                                              return map;
                                          },
                                          {})
                                        : {};

                                    var feeMap = {};
                                    var proposalFeeMap = {};
                                    function updateFeeMap(
                                        map,
                                        asset_id,
                                        opIndex,
                                        core_fees
                                    ) {
                                        if (!map[asset_id])
                                            map[asset_id] = {total: 0, ops: []};
                                        if (map[asset_id].propIdx)
                                            map[asset_id].propIdx.push(opIndex);
                                        else map[asset_id].ops.push(opIndex);

                                        if (asset_id !== "1.3.0") {
                                            map[
                                                asset_id
                                            ].total += core_fees.length
                                                ? core_fees[opIndex].amount
                                                : core_fees.amount;
                                        }
                                        return map;
                                    }

                                    var _loop = function _loop(_i3) {
                                        var op = operations[_i3];
                                        var feeAssetId = op[1].fee.asset_id;

                                        if (isProposal(op)) {
                                            feeMap = updateFeeMap(
                                                feeMap,
                                                feeAssetId,
                                                _i3,
                                                coreFees[_i3][0]
                                            );

                                            op[1].proposed_ops.forEach(function(
                                                prop,
                                                y
                                            ) {
                                                var propFeeAsset =
                                                    prop.op[1].fee.asset_id;
                                                if (!proposalFeeMap[_i3])
                                                    proposalFeeMap[_i3] = {};
                                                if (
                                                    !proposalFeeMap[_i3][
                                                        propFeeAsset
                                                    ]
                                                )
                                                    proposalFeeMap[_i3][
                                                        propFeeAsset
                                                    ] = {
                                                        total: 0,
                                                        ops: [_i3],
                                                        propIdx: []
                                                    };

                                                proposalFeeMap[
                                                    _i3
                                                ] = updateFeeMap(
                                                    proposalFeeMap[_i3],
                                                    propFeeAsset,
                                                    y,
                                                    coreFees[_i3][1]
                                                );
                                            });
                                        } else {
                                            feeMap = updateFeeMap(
                                                feeMap,
                                                feeAssetId,
                                                _i3,
                                                coreFees[_i3]
                                            );
                                        }
                                    };

                                    for (
                                        var _i3 = 0;
                                        _i3 < operations.length;
                                        _i3++
                                    ) {
                                        _loop(_i3);
                                    }

                                    /* Check fee pool balances for regular ops */
                                    function checkPoolBalance(map) {
                                        if (!Object.keys(map).length) return [];
                                        var final_fees = [];

                                        var _loop2 = function _loop2(asset) {
                                            var feePool = feePoolMap[asset]
                                                ? parseInt(
                                                      feePoolMap[asset]
                                                          .fee_pool,
                                                      10
                                                  )
                                                : 0;
                                            /* Fee pool balance insufficient, default to core*/
                                            if (map[asset].total > feePool) {
                                                map[asset].ops.forEach(function(
                                                    opIndex
                                                ) {
                                                    if (
                                                        coreFees[opIndex]
                                                            .length === 2 &&
                                                        "propIdx" in map[asset]
                                                    ) {
                                                        /* Proposal op */
                                                        map[
                                                            asset
                                                        ].propIdx.forEach(
                                                            function(prop_idx) {
                                                                final_fees[
                                                                    prop_idx
                                                                ] =
                                                                    coreFees[
                                                                        opIndex
                                                                    ][1][
                                                                        prop_idx
                                                                    ];
                                                            }
                                                        );
                                                    } else if (
                                                        coreFees[opIndex]
                                                            .length === 2
                                                    ) {
                                                        final_fees[opIndex] =
                                                            coreFees[
                                                                opIndex
                                                            ][0];
                                                    } else {
                                                        final_fees[opIndex] =
                                                            coreFees[opIndex];
                                                    }
                                                });
                                                /* Use the desired fee asset */
                                            } else {
                                                map[asset].ops.forEach(function(
                                                    opIndex
                                                ) {
                                                    if (
                                                        coreFees[opIndex]
                                                            .length === 2 &&
                                                        "propIdx" in map[asset]
                                                    ) {
                                                        map[
                                                            asset
                                                        ].propIdx.forEach(
                                                            function(prop_idx) {
                                                                final_fees[
                                                                    prop_idx
                                                                ] =
                                                                    proposalFeesByAsset[
                                                                        asset
                                                                    ][prop_idx];
                                                            }
                                                        );
                                                    } else {
                                                        final_fees[opIndex] =
                                                            feesByAsset[asset][
                                                                opIndex
                                                            ];
                                                    }
                                                });
                                            }
                                        };

                                        for (var asset in map) {
                                            _loop2(asset);
                                        }
                                        return final_fees;
                                    }

                                    var finalFees = checkPoolBalance(feeMap);

                                    var finalProposalFees = {};
                                    for (var _key in proposalFeeMap) {
                                        finalProposalFees[
                                            _key
                                        ] = checkPoolBalance(
                                            proposalFeeMap[_key]
                                        );
                                    }

                                    var set_fee = function set_fee(
                                        operation,
                                        opIndex
                                    ) {
                                        if (
                                            !operation.fee ||
                                            operation.fee.amount === 0 ||
                                            (operation.fee.amount.toString &&
                                                operation.fee.amount.toString() ===
                                                    "0") // Long
                                        ) {
                                            if (removeDuplicates) {
                                                var _op = _serializer.ops.operation.toObject(
                                                    _this3.operations[opIndex]
                                                );
                                                var originalIndex = getDuplicateOriginalIndex(
                                                    _op,
                                                    opIndex
                                                );
                                                if (originalIndex >= 0) {
                                                    // it's a duplicate
                                                    operation.fee =
                                                        finalFees[
                                                            originalIndex
                                                        ];
                                                } else {
                                                    operation.fee =
                                                        finalFees[opIndex];
                                                }
                                            } else {
                                                operation.fee =
                                                    finalFees[opIndex];
                                            }
                                        }
                                        if (operation.proposed_ops) {
                                            var result = [];
                                            /*
                    * Loop over proposed_ops and assign fee asset ids as
                    * determined by the fee pool balance check. If the balance
                    * is sufficient the asset_id is kept, if not it defaults to
                    * "1.3.0"
                    */
                                            for (
                                                var y = 0;
                                                y <
                                                operation.proposed_ops.length;
                                                y++
                                            ) {
                                                operation.proposed_ops[
                                                    y
                                                ].op[1].fee.asset_id =
                                                    finalProposalFees[opIndex][
                                                        y
                                                    ].asset_id;
                                            }

                                            return result;
                                        }
                                    };
                                    /* We apply the final fees the the operations */
                                    for (
                                        var _i4 = 0;
                                        _i4 < _this3.operations.length;
                                        _i4++
                                    ) {
                                        set_fee(_this3.operations[_i4][1], _i4);
                                    }
                                });
                                //DEBUG console.log('... get_required_fees',operations,asset_id,flat_fees)
                            };

                            TransactionBuilder.prototype.get_potential_signatures = function get_potential_signatures() {
                                var tr_object = _serializer.ops.signed_transaction.toObject(
                                    this
                                );
                                return Promise.all([
                                    _bitsharesjsWs.Apis.instance()
                                        .db_api()
                                        .exec("get_potential_signatures", [
                                            tr_object
                                        ]),
                                    _bitsharesjsWs.Apis.instance()
                                        .db_api()
                                        .exec(
                                            "get_potential_address_signatures",
                                            [tr_object]
                                        )
                                ]).then(function(results) {
                                    return {
                                        pubkeys: results[0],
                                        addys: results[1]
                                    };
                                });
                            };

                            TransactionBuilder.prototype.get_required_signatures = function get_required_signatures(
                                available_keys
                            ) {
                                if (!available_keys.length) {
                                    return Promise.resolve([]);
                                }
                                var tr_object = _serializer.ops.signed_transaction.toObject(
                                    this
                                );
                                //DEBUG console.log('... tr_object',tr_object)
                                return _bitsharesjsWs.Apis.instance()
                                    .db_api()
                                    .exec("get_required_signatures", [
                                        tr_object,
                                        available_keys
                                    ])
                                    .then(function(required_public_keys) {
                                        //DEBUG console.log('... get_required_signatures',required_public_keys)
                                        return required_public_keys;
                                    });
                            };

                            TransactionBuilder.prototype.add_signer = function add_signer(
                                private_key
                            ) {
                                var public_key =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : private_key.toPublicKey();

                                (0, _assert2.default)(
                                    private_key.d,
                                    "required PrivateKey object"
                                );

                                if (this.signed) {
                                    throw new Error("already signed");
                                }
                                if (!public_key.Q) {
                                    public_key = _ecc.PublicKey.fromPublicKeyString(
                                        public_key
                                    );
                                }
                                // prevent duplicates
                                var spHex = private_key.toHex();
                                for (
                                    var _iterator3 = this.signer_private_keys,
                                        _isArray3 = Array.isArray(_iterator3),
                                        _i5 = 0,
                                        _iterator3 = _isArray3
                                            ? _iterator3
                                            : _iterator3[Symbol.iterator]();
                                    ;

                                ) {
                                    var _ref4;

                                    if (_isArray3) {
                                        if (_i5 >= _iterator3.length) break;
                                        _ref4 = _iterator3[_i5++];
                                    } else {
                                        _i5 = _iterator3.next();
                                        if (_i5.done) break;
                                        _ref4 = _i5.value;
                                    }

                                    var sp = _ref4;

                                    if (sp[0].toHex() === spHex) return;
                                }
                                this.signer_private_keys.push([
                                    private_key,
                                    public_key
                                ]);
                            };

                            TransactionBuilder.prototype.sign = function sign() {
                                var chain_id =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : _bitsharesjsWs.Apis.instance()
                                              .chain_id;

                                if (!this.tr_buffer) {
                                    throw new Error("not finalized");
                                }
                                if (this.signed) {
                                    throw new Error("already signed");
                                }
                                if (!this.signer_private_keys.length) {
                                    throw new Error(
                                        "Transaction was not signed. Do you have a private key? [no_signers]"
                                    );
                                }
                                var end = this.signer_private_keys.length;
                                for (
                                    var i = 0;
                                    0 < end ? i < end : i > end;
                                    0 < end ? i++ : i++
                                ) {
                                    var _signer_private_keys$ = this
                                            .signer_private_keys[i],
                                        private_key = _signer_private_keys$[0],
                                        public_key = _signer_private_keys$[1];

                                    var sig = _ecc.Signature.signBuffer(
                                        Buffer.concat([
                                            new Buffer(chain_id, "hex"),
                                            this.tr_buffer
                                        ]),
                                        private_key,
                                        public_key
                                    );
                                    this.signatures.push(sig.toBuffer());
                                }
                                this.signer_private_keys = [];
                                this.signed = true;
                                return;
                            };

                            TransactionBuilder.prototype.serialize = function serialize() {
                                return _serializer.ops.signed_transaction.toObject(
                                    this
                                );
                            };

                            TransactionBuilder.prototype.toObject = function toObject() {
                                return _serializer.ops.signed_transaction.toObject(
                                    this
                                );
                            };

                            TransactionBuilder.prototype.broadcast = function broadcast(
                                was_broadcast_callback
                            ) {
                                var _this4 = this;

                                if (this.tr_buffer) {
                                    return this._broadcast(
                                        was_broadcast_callback
                                    );
                                } else {
                                    return this.finalize().then(function() {
                                        return _this4._broadcast(
                                            was_broadcast_callback
                                        );
                                    });
                                }
                            };

                            return TransactionBuilder;
                        })();

                        var base_expiration_sec = function base_expiration_sec() {
                            var head_block_sec = Math.ceil(
                                getHeadBlockDate().getTime() / 1000
                            );
                            var now_sec = Math.ceil(Date.now() / 1000);
                            // The head block time should be updated every 3 seconds.  If it isn't
                            // then help the transaction to expire (use head_block_sec)
                            if (now_sec - head_block_sec > 30) {
                                return head_block_sec;
                            }
                            // If the user's clock is very far behind, use the head block time.
                            return Math.max(now_sec, head_block_sec);
                        };

                        function _broadcast(was_broadcast_callback) {
                            var _this5 = this;

                            return new Promise(function(resolve, reject) {
                                if (!_this5.signed) {
                                    _this5.sign();
                                }
                                if (!_this5.tr_buffer) {
                                    throw new Error("not finalized");
                                }
                                if (!_this5.signatures.length) {
                                    throw new Error("not signed");
                                }
                                if (!_this5.operations.length) {
                                    throw new Error("no operations");
                                }

                                var tr_object = _serializer.ops.signed_transaction.toObject(
                                    _this5
                                );
                                // console.log('... broadcast_transaction_with_callback !!!')
                                _bitsharesjsWs.Apis.instance()
                                    .network_api()
                                    .exec(
                                        "broadcast_transaction_with_callback",
                                        [
                                            function(res) {
                                                return resolve(res);
                                            },
                                            tr_object
                                        ]
                                    )
                                    .then(function() {
                                        //console.log('... broadcast success, waiting for callback')
                                        if (was_broadcast_callback)
                                            was_broadcast_callback();
                                        return;
                                    })
                                    .catch(function(error) {
                                        // console.log may be redundant for network errors, other errors could occur
                                        console.log(error);
                                        var message = error.message;
                                        if (!message) {
                                            message = "";
                                        }
                                        reject(
                                            new Error(
                                                message +
                                                    "\n" +
                                                    "bitshares-crypto " +
                                                    " digest " +
                                                    _ecc.hash
                                                        .sha256(
                                                            _this5.tr_buffer
                                                        )
                                                        .toString("hex") +
                                                    " transaction " +
                                                    _this5.tr_buffer.toString(
                                                        "hex"
                                                    ) +
                                                    " " +
                                                    JSON.stringify(tr_object)
                                            )
                                        );
                                        return;
                                    });
                                return;
                            });
                        }

                        function getHeadBlockDate() {
                            return timeStringToDate(head_block_time_string);
                        }

                        function timeStringToDate(time_string) {
                            if (!time_string)
                                return new Date("1970-01-01T00:00:00.000Z");
                            if (!/Z$/.test(time_string))
                                //does not end in Z
                                // https://github.com/cryptonomex/graphene/issues/368
                                time_string = time_string + "Z";
                            return new Date(time_string);
                        }

                        exports.default = TransactionBuilder;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "../../ecc":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/index.js",
                    "../../serializer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/index.js",
                    "./ChainTypes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ChainTypes.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/state.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    function get(state) {
                        return function(key) {
                            return state[key] || "";
                        };
                    }

                    function set(state) {
                        return function(key, value) {
                            state[key] = value;
                            return this;
                        };
                    }

                    exports.get = get;
                    exports.set = set;
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/index.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.key = exports.hash = exports.brainKey = exports.Signature = exports.PublicKey = exports.PrivateKey = exports.Aes = exports.Address = undefined;

                    var _address = require("./src/address");

                    var _address2 = _interopRequireDefault(_address);

                    var _aes = require("./src/aes");

                    var _aes2 = _interopRequireDefault(_aes);

                    var _PrivateKey = require("./src/PrivateKey");

                    var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

                    var _PublicKey = require("./src/PublicKey");

                    var _PublicKey2 = _interopRequireDefault(_PublicKey);

                    var _signature = require("./src/signature");

                    var _signature2 = _interopRequireDefault(_signature);

                    var _BrainKey = require("./src/BrainKey");

                    var _BrainKey2 = _interopRequireDefault(_BrainKey);

                    var _hash = require("./src/hash");

                    var hash = _interopRequireWildcard(_hash);

                    var _KeyUtils = require("./src/KeyUtils");

                    var _KeyUtils2 = _interopRequireDefault(_KeyUtils);

                    function _interopRequireWildcard(obj) {
                        if (obj && obj.__esModule) {
                            return obj;
                        } else {
                            var newObj = {};
                            if (obj != null) {
                                for (var key in obj) {
                                    if (
                                        Object.prototype.hasOwnProperty.call(
                                            obj,
                                            key
                                        )
                                    )
                                        newObj[key] = obj[key];
                                }
                            }
                            newObj.default = obj;
                            return newObj;
                        }
                    }

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    exports.Address = _address2.default;
                    exports.Aes = _aes2.default;
                    exports.PrivateKey = _PrivateKey2.default;
                    exports.PublicKey = _PublicKey2.default;
                    exports.Signature = _signature2.default;
                    exports.brainKey = _BrainKey2.default;
                    exports.hash = hash;
                    exports.key = _KeyUtils2.default;
                },
                {
                    "./src/BrainKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/BrainKey.js",
                    "./src/KeyUtils":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/KeyUtils.js",
                    "./src/PrivateKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PrivateKey.js",
                    "./src/PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    "./src/address":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/address.js",
                    "./src/aes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/aes.js",
                    "./src/hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    "./src/signature":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/signature.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/BrainKey.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.default = normalize;
                    function normalize(brainKey) {
                        if (typeof brainKey !== "string") {
                            throw new Error("string required for brainKey");
                        }
                        brainKey = brainKey.trim();
                        return brainKey.split(/[\t\n\v\f\r ]+/).join(" ");
                    }
                    module.exports = exports["default"];
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/KeyUtils.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _PrivateKey = require("./PrivateKey");

                        var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

                        var _PublicKey = require("./PublicKey");

                        var _PublicKey2 = _interopRequireDefault(_PublicKey);

                        var _address = require("./address");

                        var _address2 = _interopRequireDefault(_address);

                        var _aes = require("./aes");

                        var _aes2 = _interopRequireDefault(_aes);

                        var _hash = require("./hash");

                        var _secureRandom = require("secure-random");

                        var _secureRandom2 = _interopRequireDefault(
                            _secureRandom
                        );

                        var _bitsharesjsWs = require("bitsharesjs-ws");

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        // hash for .25 second

                        // import dictionary from './dictionary_en';
                        var HASH_POWER_MILLS = 250;

                        var key = {
                            /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */
                            aes_checksum: function aes_checksum(password) {
                                if (!(typeof password === "string")) {
                                    throw new "password string required"();
                                }
                                var salt = _secureRandom2.default
                                    .randomBuffer(4)
                                    .toString("hex");
                                var iterations = 0;
                                var secret = salt + password;
                                // hash for .1 second
                                var start_t = Date.now();
                                while (
                                    Date.now() - start_t <
                                    HASH_POWER_MILLS
                                ) {
                                    secret = (0, _hash.sha256)(secret);
                                    iterations += 1;
                                }

                                var checksum = (0, _hash.sha256)(secret);
                                var checksum_string = [
                                    iterations,
                                    salt.toString("hex"),
                                    checksum.slice(0, 4).toString("hex")
                                ].join(",");

                                return {
                                    aes_private: _aes2.default.fromSeed(secret),
                                    checksum: checksum_string
                                };
                            },

                            /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
                            aes_private: function aes_private(
                                password,
                                key_checksum
                            ) {
                                var _key_checksum$split = key_checksum.split(
                                        ","
                                    ),
                                    iterations = _key_checksum$split[0],
                                    salt = _key_checksum$split[1],
                                    checksum = _key_checksum$split[2];

                                var secret = salt + password;
                                for (
                                    var i = 0;
                                    0 < iterations
                                        ? i < iterations
                                        : i > iterations;
                                    0 < iterations ? i++ : i++
                                ) {
                                    secret = (0, _hash.sha256)(secret);
                                }
                                var new_checksum = (0, _hash.sha256)(secret);
                                if (
                                    !(
                                        new_checksum
                                            .slice(0, 4)
                                            .toString("hex") === checksum
                                    )
                                ) {
                                    throw new Error("wrong password");
                                }
                                return _aes2.default.fromSeed(secret);
                            },

                            /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
                            random32ByteBuffer: function random32ByteBuffer() {
                                var entropy =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : this.browserEntropy();

                                if (!(typeof entropy === "string")) {
                                    throw new Error(
                                        "string required for entropy"
                                    );
                                }

                                if (entropy.length < 32) {
                                    throw new Error(
                                        "expecting at least 32 bytes of entropy"
                                    );
                                }

                                var start_t = Date.now();

                                while (
                                    Date.now() - start_t <
                                    HASH_POWER_MILLS
                                ) {
                                    entropy = (0, _hash.sha256)(entropy);
                                }
                                var hash_array = [];
                                hash_array.push(entropy);

                                // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
                                hash_array.push(
                                    _secureRandom2.default.randomBuffer(32)
                                );

                                return (0, _hash.sha256)(
                                    Buffer.concat(hash_array)
                                );
                            },

                            suggest_brain_key: function suggest_brain_key() {
                                var dictionary =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : ",";
                                var entropy =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : this.browserEntropy();

                                var randomBuffer = this.random32ByteBuffer(
                                    entropy
                                );

                                var word_count = 16;
                                var dictionary_lines = dictionary.split(",");

                                if (!(dictionary_lines.length === 49744)) {
                                    throw new Error(
                                        "expecting " +
                                            49744 +
                                            " but got " +
                                            dictionary_lines.length +
                                            " dictionary words"
                                    );
                                }

                                var brainkey = [];
                                var end = word_count * 2;

                                for (var i = 0; i < end; i += 2) {
                                    // randomBuffer has 256 bits / 16 bits per word == 16 words
                                    var num =
                                        (randomBuffer[i] << 8) +
                                        randomBuffer[i + 1];

                                    // convert into a number between 0 and 1 (inclusive)
                                    var rndMultiplier = num / Math.pow(2, 16);
                                    var wordIndex = Math.round(
                                        dictionary_lines.length * rndMultiplier
                                    );

                                    brainkey.push(dictionary_lines[wordIndex]);
                                }
                                return this.normalize_brainKey(
                                    brainkey.join(" ")
                                );
                            },

                            get_random_key: function get_random_key(entropy) {
                                return _PrivateKey2.default.fromBuffer(
                                    this.random32ByteBuffer(entropy)
                                );
                            },
                            get_brainPrivateKey: function get_brainPrivateKey(
                                brainKey
                            ) {
                                var sequence =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : 0;

                                if (sequence < 0) {
                                    throw new Error("invalid sequence");
                                }
                                brainKey = key.normalize_brainKey(brainKey);
                                return _PrivateKey2.default.fromBuffer(
                                    (0, _hash.sha256)(
                                        (0, _hash.sha512)(
                                            brainKey + " " + sequence
                                        )
                                    )
                                );
                            },

                            // Turn invisible space like characters into a single space
                            normalize_brainKey: function normalize_brainKey(
                                brainKey
                            ) {
                                if (!(typeof brainKey === "string")) {
                                    throw new Error(
                                        "string required for brainKey"
                                    );
                                }

                                brainKey = brainKey.trim();
                                return brainKey
                                    .split(/[\t\n\v\f\r ]+/)
                                    .join(" ");
                            },
                            browserEntropy: function browserEntropy() {
                                var entropyStr = "";
                                try {
                                    entropyStr =
                                        new Date().toString() +
                                        " " +
                                        window.screen.height +
                                        " " +
                                        window.screen.width +
                                        " " +
                                        window.screen.colorDepth +
                                        " " +
                                        " " +
                                        window.screen.availHeight +
                                        " " +
                                        window.screen.availWidth +
                                        " " +
                                        window.screen.pixelDepth +
                                        navigator.language +
                                        " " +
                                        window.location +
                                        " " +
                                        window.history.length;

                                    for (
                                        var i = 0, mimeType;
                                        i < navigator.mimeTypes.length;
                                        i++
                                    ) {
                                        mimeType = navigator.mimeTypes[i];
                                        entropyStr +=
                                            mimeType.description +
                                            " " +
                                            mimeType.type +
                                            " " +
                                            mimeType.suffixes +
                                            " ";
                                    }
                                    console.log(
                                        "INFO\tbrowserEntropy gathered"
                                    );
                                } catch (error) {
                                    //nodejs:ReferenceError: window is not defined
                                    entropyStr = (0, _hash.sha256)(
                                        new Date().toString()
                                    );
                                }

                                var b = new Buffer(entropyStr);
                                entropyStr +=
                                    b.toString("binary") +
                                    " " +
                                    new Date().toString();
                                return entropyStr;
                            },

                            // @return array of 5 legacy addresses for a pubkey string parameter.
                            addresses: function addresses(pubkey) {
                                var address_prefix =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                var public_key = _PublicKey2.default.fromPublicKeyString(
                                    pubkey,
                                    address_prefix
                                );
                                // S L O W
                                var address_string = [
                                    _address2.default
                                        .fromPublic(public_key, false, 0)
                                        .toString(address_prefix), // btc_uncompressed
                                    _address2.default
                                        .fromPublic(public_key, true, 0)
                                        .toString(address_prefix), // btc_compressed
                                    _address2.default
                                        .fromPublic(public_key, false, 56)
                                        .toString(address_prefix), // pts_uncompressed
                                    _address2.default
                                        .fromPublic(public_key, true, 56)
                                        .toString(address_prefix), // pts_compressed
                                    public_key.toAddressString(address_prefix) // bts_short, most recent format
                                ];
                                return address_string;
                            }
                        };

                        exports.default = key;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./PrivateKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PrivateKey.js",
                    "./PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    "./address":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/address.js",
                    "./aes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/aes.js",
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "secure-random":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/secure-random/lib/secure-random.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PrivateKey.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _ecurve = require("ecurve");

                        var _ecurve2 = _interopRequireDefault(_ecurve);

                        var _bigi = require("bigi");

                        var _bigi2 = _interopRequireDefault(_bigi);

                        var _bs = require("bs58");

                        var _hash = require("./hash");

                        var _PublicKey = require("./PublicKey");

                        var _PublicKey2 = _interopRequireDefault(_PublicKey);

                        var _deepEqual = require("deep-equal");

                        var _deepEqual2 = _interopRequireDefault(_deepEqual);

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var secp256k1 = (0, _ecurve.getCurveByName)(
                            "secp256k1"
                        );
                        var G = secp256k1.G,
                            n = secp256k1.n;

                        var PrivateKey = (function() {
                            /**
        @private see static functions
        @param {BigInteger}
    */
                            function PrivateKey(d) {
                                _classCallCheck(this, PrivateKey);

                                this.d = d;
                            }

                            PrivateKey.fromBuffer = function fromBuffer(buf) {
                                if (!Buffer.isBuffer(buf)) {
                                    throw new Error(
                                        "Expecting paramter to be a Buffer type"
                                    );
                                }
                                if (32 !== buf.length) {
                                    console.log(
                                        "WARN: Expecting 32 bytes, instead got " +
                                            buf.length +
                                            ", stack trace:",
                                        new Error().stack
                                    );
                                }
                                if (buf.length === 0) {
                                    throw new Error("Empty buffer");
                                }
                                return new PrivateKey(
                                    _bigi2.default.fromBuffer(buf)
                                );
                            };

                            /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

                            PrivateKey.fromSeed = function fromSeed(seed) {
                                // generate_private_key
                                if (!(typeof seed === "string")) {
                                    throw new Error(
                                        "seed must be of type string"
                                    );
                                }
                                return PrivateKey.fromBuffer(
                                    (0, _hash.sha256)(seed)
                                );
                            };

                            /** @return {string} Wallet Import Format (still a secret, Not encrypted) */

                            PrivateKey.fromWif = function fromWif(
                                _private_wif
                            ) {
                                var private_wif = new Buffer(
                                    (0, _bs.decode)(_private_wif)
                                );
                                var version = private_wif.readUInt8(0);
                                _assert2.default.equal(
                                    0x80,
                                    version,
                                    "Expected version " +
                                        0x80 +
                                        ", instead got " +
                                        version
                                );
                                // checksum includes the version
                                var private_key = private_wif.slice(0, -4);
                                var checksum = private_wif.slice(-4);
                                var new_checksum = (0, _hash.sha256)(
                                    private_key
                                );
                                new_checksum = (0, _hash.sha256)(new_checksum);
                                new_checksum = new_checksum.slice(0, 4);
                                var isEqual = (0, _deepEqual2.default)(
                                    checksum,
                                    new_checksum
                                ); //, 'Invalid checksum'
                                if (!isEqual) {
                                    throw new Error("Checksum did not match");
                                }
                                private_key = private_key.slice(1);
                                return PrivateKey.fromBuffer(private_key);
                            };

                            PrivateKey.prototype.toWif = function toWif() {
                                var private_key = this.toBuffer();
                                // checksum includes the version
                                private_key = Buffer.concat([
                                    new Buffer([0x80]),
                                    private_key
                                ]);
                                var checksum = (0, _hash.sha256)(private_key);
                                checksum = (0, _hash.sha256)(checksum);
                                checksum = checksum.slice(0, 4);
                                var private_wif = Buffer.concat([
                                    private_key,
                                    checksum
                                ]);
                                return (0, _bs.encode)(private_wif);
                            };

                            /**
        @return {Point}
    */

                            PrivateKey.prototype.toPublicKeyPoint = function toPublicKeyPoint() {
                                var Q;
                                return (Q = secp256k1.G.multiply(this.d));
                            };

                            PrivateKey.prototype.toPublicKey = function toPublicKey() {
                                if (this.public_key) {
                                    return this.public_key;
                                }
                                return (this.public_key = _PublicKey2.default.fromPoint(
                                    this.toPublicKeyPoint()
                                ));
                            };

                            PrivateKey.prototype.toBuffer = function toBuffer() {
                                return this.d.toBuffer(32);
                            };

                            /** ECIES */

                            PrivateKey.prototype.get_shared_secret = function get_shared_secret(
                                public_key
                            ) {
                                var legacy =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : false;

                                public_key = toPublic(public_key);
                                var KB = public_key.toUncompressed().toBuffer();
                                var KBP = _ecurve.Point.fromAffine(
                                    secp256k1,
                                    _bigi2.default.fromBuffer(KB.slice(1, 33)), // x
                                    _bigi2.default.fromBuffer(KB.slice(33, 65)) // y
                                );
                                var r = this.toBuffer();
                                var P = KBP.multiply(
                                    _bigi2.default.fromBuffer(r)
                                );
                                var S = P.affineX.toBuffer({size: 32});
                                /*
        the input to sha512 must be exactly 32-bytes, to match the c++ implementation
        of get_shared_secret.  Right now S will be shorter if the most significant
        byte(s) is zero.  Pad it back to the full 32-bytes
        */
                                if (!legacy && S.length < 32) {
                                    var pad = new Buffer(32 - S.length).fill(0);
                                    S = Buffer.concat([pad, S]);
                                }

                                // SHA512 used in ECIES
                                return (0, _hash.sha512)(S);
                            };

                            // /** ECIES (does not always match the Point.fromAffine version above) */
                            // get_shared_secret(public_key){
                            //     public_key = toPublic(public_key)
                            //     var P = public_key.Q.multiply( this.d );
                            //     var S = P.affineX.toBuffer({size: 32});
                            //     // ECIES, adds an extra sha512
                            //     return sha512(S);
                            // }

                            /** @throws {Error} - overflow of the key could not be derived */

                            PrivateKey.prototype.child = function child(
                                offset
                            ) {
                                offset = Buffer.concat([
                                    this.toPublicKey().toBuffer(),
                                    offset
                                ]);
                                offset = (0, _hash.sha256)(offset);
                                var c = _bigi2.default.fromBuffer(offset);

                                if (c.compareTo(n) >= 0)
                                    throw new Error(
                                        "Child offset went out of bounds, try again"
                                    );

                                var derived = this.d.add(c); //.mod(n)

                                if (derived.signum() === 0)
                                    throw new Error(
                                        "Child offset derived to an invalid key, try again"
                                    );

                                return new PrivateKey(derived);
                            };

                            /* <helper_functions> */

                            PrivateKey.prototype.toByteBuffer = function toByteBuffer() {
                                var b = new ByteBuffer(
                                    ByteBuffer.DEFAULT_CAPACITY,
                                    ByteBuffer.LITTLE_ENDIAN
                                );
                                this.appendByteBuffer(b);
                                return b.copy(0, b.offset);
                            };

                            PrivateKey.fromHex = function fromHex(hex) {
                                return PrivateKey.fromBuffer(
                                    new Buffer(hex, "hex")
                                );
                            };

                            PrivateKey.prototype.toHex = function toHex() {
                                return this.toBuffer().toString("hex");
                            };

                            /* </helper_functions> */

                            return PrivateKey;
                        })();

                        exports.default = PrivateKey;

                        var toPublic = function toPublic(data) {
                            return data == null
                                ? data
                                : data.Q
                                    ? data
                                    : _PublicKey2.default.fromStringOrThrow(
                                          data
                                      );
                        };
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    bs58:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bs58/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "deep-equal":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/index.js",
                    ecurve:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _bigi = require("bigi");

                        var _bigi2 = _interopRequireDefault(_bigi);

                        var _ecurve = require("ecurve");

                        var _bs = require("bs58");

                        var _hash = require("./hash");

                        var _bitsharesjsWs = require("bitsharesjs-ws");

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _deepEqual = require("deep-equal");

                        var _deepEqual2 = _interopRequireDefault(_deepEqual);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var secp256k1 = (0, _ecurve.getCurveByName)(
                            "secp256k1"
                        );
                        var G = secp256k1.G,
                            n = secp256k1.n;

                        var PublicKey = (function() {
                            /** @param {Point} public key */
                            function PublicKey(Q) {
                                _classCallCheck(this, PublicKey);

                                this.Q = Q;
                            }

                            PublicKey.fromBinary = function fromBinary(bin) {
                                return PublicKey.fromBuffer(
                                    new Buffer(bin, "binary")
                                );
                            };

                            PublicKey.fromBuffer = function fromBuffer(buffer) {
                                if (
                                    buffer.toString("hex") ===
                                    "000000000000000000000000000000000000000000000000000000000000000000"
                                )
                                    return new PublicKey(null);
                                return new PublicKey(
                                    _ecurve.Point.decodeFrom(secp256k1, buffer)
                                );
                            };

                            PublicKey.prototype.toBuffer = function toBuffer() {
                                var compressed =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : this.Q
                                            ? this.Q.compressed
                                            : null;

                                if (this.Q === null)
                                    return new Buffer(
                                        "000000000000000000000000000000000000000000000000000000000000000000",
                                        "hex"
                                    );
                                return this.Q.getEncoded(compressed);
                            };

                            PublicKey.fromPoint = function fromPoint(point) {
                                return new PublicKey(point);
                            };

                            PublicKey.prototype.toUncompressed = function toUncompressed() {
                                var buf = this.Q.getEncoded(false);
                                var point = _ecurve.Point.decodeFrom(
                                    secp256k1,
                                    buf
                                );
                                return PublicKey.fromPoint(point);
                            };

                            /** bts::blockchain::address (unique but not a full public key) */

                            PublicKey.prototype.toBlockchainAddress = function toBlockchainAddress() {
                                var pub_buf = this.toBuffer();
                                var pub_sha = (0, _hash.sha512)(pub_buf);
                                return (0, _hash.ripemd160)(pub_sha);
                            };

                            /** Alias for {@link toPublicKeyString} */

                            PublicKey.prototype.toString = function toString() {
                                var address_prefix =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                return this.toPublicKeyString(address_prefix);
                            };

                            /**
        Full public key
        {return} string
    */

                            PublicKey.prototype.toPublicKeyString = function toPublicKeyString() {
                                var address_prefix =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                var pub_buf = this.toBuffer();
                                var checksum = (0, _hash.ripemd160)(pub_buf);
                                var addy = Buffer.concat([
                                    pub_buf,
                                    checksum.slice(0, 4)
                                ]);
                                return address_prefix + (0, _bs.encode)(addy);
                            };

                            /**
        @arg {string} public_key - like GPHXyz...
        @arg {string} address_prefix - like GPH
        @return PublicKey or `null` (if the public_key string is invalid)
    */

                            PublicKey.fromPublicKeyString = function fromPublicKeyString(
                                public_key
                            ) {
                                var address_prefix =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                try {
                                    return PublicKey.fromStringOrThrow(
                                        public_key,
                                        address_prefix
                                    );
                                } catch (e) {
                                    return null;
                                }
                            };

                            /**
        @arg {string} public_key - like GPHXyz...
        @arg {string} address_prefix - like GPH
        @throws {Error} if public key is invalid
        @return PublicKey
    */

                            PublicKey.fromStringOrThrow = function fromStringOrThrow(
                                public_key
                            ) {
                                var address_prefix =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                if (public_key.Q === null)
                                    public_key =
                                        address_prefix +
                                        "1111111111111111111111111111111114T1Anm"; // null key
                                var prefix = public_key.slice(
                                    0,
                                    address_prefix.length
                                );
                                _assert2.default.equal(
                                    address_prefix,
                                    prefix,
                                    "Expecting key to begin with " +
                                        address_prefix +
                                        ", instead got " +
                                        prefix
                                );
                                public_key = public_key.slice(
                                    address_prefix.length
                                );

                                public_key = new Buffer(
                                    (0, _bs.decode)(public_key),
                                    "binary"
                                );
                                var checksum = public_key.slice(-4);
                                public_key = public_key.slice(0, -4);
                                var new_checksum = (0, _hash.ripemd160)(
                                    public_key
                                );
                                new_checksum = new_checksum.slice(0, 4);
                                var isEqual = (0, _deepEqual2.default)(
                                    checksum,
                                    new_checksum
                                ); //, 'Invalid checksum'
                                if (!isEqual) {
                                    throw new Error("Checksum did not match");
                                }
                                return PublicKey.fromBuffer(public_key);
                            };

                            PublicKey.prototype.toAddressString = function toAddressString() {
                                var address_prefix =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                var pub_buf = this.toBuffer();
                                var pub_sha = (0, _hash.sha512)(pub_buf);
                                var addy = (0, _hash.ripemd160)(pub_sha);
                                var checksum = (0, _hash.ripemd160)(addy);
                                addy = Buffer.concat([
                                    addy,
                                    checksum.slice(0, 4)
                                ]);
                                return address_prefix + (0, _bs.encode)(addy);
                            };

                            PublicKey.prototype.toPtsAddy = function toPtsAddy() {
                                var pub_buf = this.toBuffer();
                                var pub_sha = (0, _hash.sha256)(pub_buf);
                                var addy = (0, _hash.ripemd160)(pub_sha);
                                addy = Buffer.concat([
                                    new Buffer([0x38]),
                                    addy
                                ]); //version 56(decimal)

                                var checksum = (0, _hash.sha256)(addy);
                                checksum = (0, _hash.sha256)(checksum);

                                addy = Buffer.concat([
                                    addy,
                                    checksum.slice(0, 4)
                                ]);
                                return (0, _bs.encode)(addy);
                            };

                            PublicKey.prototype.child = function child(offset) {
                                (0, _assert2.default)(
                                    Buffer.isBuffer(offset),
                                    "Buffer required: offset"
                                );
                                _assert2.default.equal(
                                    offset.length,
                                    32,
                                    "offset length"
                                );

                                offset = Buffer.concat([
                                    this.toBuffer(),
                                    offset
                                ]);
                                offset = (0, _hash.sha256)(offset);

                                var c = _bigi2.default.fromBuffer(offset);

                                if (c.compareTo(n) >= 0)
                                    throw new Error(
                                        "Child offset went out of bounds, try again"
                                    );

                                var cG = G.multiply(c);
                                var Qprime = this.Q.add(cG);

                                if (secp256k1.isInfinity(Qprime))
                                    throw new Error(
                                        "Child offset derived to an invalid key, try again"
                                    );

                                return PublicKey.fromPoint(Qprime);
                            };

                            /* <HEX> */

                            PublicKey.prototype.toByteBuffer = function toByteBuffer() {
                                var b = new ByteBuffer(
                                    ByteBuffer.DEFAULT_CAPACITY,
                                    ByteBuffer.LITTLE_ENDIAN
                                );
                                this.appendByteBuffer(b);
                                return b.copy(0, b.offset);
                            };

                            PublicKey.fromHex = function fromHex(hex) {
                                return PublicKey.fromBuffer(
                                    new Buffer(hex, "hex")
                                );
                            };

                            PublicKey.prototype.toHex = function toHex() {
                                return this.toBuffer().toString("hex");
                            };

                            PublicKey.fromPublicKeyStringHex = function fromPublicKeyStringHex(
                                hex
                            ) {
                                return PublicKey.fromPublicKeyString(
                                    new Buffer(hex, "hex")
                                );
                            };

                            /* </HEX> */

                            return PublicKey;
                        })();

                        exports.default = PublicKey;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js",
                    bs58:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bs58/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "deep-equal":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/index.js",
                    ecurve:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/address.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _bitsharesjsWs = require("bitsharesjs-ws");

                        var _hash2 = require("./hash");

                        var _bs = require("bs58");

                        var _deepEqual = require("deep-equal");

                        var _deepEqual2 = _interopRequireDefault(_deepEqual);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        /** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/
                        var Address = (function() {
                            function Address(addy) {
                                _classCallCheck(this, Address);

                                this.addy = addy;
                            }

                            Address.fromBuffer = function fromBuffer(buffer) {
                                var _hash = (0, _hash2.sha512)(buffer);
                                var addy = (0, _hash2.ripemd160)(_hash);
                                return new Address(addy);
                            };

                            Address.fromString = function fromString(string) {
                                var address_prefix =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                var prefix = string.slice(
                                    0,
                                    address_prefix.length
                                );
                                _assert2.default.equal(
                                    address_prefix,
                                    prefix,
                                    "Expecting key to begin with " +
                                        address_prefix +
                                        ", instead got " +
                                        prefix
                                );
                                var addy = string.slice(address_prefix.length);
                                addy = new Buffer(
                                    (0, _bs.decode)(addy),
                                    "binary"
                                );
                                var checksum = addy.slice(-4);
                                addy = addy.slice(0, -4);
                                var new_checksum = (0, _hash2.ripemd160)(addy);
                                new_checksum = new_checksum.slice(0, 4);
                                var isEqual = (0, _deepEqual2.default)(
                                    checksum,
                                    new_checksum
                                ); //, 'Invalid checksum'
                                if (!isEqual) {
                                    throw new Error("Checksum did not match");
                                }
                                return new Address(addy);
                            };

                            /** @return Address - Compressed PTS format (by default) */
                            Address.fromPublic = function fromPublic(
                                public_key
                            ) {
                                var compressed =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : true;
                                var version =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : 56;

                                var sha2 = (0, _hash2.sha256)(
                                    public_key.toBuffer(compressed)
                                );
                                var rep = (0, _hash2.ripemd160)(sha2);
                                var versionBuffer = new Buffer(1);
                                versionBuffer.writeUInt8(0xff & version, 0);
                                var addr = Buffer.concat([versionBuffer, rep]);
                                var check = (0, _hash2.sha256)(addr);
                                check = (0, _hash2.sha256)(check);
                                var buffer = Buffer.concat([
                                    addr,
                                    check.slice(0, 4)
                                ]);
                                return new Address(
                                    (0, _hash2.ripemd160)(buffer)
                                );
                            };

                            Address.prototype.toBuffer = function toBuffer() {
                                return this.addy;
                            };

                            Address.prototype.toString = function toString() {
                                var address_prefix =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : _bitsharesjsWs.ChainConfig
                                              .address_prefix;

                                var checksum = (0, _hash2.ripemd160)(this.addy);
                                var addy = Buffer.concat([
                                    this.addy,
                                    checksum.slice(0, 4)
                                ]);
                                return address_prefix + (0, _bs.encode)(addy);
                            };

                            return Address;
                        })();

                        exports.default = Address;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js",
                    bs58:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bs58/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "deep-equal":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/aes.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _aes = require("crypto-js/aes");

                        var _aes2 = _interopRequireDefault(_aes);

                        var _encHex = require("crypto-js/enc-hex");

                        var _encHex2 = _interopRequireDefault(_encHex);

                        var _encBase = require("crypto-js/enc-base64");

                        var _encBase2 = _interopRequireDefault(_encBase);

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _bytebuffer = require("bytebuffer");

                        var _hash2 = require("./hash");

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        } // https://code.google.com/p/crypto-js

                        /** Provides symetric encrypt and decrypt via AES. */
                        var Aes = (function() {
                            /** @private */
                            function Aes(iv, key) {
                                _classCallCheck(this, Aes);

                                (this.iv = iv), (this.key = key);
                            }

                            /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */

                            Aes.prototype.clear = function clear() {
                                return (this.iv = this.key = undefined);
                            };

                            /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */

                            Aes.fromSeed = function fromSeed(seed) {
                                if (seed === undefined) {
                                    throw new Error("seed is required");
                                }
                                var _hash = (0, _hash2.sha512)(seed);
                                _hash = _hash.toString("hex");
                                // DEBUG console.log('... fromSeed _hash',_hash)
                                return Aes.fromSha512(_hash);
                            };

                            /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
                            Aes.fromSha512 = function fromSha512(hash) {
                                _assert2.default.equal(
                                    hash.length,
                                    128,
                                    "A Sha512 in HEX should be 128 characters long, instead got " +
                                        hash.length
                                );
                                var iv = _encHex2.default.parse(
                                    hash.substring(64, 96)
                                );
                                var key = _encHex2.default.parse(
                                    hash.substring(0, 64)
                                );
                                return new Aes(iv, key);
                            };

                            Aes.fromBuffer = function fromBuffer(buf) {
                                (0, _assert2.default)(
                                    Buffer.isBuffer(buf),
                                    "Expecting Buffer"
                                );
                                _assert2.default.equal(
                                    buf.length,
                                    64,
                                    "A Sha512 Buffer should be 64 characters long, instead got " +
                                        buf.length
                                );
                                return Aes.fromSha512(buf.toString("hex"));
                            };
                            /**
        @throws {Error} - "Invalid Key, ..."
        @arg {PrivateKey} private_key - required and used for decryption
        @arg {PublicKey} public_key - required and used to calcualte the shared secret
        @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
        @arg {string|Buffer} message - Encrypted message containing a checksum
        @return {Buffer}
    */

                            Aes.decrypt_with_checksum = function decrypt_with_checksum(
                                private_key,
                                public_key,
                                nonce,
                                message
                            ) {
                                var legacy =
                                    arguments.length > 4 &&
                                    arguments[4] !== undefined
                                        ? arguments[4]
                                        : false;

                                // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
                                if (nonce == null)
                                    // null or undefined
                                    nonce = "";

                                if (!Buffer.isBuffer(message)) {
                                    message = new Buffer(message, "hex");
                                }

                                var S = private_key.get_shared_secret(
                                    public_key,
                                    legacy
                                );
                                // D E B U G
                                // console.log('decrypt_with_checksum', {
                                //     priv_to_pub: private_key.toPublicKey().toString(),
                                //     pub: public_key.toPublicKeyString(),
                                //     nonce: nonce,
                                //     message: message.length,
                                //     S: S.toString('hex')
                                // })

                                var aes = Aes.fromSeed(
                                    Buffer.concat([
                                        // A null or empty string nonce will not effect the hash
                                        new Buffer("" + nonce),
                                        new Buffer(S.toString("hex"))
                                    ])
                                );

                                var planebuffer = aes.decrypt(message);
                                if (!(planebuffer.length >= 4)) {
                                    throw new Error(
                                        "Invalid key, could not decrypt message(1)"
                                    );
                                }

                                // DEBUG console.log('... planebuffer',planebuffer)
                                var checksum = planebuffer.slice(0, 4);
                                var plaintext = planebuffer.slice(4);

                                // console.log('... checksum',checksum.toString('hex'))
                                // console.log('... plaintext',plaintext.toString())

                                var new_checksum = (0, _hash2.sha256)(
                                    plaintext
                                );
                                new_checksum = new_checksum.slice(0, 4);
                                new_checksum = new_checksum.toString("hex");

                                if (
                                    !(checksum.toString("hex") === new_checksum)
                                ) {
                                    throw new Error(
                                        "Invalid key, could not decrypt message(2)"
                                    );
                                }

                                return plaintext;
                            };

                            /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
        @return {Buffer} message - Encrypted message which includes a checksum
    */
                            Aes.encrypt_with_checksum = function encrypt_with_checksum(
                                private_key,
                                public_key,
                                nonce,
                                message
                            ) {
                                // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

                                if (nonce == null)
                                    // null or undefined
                                    nonce = "";

                                if (!Buffer.isBuffer(message)) {
                                    message = new Buffer(message, "binary");
                                }

                                var S = private_key.get_shared_secret(
                                    public_key
                                );

                                // D E B U G
                                // console.log('encrypt_with_checksum', {
                                //     priv_to_pub: private_key.toPublicKey().toString()
                                //     pub: public_key.toPublicKeyString()
                                //     nonce: nonce
                                //     message: message.length
                                //     S: S.toString('hex')
                                // })

                                var aes = Aes.fromSeed(
                                    Buffer.concat([
                                        // A null or empty string nonce will not effect the hash
                                        new Buffer("" + nonce),
                                        new Buffer(S.toString("hex"))
                                    ])
                                );
                                // DEBUG console.log('... S',S.toString('hex'))
                                var checksum = (0, _hash2.sha256)(
                                    message
                                ).slice(0, 4);
                                var payload = Buffer.concat([
                                    checksum,
                                    message
                                ]);
                                // DEBUG console.log('... payload',payload.toString())
                                return aes.encrypt(payload);
                            };

                            /** @private */
                            Aes.prototype._decrypt_word_array = function _decrypt_word_array(
                                cipher
                            ) {
                                // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
                                // see wallet_records.cpp master_key::decrypt_key
                                return _aes2.default.decrypt(
                                    {ciphertext: cipher, salt: null},
                                    this.key,
                                    {iv: this.iv}
                                );
                            };

                            /** @private */

                            Aes.prototype._encrypt_word_array = function _encrypt_word_array(
                                plaintext
                            ) {
                                //https://code.google.com/p/crypto-js/issues/detail?id=85
                                var cipher = _aes2.default.encrypt(
                                    plaintext,
                                    this.key,
                                    {iv: this.iv}
                                );
                                return _encBase2.default.parse(
                                    cipher.toString()
                                );
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} ciphertext
        @return {Buffer} binary
    */

                            Aes.prototype.decrypt = function decrypt(
                                ciphertext
                            ) {
                                if (typeof ciphertext === "string") {
                                    ciphertext = new Buffer(
                                        ciphertext,
                                        "binary"
                                    );
                                }
                                if (!Buffer.isBuffer(ciphertext)) {
                                    throw new Error("buffer required");
                                }
                                (0, _assert2.default)(
                                    ciphertext,
                                    "Missing cipher text"
                                );
                                // hex is the only common format
                                var hex = this.decryptHex(
                                    ciphertext.toString("hex")
                                );
                                return new Buffer(hex, "hex");
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} plaintext
        @return {Buffer} binary
    */

                            Aes.prototype.encrypt = function encrypt(
                                plaintext
                            ) {
                                if (typeof plaintext === "string") {
                                    plaintext = new Buffer(plaintext, "binary");
                                }
                                if (!Buffer.isBuffer(plaintext)) {
                                    throw new Error("buffer required");
                                }
                                //assert plaintext, "Missing plain text"
                                // hex is the only common format
                                var hex = this.encryptHex(
                                    plaintext.toString("hex")
                                );
                                return new Buffer(hex, "hex");
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string|Buffer} plaintext
        @return {string} hex
    */

                            Aes.prototype.encryptToHex = function encryptToHex(
                                plaintext
                            ) {
                                if (typeof plaintext === "string") {
                                    plaintext = new Buffer(plaintext, "binary");
                                }
                                if (!Buffer.isBuffer(plaintext)) {
                                    throw new Error("buffer required");
                                }
                                //assert plaintext, "Missing plain text"
                                // hex is the only common format
                                return this.encryptHex(
                                    plaintext.toString("hex")
                                );
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @return {string} binary (could easily be readable text)
    */

                            Aes.prototype.decryptHex = function decryptHex(
                                cipher
                            ) {
                                (0, _assert2.default)(
                                    cipher,
                                    "Missing cipher text"
                                );
                                // Convert data into word arrays (used by Crypto)
                                var cipher_array = _encHex2.default.parse(
                                    cipher
                                );
                                var plainwords = this._decrypt_word_array(
                                    cipher_array
                                );
                                return _encHex2.default.stringify(plainwords);
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @return {Buffer} encoded as specified by the parameter
    */

                            Aes.prototype.decryptHexToBuffer = function decryptHexToBuffer(
                                cipher
                            ) {
                                (0, _assert2.default)(
                                    cipher,
                                    "Missing cipher text"
                                );
                                // Convert data into word arrays (used by Crypto)
                                var cipher_array = _encHex2.default.parse(
                                    cipher
                                );
                                var plainwords = this._decrypt_word_array(
                                    cipher_array
                                );
                                var plainhex = _encHex2.default.stringify(
                                    plainwords
                                );
                                return new Buffer(plainhex, "hex");
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @arg {string} [encoding = 'binary'] - a valid Buffer encoding
        @return {String} encoded as specified by the parameter
    */

                            Aes.prototype.decryptHexToText = function decryptHexToText(
                                cipher
                            ) {
                                var encoding =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : "binary";

                                return this.decryptHexToBuffer(cipher).toString(
                                    encoding
                                );
                            };

                            /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} plainhex - hex format
        @return {String} hex
    */

                            Aes.prototype.encryptHex = function encryptHex(
                                plainhex
                            ) {
                                var plain_array = _encHex2.default.parse(
                                    plainhex
                                );
                                var cipher_array = this._encrypt_word_array(
                                    plain_array
                                );
                                return _encHex2.default.stringify(cipher_array);
                            };

                            return Aes;
                        })();

                        exports.default = Aes;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    bytebuffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bytebuffer/dist/bytebuffer.js",
                    "crypto-js/aes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/aes.js",
                    "crypto-js/enc-base64":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/enc-base64.js",
                    "crypto-js/enc-hex":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/enc-hex.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/ecdsa.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;
                        exports.verifyRaw = exports.verify = exports.sign = exports.recoverPubKey = exports.deterministicGenerateK = exports.calcPubKeyRecoveryParam = undefined;

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _hash = require("./hash");

                        var _enforce_types = require("./enforce_types");

                        var _enforce_types2 = _interopRequireDefault(
                            _enforce_types
                        );

                        var _bigi = require("bigi");

                        var _bigi2 = _interopRequireDefault(_bigi);

                        var _ecsignature = require("./ecsignature");

                        var _ecsignature2 = _interopRequireDefault(
                            _ecsignature
                        );

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        // https://tools.ietf.org/html/rfc6979#section-3.2
                        // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
                        function deterministicGenerateK(
                            curve,
                            hash,
                            d,
                            checkSig,
                            nonce
                        ) {
                            (0, _enforce_types2.default)("Buffer", hash);
                            (0, _enforce_types2.default)(_bigi2.default, d);

                            if (nonce) {
                                hash = (0, _hash.sha256)(
                                    Buffer.concat([hash, new Buffer(nonce)])
                                );
                            }

                            // sanity check
                            _assert2.default.equal(
                                hash.length,
                                32,
                                "Hash must be 256 bit"
                            );

                            var x = d.toBuffer(32);
                            var k = new Buffer(32);
                            var v = new Buffer(32);

                            // Step B
                            v.fill(1);

                            // Step C
                            k.fill(0);

                            // Step D
                            k = (0, _hash.HmacSHA256)(
                                Buffer.concat([v, new Buffer([0]), x, hash]),
                                k
                            );

                            // Step E
                            v = (0, _hash.HmacSHA256)(v, k);

                            // Step F
                            k = (0, _hash.HmacSHA256)(
                                Buffer.concat([v, new Buffer([1]), x, hash]),
                                k
                            );

                            // Step G
                            v = (0, _hash.HmacSHA256)(v, k);

                            // Step H1/H2a, ignored as tlen === qlen (256 bit)
                            // Step H2b
                            v = (0, _hash.HmacSHA256)(v, k);

                            var T = _bigi2.default.fromBuffer(v);

                            // Step H3, repeat until T is within the interval [1, n - 1]
                            while (
                                T.signum() <= 0 ||
                                T.compareTo(curve.n) >= 0 ||
                                !checkSig(T)
                            ) {
                                k = (0, _hash.HmacSHA256)(
                                    Buffer.concat([v, new Buffer([0])]),
                                    k
                                );
                                v = (0, _hash.HmacSHA256)(v, k);

                                // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
                                // Step H2b again
                                v = (0, _hash.HmacSHA256)(v, k);

                                T = _bigi2.default.fromBuffer(v);
                            }

                            return T;
                        }

                        function sign(curve, hash, d, nonce) {
                            var e = _bigi2.default.fromBuffer(hash);
                            var n = curve.n;
                            var G = curve.G;

                            var r, s;
                            var k = deterministicGenerateK(
                                curve,
                                hash,
                                d,
                                function(k) {
                                    // find canonically valid signature
                                    var Q = G.multiply(k);

                                    if (curve.isInfinity(Q)) return false;

                                    r = Q.affineX.mod(n);
                                    if (r.signum() === 0) return false;

                                    s = k
                                        .modInverse(n)
                                        .multiply(e.add(d.multiply(r)))
                                        .mod(n);
                                    if (s.signum() === 0) return false;

                                    return true;
                                },
                                nonce
                            );

                            var N_OVER_TWO = n.shiftRight(1);

                            // enforce low S values, see bip62: 'low s values in signatures'
                            if (s.compareTo(N_OVER_TWO) > 0) {
                                s = n.subtract(s);
                            }

                            return new _ecsignature2.default(r, s);
                        }

                        function verifyRaw(curve, e, signature, Q) {
                            var n = curve.n;
                            var G = curve.G;

                            var r = signature.r;
                            var s = signature.s;

                            // 1.4.1 Enforce r and s are both integers in the interval [1, n  1]
                            if (r.signum() <= 0 || r.compareTo(n) >= 0)
                                return false;
                            if (s.signum() <= 0 || s.compareTo(n) >= 0)
                                return false;

                            // c = s^-1 mod n
                            var c = s.modInverse(n);

                            // 1.4.4 Compute u1 = es^1 mod n
                            //               u2 = rs^1 mod n
                            var u1 = e.multiply(c).mod(n);
                            var u2 = r.multiply(c).mod(n);

                            // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
                            var R = G.multiplyTwo(u1, Q, u2);

                            // 1.4.5 (cont.) Enforce R is not at infinity
                            if (curve.isInfinity(R)) return false;

                            // 1.4.6 Convert the field element R.x to an integer
                            var xR = R.affineX;

                            // 1.4.7 Set v = xR mod n
                            var v = xR.mod(n);

                            // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
                            return v.equals(r);
                        }

                        function verify(curve, hash, signature, Q) {
                            // 1.4.2 H = Hash(M), already done by the user
                            // 1.4.3 e = H
                            var e = _bigi2.default.fromBuffer(hash);
                            return verifyRaw(curve, e, signature, Q);
                        }

                        /**
                         * Recover a public key from a signature.
                         *
                         * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
                         * Key Recovery Operation".
                         *
                         * http://www.secg.org/download/aid-780/sec1-v2.pdf
                         */
                        function recoverPubKey(curve, e, signature, i) {
                            _assert2.default.strictEqual(
                                i & 3,
                                i,
                                "Recovery param is more than two bits"
                            );

                            var n = curve.n;
                            var G = curve.G;

                            var r = signature.r;
                            var s = signature.s;

                            (0, _assert2.default)(
                                r.signum() > 0 && r.compareTo(n) < 0,
                                "Invalid r value"
                            );
                            (0, _assert2.default)(
                                s.signum() > 0 && s.compareTo(n) < 0,
                                "Invalid s value"
                            );

                            // A set LSB signifies that the y-coordinate is odd
                            var isYOdd = i & 1;

                            // The more significant bit specifies whether we should use the
                            // first or second candidate key.
                            var isSecondKey = i >> 1;

                            // 1.1 Let x = r + jn
                            var x = isSecondKey ? r.add(n) : r;
                            var R = curve.pointFromX(isYOdd, x);

                            // 1.4 Check that nR is at infinity
                            var nR = R.multiply(n);
                            (0, _assert2.default)(
                                curve.isInfinity(nR),
                                "nR is not a valid curve point"
                            );

                            // Compute -e from e
                            var eNeg = e.negate().mod(n);

                            // 1.6.1 Compute Q = r^-1 (sR -  eG)
                            //               Q = r^-1 (sR + -eG)
                            var rInv = r.modInverse(n);

                            var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
                            curve.validate(Q);

                            return Q;
                        }

                        /**
                         * Calculate pubkey extraction parameter.
                         *
                         * When extracting a pubkey from a signature, we have to
                         * distinguish four different cases. Rather than putting this
                         * burden on the verifier, Bitcoin includes a 2-bit value with the
                         * signature.
                         *
                         * This function simply tries all four cases and returns the value
                         * that resulted in a successful pubkey recovery.
                         */
                        function calcPubKeyRecoveryParam(
                            curve,
                            e,
                            signature,
                            Q
                        ) {
                            for (var i = 0; i < 4; i++) {
                                var Qprime = recoverPubKey(
                                    curve,
                                    e,
                                    signature,
                                    i
                                );

                                // 1.6.2 Verify Q
                                if (Qprime.equals(Q)) {
                                    return i;
                                }
                            }

                            throw new Error(
                                "Unable to find valid recovery factor"
                            );
                        }

                        exports.calcPubKeyRecoveryParam = calcPubKeyRecoveryParam;
                        exports.deterministicGenerateK = deterministicGenerateK;
                        exports.recoverPubKey = recoverPubKey;
                        exports.sign = sign;
                        exports.verify = verify;
                        exports.verifyRaw = verifyRaw;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./ecsignature":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/ecsignature.js",
                    "./enforce_types":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/enforce_types.js",
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/ecsignature.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _enforce_types = require("./enforce_types");

                        var _enforce_types2 = _interopRequireDefault(
                            _enforce_types
                        );

                        var _bigi = require("bigi");

                        var _bigi2 = _interopRequireDefault(_bigi);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        // from https://github.com/bitcoinjs/bitcoinjs-lib
                        function ECSignature(r, s) {
                            (0, _enforce_types2.default)(_bigi2.default, r);
                            (0, _enforce_types2.default)(_bigi2.default, s);

                            this.r = r;
                            this.s = s;
                        }

                        // Import operations
                        ECSignature.parseCompact = function(buffer) {
                            _assert2.default.equal(
                                buffer.length,
                                65,
                                "Invalid signature length"
                            );
                            var i = buffer.readUInt8(0) - 27;

                            // At most 3 bits
                            _assert2.default.equal(
                                i,
                                i & 7,
                                "Invalid signature parameter"
                            );
                            var compressed = !!(i & 4);

                            // Recovery param only
                            i = i & 3;

                            var r = _bigi2.default.fromBuffer(
                                buffer.slice(1, 33)
                            );
                            var s = _bigi2.default.fromBuffer(buffer.slice(33));

                            return {
                                compressed: compressed,
                                i: i,
                                signature: new ECSignature(r, s)
                            };
                        };

                        ECSignature.fromDER = function(buffer) {
                            _assert2.default.equal(
                                buffer.readUInt8(0),
                                0x30,
                                "Not a DER sequence"
                            );
                            _assert2.default.equal(
                                buffer.readUInt8(1),
                                buffer.length - 2,
                                "Invalid sequence length"
                            );
                            _assert2.default.equal(
                                buffer.readUInt8(2),
                                0x02,
                                "Expected a DER integer"
                            );

                            var rLen = buffer.readUInt8(3);
                            (0, _assert2.default)(rLen > 0, "R length is zero");

                            var offset = 4 + rLen;
                            _assert2.default.equal(
                                buffer.readUInt8(offset),
                                0x02,
                                "Expected a DER integer (2)"
                            );

                            var sLen = buffer.readUInt8(offset + 1);
                            (0, _assert2.default)(sLen > 0, "S length is zero");

                            var rB = buffer.slice(4, offset);
                            var sB = buffer.slice(offset + 2);
                            offset += 2 + sLen;

                            if (rLen > 1 && rB.readUInt8(0) === 0x00) {
                                (0, _assert2.default)(
                                    rB.readUInt8(1) & 0x80,
                                    "R value excessively padded"
                                );
                            }

                            if (sLen > 1 && sB.readUInt8(0) === 0x00) {
                                (0, _assert2.default)(
                                    sB.readUInt8(1) & 0x80,
                                    "S value excessively padded"
                                );
                            }

                            _assert2.default.equal(
                                offset,
                                buffer.length,
                                "Invalid DER encoding"
                            );
                            var r = _bigi2.default.fromDERInteger(rB);
                            var s = _bigi2.default.fromDERInteger(sB);

                            (0, _assert2.default)(
                                r.signum() >= 0,
                                "R value is negative"
                            );
                            (0, _assert2.default)(
                                s.signum() >= 0,
                                "S value is negative"
                            );

                            return new ECSignature(r, s);
                        };

                        // FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
                        ECSignature.parseScriptSignature = function(buffer) {
                            var hashType = buffer.readUInt8(buffer.length - 1);
                            var hashTypeMod = hashType & ~0x80;

                            (0, _assert2.default)(
                                hashTypeMod > 0x00 && hashTypeMod < 0x04,
                                "Invalid hashType"
                            );

                            return {
                                signature: ECSignature.fromDER(
                                    buffer.slice(0, -1)
                                ),
                                hashType: hashType
                            };
                        };

                        // Export operations
                        ECSignature.prototype.toCompact = function(
                            i,
                            compressed
                        ) {
                            if (compressed) i += 4;
                            i += 27;

                            var buffer = new Buffer(65);
                            buffer.writeUInt8(i, 0);

                            this.r.toBuffer(32).copy(buffer, 1);
                            this.s.toBuffer(32).copy(buffer, 33);

                            return buffer;
                        };

                        ECSignature.prototype.toDER = function() {
                            var rBa = this.r.toDERInteger();
                            var sBa = this.s.toDERInteger();

                            var sequence = [];

                            // INTEGER
                            sequence.push(0x02, rBa.length);
                            sequence = sequence.concat(rBa);

                            // INTEGER
                            sequence.push(0x02, sBa.length);
                            sequence = sequence.concat(sBa);

                            // SEQUENCE
                            sequence.unshift(0x30, sequence.length);

                            return new Buffer(sequence);
                        };

                        ECSignature.prototype.toScriptSignature = function(
                            hashType
                        ) {
                            var hashTypeBuffer = new Buffer(1);
                            hashTypeBuffer.writeUInt8(hashType, 0);

                            return Buffer.concat([
                                this.toDER(),
                                hashTypeBuffer
                            ]);
                        };

                        exports.default = ECSignature;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./enforce_types":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/enforce_types.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/enforce_types.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;
                        exports.default = enforce;
                        function enforce(type, value) {
                            // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
                            switch (type) {
                                case "Array": {
                                    if (Array.isArray(value)) return;
                                    break;
                                }

                                case "Boolean": {
                                    if (typeof value === "boolean") return;
                                    break;
                                }

                                case "Buffer": {
                                    if (Buffer.isBuffer(value)) return;
                                    break;
                                }

                                case "Number": {
                                    if (typeof value === "number") return;
                                    break;
                                }

                                case "String": {
                                    if (typeof value === "string") return;
                                    break;
                                }

                                default: {
                                    if (
                                        getName(value.constructor) ===
                                        getName(type)
                                    )
                                        return;
                                }
                            }

                            throw new TypeError(
                                "Expected " +
                                    (getName(type) || type) +
                                    ", got " +
                                    value
                            );
                        }

                        function getName(fn) {
                            // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
                            var match = fn.toString().match(/function (.*?)\(/);
                            return match ? match[1] : null;
                        }
                        module.exports = exports["default"];
                    }.call(this, {
                        isBuffer: require("../../../node_modules/is-buffer/index.js")
                    }));
                },
                {
                    "../../../node_modules/is-buffer/index.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/is-buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.ripemd160 = exports.HmacSHA256 = exports.sha512 = exports.sha256 = exports.sha1 = undefined;

                    var _createHash = require("create-hash");

                    var _createHash2 = _interopRequireDefault(_createHash);

                    var _createHmac = require("create-hmac");

                    var _createHmac2 = _interopRequireDefault(_createHmac);

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    /** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
                    function sha1(data, encoding) {
                        return (0, _createHash2.default)("sha1")
                            .update(data)
                            .digest(encoding);
                    }

                    /** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
                    function sha256(data, encoding) {
                        return (0, _createHash2.default)("sha256")
                            .update(data)
                            .digest(encoding);
                    }

                    /** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
                    function sha512(data, encoding) {
                        return (0, _createHash2.default)("sha512")
                            .update(data)
                            .digest(encoding);
                    }

                    function HmacSHA256(buffer, secret) {
                        return (0, _createHmac2.default)("sha256", secret)
                            .update(buffer)
                            .digest();
                    }

                    function ripemd160(data) {
                        return (0, _createHash2.default)("rmd160")
                            .update(data)
                            .digest();
                    }

                    // function hash160(buffer) {
                    //   return ripemd160(sha256(buffer))
                    // }
                    //
                    // function hash256(buffer) {
                    //   return sha256(sha256(buffer))
                    // }

                    //
                    // function HmacSHA512(buffer, secret) {
                    //   return crypto.createHmac('sha512', secret).update(buffer).digest()
                    // }

                    exports.sha1 = sha1;
                    exports.sha256 = sha256;
                    exports.sha512 = sha512;
                    exports.HmacSHA256 = HmacSHA256;
                    exports.ripemd160 = ripemd160;
                },
                {
                    "create-hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hash/browser.js",
                    "create-hmac":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hmac/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/signature.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _ecdsa = require("./ecdsa");

                        var _hash2 = require("./hash");

                        var _ecurve = require("ecurve");

                        var _assert = require("assert");

                        var _assert2 = _interopRequireDefault(_assert);

                        var _bigi = require("bigi");

                        var _bigi2 = _interopRequireDefault(_bigi);

                        var _PublicKey = require("./PublicKey");

                        var _PublicKey2 = _interopRequireDefault(_PublicKey);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var secp256k1 = (0, _ecurve.getCurveByName)(
                            "secp256k1"
                        );

                        var Signature = (function() {
                            function Signature(r1, s1, i1) {
                                _classCallCheck(this, Signature);

                                this.r = r1;
                                this.s = s1;
                                this.i = i1;
                                _assert2.default.equal(
                                    this.r != null,
                                    true,
                                    "Missing parameter"
                                );
                                _assert2.default.equal(
                                    this.s != null,
                                    true,
                                    "Missing parameter"
                                );
                                _assert2.default.equal(
                                    this.i != null,
                                    true,
                                    "Missing parameter"
                                );
                            }

                            Signature.fromBuffer = function fromBuffer(buf) {
                                var i, r, s;
                                _assert2.default.equal(
                                    buf.length,
                                    65,
                                    "Invalid signature length"
                                );
                                i = buf.readUInt8(0);
                                _assert2.default.equal(
                                    i - 27,
                                    (i - 27) & 7,
                                    "Invalid signature parameter"
                                );
                                r = _bigi2.default.fromBuffer(buf.slice(1, 33));
                                s = _bigi2.default.fromBuffer(buf.slice(33));
                                return new Signature(r, s, i);
                            };

                            Signature.prototype.toBuffer = function toBuffer() {
                                var buf;
                                buf = new Buffer(65);
                                buf.writeUInt8(this.i, 0);
                                this.r.toBuffer(32).copy(buf, 1);
                                this.s.toBuffer(32).copy(buf, 33);
                                return buf;
                            };

                            Signature.prototype.recoverPublicKeyFromBuffer = function recoverPublicKeyFromBuffer(
                                buffer
                            ) {
                                return this.recoverPublicKey(
                                    (0, _hash2.sha256)(buffer)
                                );
                            };

                            /**
        @return {PublicKey}
    */
                            Signature.prototype.recoverPublicKey = function recoverPublicKey(
                                sha256_buffer
                            ) {
                                var Q = void 0,
                                    e = void 0,
                                    i = void 0;
                                e = _bigi2.default.fromBuffer(sha256_buffer);
                                i = this.i;
                                i -= 27;
                                i = i & 3;
                                Q = (0, _ecdsa.recoverPubKey)(
                                    secp256k1,
                                    e,
                                    this,
                                    i
                                );
                                return _PublicKey2.default.fromPoint(Q);
                            };

                            /**
        @param {Buffer} buf
        @param {PrivateKey} private_key
        @return {Signature}
    */
                            Signature.signBuffer = function signBuffer(
                                buf,
                                private_key
                            ) {
                                var _hash = (0, _hash2.sha256)(buf);
                                return Signature.signBufferSha256(
                                    _hash,
                                    private_key
                                );
                            };

                            /** Sign a buffer of exactally 32 bytes in size (sha256(text))
        @param {Buffer} buf - 32 bytes binary
        @param {PrivateKey} private_key
        @return {Signature}
    */

                            Signature.signBufferSha256 = function signBufferSha256(
                                buf_sha256,
                                private_key
                            ) {
                                if (
                                    buf_sha256.length !== 32 ||
                                    !Buffer.isBuffer(buf_sha256)
                                )
                                    throw new Error(
                                        "buf_sha256: 32 byte buffer requred"
                                    );
                                var der, e, ecsignature, i, lenR, lenS, nonce;
                                i = null;
                                nonce = 0;
                                e = _bigi2.default.fromBuffer(buf_sha256);
                                while (true) {
                                    ecsignature = (0, _ecdsa.sign)(
                                        secp256k1,
                                        buf_sha256,
                                        private_key.d,
                                        nonce++
                                    );
                                    der = ecsignature.toDER();
                                    lenR = der[3];
                                    lenS = der[5 + lenR];
                                    if (lenR === 32 && lenS === 32) {
                                        i = (0, _ecdsa.calcPubKeyRecoveryParam)(
                                            secp256k1,
                                            e,
                                            ecsignature,
                                            private_key.toPublicKey().Q
                                        );
                                        i += 4; // compressed
                                        i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                                        break;
                                    }
                                    if (nonce % 10 === 0) {
                                        console.log(
                                            "WARN: " +
                                                nonce +
                                                " attempts to find canonical signature"
                                        );
                                    }
                                }
                                return new Signature(
                                    ecsignature.r,
                                    ecsignature.s,
                                    i
                                );
                            };

                            Signature.sign = function sign(
                                string,
                                private_key
                            ) {
                                return Signature.signBuffer(
                                    new Buffer(string),
                                    private_key
                                );
                            };

                            /**
        @param {Buffer} un-hashed
        @param {./PublicKey}
        @return {boolean}
    */
                            Signature.prototype.verifyBuffer = function verifyBuffer(
                                buf,
                                public_key
                            ) {
                                var _hash = (0, _hash2.sha256)(buf);
                                return this.verifyHash(_hash, public_key);
                            };

                            Signature.prototype.verifyHash = function verifyHash(
                                hash,
                                public_key
                            ) {
                                _assert2.default.equal(
                                    hash.length,
                                    32,
                                    "A SHA 256 should be 32 bytes long, instead got " +
                                        hash.length
                                );
                                return (0, _ecdsa.verify)(
                                    secp256k1,
                                    hash,
                                    {
                                        r: this.r,
                                        s: this.s
                                    },
                                    public_key.Q
                                );
                            };

                            /* <HEX> */

                            Signature.prototype.toByteBuffer = function toByteBuffer() {
                                var b;
                                b = new ByteBuffer(
                                    ByteBuffer.DEFAULT_CAPACITY,
                                    ByteBuffer.LITTLE_ENDIAN
                                );
                                this.appendByteBuffer(b);
                                return b.copy(0, b.offset);
                            };

                            Signature.fromHex = function fromHex(hex) {
                                return Signature.fromBuffer(
                                    new Buffer(hex, "hex")
                                );
                            };

                            Signature.prototype.toHex = function toHex() {
                                return this.toBuffer().toString("hex");
                            };

                            Signature.signHex = function signHex(
                                hex,
                                private_key
                            ) {
                                var buf;
                                buf = new Buffer(hex, "hex");
                                return Signature.signBuffer(buf, private_key);
                            };

                            Signature.prototype.verifyHex = function verifyHex(
                                hex,
                                public_key
                            ) {
                                var buf;
                                buf = new Buffer(hex, "hex");
                                return this.verifyBuffer(buf, public_key);
                            };

                            return Signature;
                        })();

                        exports.default = Signature;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    "./ecdsa":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/ecdsa.js",
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/hash.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    ecurve:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/index.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.SerializerValidation = exports.template = exports.ops = exports.types = exports.fp = exports.Serializer = undefined;

                    var _serializer = require("./src/serializer");

                    var _serializer2 = _interopRequireDefault(_serializer);

                    var _FastParser = require("./src/FastParser");

                    var _FastParser2 = _interopRequireDefault(_FastParser);

                    var _types = require("./src/types");

                    var _types2 = _interopRequireDefault(_types);

                    var _operations = require("./src/operations");

                    var ops = _interopRequireWildcard(_operations);

                    var _template = require("./src/template");

                    var _template2 = _interopRequireDefault(_template);

                    var _SerializerValidation = require("./src/SerializerValidation");

                    var _SerializerValidation2 = _interopRequireDefault(
                        _SerializerValidation
                    );

                    function _interopRequireWildcard(obj) {
                        if (obj && obj.__esModule) {
                            return obj;
                        } else {
                            var newObj = {};
                            if (obj != null) {
                                for (var key in obj) {
                                    if (
                                        Object.prototype.hasOwnProperty.call(
                                            obj,
                                            key
                                        )
                                    )
                                        newObj[key] = obj[key];
                                }
                            }
                            newObj.default = obj;
                            return newObj;
                        }
                    }

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    exports.Serializer = _serializer2.default;
                    exports.fp = _FastParser2.default;
                    exports.types = _types2.default;
                    exports.ops = ops;
                    exports.template = _template2.default;
                    exports.SerializerValidation =
                        _SerializerValidation2.default;
                },
                {
                    "./src/FastParser":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/FastParser.js",
                    "./src/SerializerValidation":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/SerializerValidation.js",
                    "./src/operations":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/operations.js",
                    "./src/serializer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/serializer.js",
                    "./src/template":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/template.js",
                    "./src/types":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/types.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/FastParser.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _PublicKey = require("../../ecc/src/PublicKey");

                        var _PublicKey2 = _interopRequireDefault(_PublicKey);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var FastParser = (function() {
                            function FastParser() {
                                _classCallCheck(this, FastParser);
                            }

                            FastParser.fixed_data = function fixed_data(
                                b,
                                len,
                                buffer
                            ) {
                                if (!b) {
                                    return;
                                }
                                if (buffer) {
                                    var data = buffer
                                        .slice(0, len)
                                        .toString("binary");
                                    b.append(data, "binary");
                                    while (len-- > data.length) {
                                        b.writeUint8(0);
                                    }
                                } else {
                                    var b_copy = b.copy(
                                        b.offset,
                                        b.offset + len
                                    );
                                    b.skip(len);
                                    return new Buffer(
                                        b_copy.toBinary(),
                                        "binary"
                                    );
                                }
                            };

                            FastParser.public_key = function public_key(
                                b,
                                _public_key
                            ) {
                                if (!b) {
                                    return;
                                }
                                if (_public_key) {
                                    var buffer = _public_key.toBuffer();
                                    b.append(
                                        buffer.toString("binary"),
                                        "binary"
                                    );
                                    return;
                                } else {
                                    buffer = FastParser.fixed_data(b, 33);
                                    return _PublicKey2.default.fromBuffer(
                                        buffer
                                    );
                                }
                            };

                            FastParser.ripemd160 = function ripemd160(
                                b,
                                _ripemd
                            ) {
                                if (!b) {
                                    return;
                                }
                                if (_ripemd) {
                                    FastParser.fixed_data(b, 20, _ripemd);
                                    return;
                                } else {
                                    return FastParser.fixed_data(b, 20);
                                }
                            };

                            FastParser.time_point_sec = function time_point_sec(
                                b,
                                epoch
                            ) {
                                if (epoch) {
                                    epoch = Math.ceil(epoch / 1000);
                                    b.writeInt32(epoch);
                                    return;
                                } else {
                                    epoch = b.readInt32(); // fc::time_point_sec
                                    return new Date(epoch * 1000);
                                }
                            };

                            return FastParser;
                        })();

                        exports.default = FastParser;
                        module.exports = exports["default"];
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "../../ecc/src/PublicKey":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/src/PublicKey.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/SerializerValidation.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    var _typeof =
                        typeof Symbol === "function" &&
                        typeof Symbol.iterator === "symbol"
                            ? function(obj) {
                                  return typeof obj;
                              }
                            : function(obj) {
                                  return obj &&
                                      typeof Symbol === "function" &&
                                      obj.constructor === Symbol &&
                                      obj !== Symbol.prototype
                                      ? "symbol"
                                      : typeof obj;
                              };

                    var _bytebuffer = require("bytebuffer");

                    var _ChainTypes = require("../../chain/src/ChainTypes");

                    var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    var MAX_SAFE_INT = 9007199254740991;
                    var MIN_SAFE_INT = -9007199254740991;

                    /**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required").

    Validations support a string format for dealing with large numbers.
*/
                    var _my = {
                        is_empty: function is_empty(value) {
                            return value === null || value === undefined;
                        },

                        required: function required(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (this.is_empty(value)) {
                                throw new Error(
                                    "value required " + field_name + " " + value
                                );
                            }
                            return value;
                        },
                        require_long: function require_long(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (!_bytebuffer.Long.isLong(value)) {
                                throw new Error(
                                    "Long value required " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return value;
                        },
                        string: function string(value) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (typeof value !== "string") {
                                throw new Error("string required: " + value);
                            }
                            return value;
                        },
                        number: function number(value) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (typeof value !== "number") {
                                throw new Error("number required: " + value);
                            }
                            return value;
                        },
                        whole_number: function whole_number(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (/\./.test(value)) {
                                throw new Error(
                                    "whole number required " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return value;
                        },
                        unsigned: function unsigned(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (/-/.test(value)) {
                                throw new Error(
                                    "unsigned required " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return value;
                        },

                        is_digits: function is_digits(value) {
                            if (typeof value === "numeric") {
                                return true;
                            }
                            return /^[0-9]+$/.test(value);
                        },

                        to_number: function to_number(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.no_overflow53(value, field_name);
                            var int_value = (function() {
                                if (typeof value === "number") {
                                    return value;
                                } else {
                                    return parseInt(value);
                                }
                            })();
                            return int_value;
                        },

                        to_long: function to_long(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";
                            var unsigned =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : false;

                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (_bytebuffer.Long.isLong(value)) {
                                return value;
                            }

                            this.no_overflow64(value, field_name, unsigned);
                            if (typeof value === "number") {
                                value = "" + value;
                            }
                            return _bytebuffer.Long.fromString(value, unsigned);
                        },
                        to_string: function to_string(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (typeof value === "string") {
                                return value;
                            }
                            if (typeof value === "number") {
                                this.no_overflow53(value, field_name);
                                return "" + value;
                            }
                            if (_bytebuffer.Long.isLong(value)) {
                                return value.toString();
                            }
                            throw "unsupported type " +
                                field_name +
                                ": (" +
                                (typeof value === "undefined"
                                    ? "undefined"
                                    : _typeof(value)) +
                                ") " +
                                value;
                        },
                        require_test: function require_test(regex, value) {
                            var field_name =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            if (!regex.test(value)) {
                                throw new Error(
                                    "unmatched " +
                                        regex +
                                        " " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return value;
                        },

                        require_match: function require_match(regex, value) {
                            var field_name =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            var match = value.match(regex);
                            if (match === null) {
                                throw new Error(
                                    "unmatched " +
                                        regex +
                                        " " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return match;
                        },

                        require_object_id: function require_object_id(
                            value,
                            field_name
                        ) {
                            return require_match(
                                /^([0-9]+)\.([0-9]+)\.([0-9]+)$/,
                                value,
                                field_name
                            );
                        },

                        // Does not support over 53 bits
                        require_range: function require_range(min, max, value) {
                            var field_name =
                                arguments.length > 3 &&
                                arguments[3] !== undefined
                                    ? arguments[3]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            var number = this.to_number(value);
                            if (value < min || value > max) {
                                throw new Error(
                                    "out of range " +
                                        value +
                                        " " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            return value;
                        },

                        require_object_type: function require_object_type() {
                            var reserved_spaces =
                                arguments.length > 0 &&
                                arguments[0] !== undefined
                                    ? arguments[0]
                                    : 1;
                            var type = arguments[1];
                            var value = arguments[2];
                            var field_name =
                                arguments.length > 3 &&
                                arguments[3] !== undefined
                                    ? arguments[3]
                                    : "";

                            if (this.is_empty(value)) {
                                return value;
                            }
                            var object_type =
                                _ChainTypes2.default.object_type[type];
                            if (!object_type) {
                                throw new Error(
                                    "Unknown object type " +
                                        type +
                                        " " +
                                        field_name +
                                        " " +
                                        value
                                );
                            }
                            var re = new RegExp(
                                reserved_spaces + "." + object_type + ".[0-9]+$"
                            );
                            if (!re.test(value)) {
                                throw new Error(
                                    "Expecting " +
                                        type +
                                        " in format " +
                                        (reserved_spaces +
                                            "." +
                                            object_type +
                                            ".[0-9]+ ") +
                                        ("instead of " +
                                            value +
                                            " " +
                                            field_name +
                                            " " +
                                            value)
                                );
                            }
                            return value;
                        },

                        get_instance: function get_instance(
                            reserve_spaces,
                            type,
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.require_object_type(
                                reserve_spaces,
                                type,
                                value,
                                field_name
                            );
                            return this.to_number(value.split(".")[2]);
                        },

                        require_relative_type: function require_relative_type(
                            type,
                            value,
                            field_name
                        ) {
                            this.require_object_type(
                                0,
                                type,
                                value,
                                field_name
                            );
                            return value;
                        },

                        get_relative_instance: function get_relative_instance(
                            type,
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.require_object_type(
                                0,
                                type,
                                value,
                                field_name
                            );
                            return this.to_number(value.split(".")[2]);
                        },

                        require_protocol_type: function require_protocol_type(
                            type,
                            value,
                            field_name
                        ) {
                            this.require_object_type(
                                1,
                                type,
                                value,
                                field_name
                            );
                            return value;
                        },

                        get_protocol_instance: function get_protocol_instance(
                            type,
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.require_object_type(
                                1,
                                type,
                                value,
                                field_name
                            );
                            return this.to_number(value.split(".")[2]);
                        },

                        get_protocol_type: function get_protocol_type(
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.require_object_id(value, field_name);
                            var values = value.split(".");
                            return this.to_number(values[1]);
                        },

                        get_protocol_type_name: function get_protocol_type_name(
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            var type_id = this.get_protocol_type(
                                value,
                                field_name
                            );
                            return Object.keys(
                                _ChainTypes2.default.object_type
                            )[type_id];
                        },

                        require_implementation_type: function require_implementation_type(
                            type,
                            value,
                            field_name
                        ) {
                            this.require_object_type(
                                2,
                                type,
                                value,
                                field_name
                            );
                            return value;
                        },

                        get_implementation_instance: function get_implementation_instance(
                            type,
                            value,
                            field_name
                        ) {
                            if (this.is_empty(value)) {
                                return value;
                            }
                            this.require_object_type(
                                2,
                                type,
                                value,
                                field_name
                            );
                            return this.to_number(value.split(".")[2]);
                        },

                        // signed / unsigned decimal
                        no_overflow53: function no_overflow53(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            if (typeof value === "number") {
                                if (
                                    value > MAX_SAFE_INT ||
                                    value < MIN_SAFE_INT
                                ) {
                                    throw new Error(
                                        "overflow " + field_name + " " + value
                                    );
                                }
                                return;
                            }
                            if (typeof value === "string") {
                                var int = parseInt(value);
                                if (
                                    value > MAX_SAFE_INT ||
                                    value < MIN_SAFE_INT
                                ) {
                                    throw new Error(
                                        "overflow " + field_name + " " + value
                                    );
                                }
                                return;
                            }
                            if (_bytebuffer.Long.isLong(value)) {
                                // typeof value.toInt() is 'number'
                                this.no_overflow53(value.toInt(), field_name);
                                return;
                            }
                            throw "unsupported type " +
                                field_name +
                                ": (" +
                                (typeof value === "undefined"
                                    ? "undefined"
                                    : _typeof(value)) +
                                ") " +
                                value;
                        },

                        // signed / unsigned whole numbers only
                        no_overflow64: function no_overflow64(value) {
                            var field_name =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";
                            var unsigned =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : false;

                            // https://github.com/dcodeIO/Long.js/issues/20
                            if (_bytebuffer.Long.isLong(value)) {
                                return;
                            }

                            // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
                            if (
                                value.t !== undefined &&
                                value.s !== undefined
                            ) {
                                this.no_overflow64(
                                    value.toString(),
                                    field_name,
                                    unsigned
                                );
                                return;
                            }

                            if (typeof value === "string") {
                                // remove leading zeros, will cause a false positive
                                value = value.replace(/^0+/, "");
                                // remove trailing zeros
                                while (/0$/.test(value)) {
                                    value = value.substring(
                                        0,
                                        value.length - 1
                                    );
                                }
                                if (/\.$/.test(value)) {
                                    // remove trailing dot
                                    value = value.substring(
                                        0,
                                        value.length - 1
                                    );
                                }
                                if (value === "") {
                                    value = "0";
                                }
                                var long_string = _bytebuffer.Long.fromString(
                                    value,
                                    unsigned
                                ).toString();
                                if (long_string !== value.trim()) {
                                    throw new Error(
                                        "overflow " + field_name + " " + value
                                    );
                                }
                                return;
                            }
                            if (typeof value === "number") {
                                if (
                                    value > MAX_SAFE_INT ||
                                    value < MIN_SAFE_INT
                                ) {
                                    throw new Error(
                                        "overflow " + field_name + " " + value
                                    );
                                }
                                return;
                            }

                            throw "unsupported type " +
                                field_name +
                                ": (" +
                                (typeof value === "undefined"
                                    ? "undefined"
                                    : _typeof(value)) +
                                ") " +
                                value;
                        }
                    };

                    exports.default = _my;
                    module.exports = exports["default"];
                },
                {
                    "../../chain/src/ChainTypes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ChainTypes.js",
                    bytebuffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bytebuffer/dist/bytebuffer.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/error_with_cause.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    /** Exception nesting.  */
                    var ErrorWithCause = (function() {
                        function ErrorWithCause(message, cause) {
                            _classCallCheck(this, ErrorWithCause);

                            this.message = message;
                            if (
                                typeof cause !== "undefined" && cause !== null
                                    ? cause.message
                                    : undefined
                            ) {
                                this.message =
                                    "cause\t" +
                                    cause.message +
                                    "\t" +
                                    this.message;
                            }

                            var stack = ""; //(new Error).stack
                            if (
                                typeof cause !== "undefined" && cause !== null
                                    ? cause.stack
                                    : undefined
                            ) {
                                stack =
                                    "caused by\n\t" +
                                    cause.stack +
                                    "\t" +
                                    stack;
                            }

                            this.stack = this.message + "\n" + stack;
                        }

                        ErrorWithCause.throw = function _throw(message, cause) {
                            var msg = message;
                            if (
                                typeof cause !== "undefined" && cause !== null
                                    ? cause.message
                                    : undefined
                            ) {
                                msg += "\t cause: " + cause.message + " ";
                            }
                            if (
                                typeof cause !== "undefined" && cause !== null
                                    ? cause.stack
                                    : undefined
                            ) {
                                msg += "\n stack: " + cause.stack + " ";
                            }
                            throw new Error(msg);
                        };

                        return ErrorWithCause;
                    })();

                    exports.default = ErrorWithCause;
                    module.exports = exports["default"];
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/operations.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.stealth_memo_data = exports.signed_transaction = exports.transaction = exports.asset_claim_fees = exports.asset_settle_cancel = exports.transfer_from_blind = exports.blind_transfer = exports.blind_input = exports.transfer_to_blind = exports.blind_output = exports.stealth_confirmation = exports.override_transfer = exports.balance_claim = exports.assert = exports.block_id_predicate = exports.asset_symbol_eq_lit_predicate = exports.account_name_eq_lit_predicate = exports.custom = exports.worker_create = undefined;
                    exports.burn_worker_initializer = exports.vesting_balance_worker_initializer = exports.refund_worker_initializer = exports.vesting_balance_withdraw = exports.vesting_balance_create = exports.cdd_vesting_policy_initializer = exports.linear_vesting_policy_initializer = exports.committee_member_update_global_parameters = exports.chain_parameters = exports.committee_member_update = exports.committee_member_create = exports.withdraw_permission_delete = exports.withdraw_permission_claim = exports.withdraw_permission_update = exports.withdraw_permission_create = exports.proposal_delete = exports.proposal_update = exports.proposal_create = exports.op_wrapper = exports.witness_update = exports.witness_create = exports.asset_publish_feed = exports.price_feed = exports.asset_global_settle = exports.asset_settle = exports.asset_fund_fee_pool = exports.asset_reserve = exports.asset_issue = exports.asset_update_feed_producers = exports.asset_update_bitasset = exports.asset_update = exports.asset_create = exports.bitasset_options = exports.asset_options = exports.price = exports.account_transfer = exports.account_upgrade = exports.account_whitelist = exports.account_update = exports.account_create = exports.account_options = exports.authority = exports.fill_order = exports.call_order_update = exports.limit_order_cancel = exports.limit_order_create = exports.transfer = exports.memo_data = exports.signed_block_header = exports.block_header = exports.signed_block = exports.processed_transaction = exports.asset = exports.void_result = exports.fee_schedule = exports.asset_claim_fees_operation_fee_parameters = exports.asset_settle_cancel_operation_fee_parameters = exports.transfer_from_blind_operation_fee_parameters = exports.blind_transfer_operation_fee_parameters = exports.transfer_to_blind_operation_fee_parameters = exports.override_transfer_operation_fee_parameters = exports.balance_claim_operation_fee_parameters = exports.assert_operation_fee_parameters = exports.custom_operation_fee_parameters = exports.worker_create_operation_fee_parameters = exports.vesting_balance_withdraw_operation_fee_parameters = exports.vesting_balance_create_operation_fee_parameters = exports.committee_member_update_global_parameters_operation_fee_parameters = exports.committee_member_update_operation_fee_parameters = exports.committee_member_create_operation_fee_parameters = exports.withdraw_permission_delete_operation_fee_parameters = exports.withdraw_permission_claim_operation_fee_parameters = exports.withdraw_permission_update_operation_fee_parameters = exports.withdraw_permission_create_operation_fee_parameters = exports.proposal_delete_operation_fee_parameters = exports.proposal_update_operation_fee_parameters = exports.proposal_create_operation_fee_parameters = exports.witness_update_operation_fee_parameters = exports.witness_create_operation_fee_parameters = exports.asset_publish_feed_operation_fee_parameters = exports.asset_global_settle_operation_fee_parameters = exports.asset_settle_operation_fee_parameters = exports.asset_fund_fee_pool_operation_fee_parameters = exports.asset_reserve_operation_fee_parameters = exports.asset_issue_operation_fee_parameters = exports.asset_update_feed_producers_operation_fee_parameters = exports.asset_update_bitasset_operation_fee_parameters = exports.asset_update_operation_fee_parameters = exports.asset_create_operation_fee_parameters = exports.account_transfer_operation_fee_parameters = exports.account_upgrade_operation_fee_parameters = exports.account_whitelist_operation_fee_parameters = exports.account_update_operation_fee_parameters = exports.account_create_operation_fee_parameters = exports.fill_order_operation_fee_parameters = exports.call_order_update_operation_fee_parameters = exports.limit_order_cancel_operation_fee_parameters = exports.limit_order_create_operation_fee_parameters = exports.transfer_operation_fee_parameters = exports.operation = undefined;

                    var _types = require("./types");

                    var _types2 = _interopRequireDefault(_types);

                    var _serializer = require("./serializer");

                    var _serializer2 = _interopRequireDefault(_serializer);

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    var uint8 = _types2.default.uint8,
                        uint16 = _types2.default.uint16,
                        uint32 = _types2.default.uint32,
                        int64 = _types2.default.int64,
                        uint64 = _types2.default.uint64,
                        string = _types2.default.string,
                        bytes = _types2.default.bytes,
                        bool = _types2.default.bool,
                        array = _types2.default.array,
                        fixed_array = _types2.default.fixed_array,
                        protocol_id_type = _types2.default.protocol_id_type,
                        object_id_type = _types2.default.object_id_type,
                        vote_id = _types2.default.vote_id,
                        future_extensions = _types2.default.future_extensions,
                        static_variant = _types2.default.static_variant,
                        map = _types2.default.map,
                        set = _types2.default.set,
                        public_key = _types2.default.public_key,
                        address = _types2.default.address,
                        time_point_sec = _types2.default.time_point_sec,
                        optional = _types2.default.optional;

                    future_extensions = _types2.default.void;

                    /*
When updating generated code
Replace:  operation = static_variant [
with:     operation.st_operations = [

Delete:
public_key = new Serializer(
    "public_key"
    key_data: bytes 33
)

*/
                    // Place-holder, their are dependencies on "operation" .. The final list of
                    // operations is not avialble until the very end of the generated code.
                    // See: operation.st_operations = ...
                    var operation = static_variant();
                    // module.exports["operation"] = operation;

                    exports.operation = operation;
                    // For module.exports

                    var Serializer = function Serializer(
                        operation_name,
                        serilization_types_object
                    ) {
                        return new _serializer2.default(
                            operation_name,
                            serilization_types_object
                        );
                        // return module.exports[operation_name] = s;
                    };

                    // Custom-types follow Generated code:

                    // ##  Generated code follows
                    // # programs/js_operation_serializer > npm i -g decaffeinate
                    // ## -------------------------------
                    var transfer_operation_fee_parameters = (exports.transfer_operation_fee_parameters = new Serializer(
                        "transfer_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var limit_order_create_operation_fee_parameters = (exports.limit_order_create_operation_fee_parameters = new Serializer(
                        "limit_order_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var limit_order_cancel_operation_fee_parameters = (exports.limit_order_cancel_operation_fee_parameters = new Serializer(
                        "limit_order_cancel_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var call_order_update_operation_fee_parameters = (exports.call_order_update_operation_fee_parameters = new Serializer(
                        "call_order_update_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var fill_order_operation_fee_parameters = (exports.fill_order_operation_fee_parameters = new Serializer(
                        "fill_order_operation_fee_parameters"
                    ));

                    var account_create_operation_fee_parameters = (exports.account_create_operation_fee_parameters = new Serializer(
                        "account_create_operation_fee_parameters",
                        {
                            basic_fee: uint64,
                            premium_fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var account_update_operation_fee_parameters = (exports.account_update_operation_fee_parameters = new Serializer(
                        "account_update_operation_fee_parameters",
                        {
                            fee: int64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var account_whitelist_operation_fee_parameters = (exports.account_whitelist_operation_fee_parameters = new Serializer(
                        "account_whitelist_operation_fee_parameters",
                        {fee: int64}
                    ));

                    var account_upgrade_operation_fee_parameters = (exports.account_upgrade_operation_fee_parameters = new Serializer(
                        "account_upgrade_operation_fee_parameters",
                        {
                            membership_annual_fee: uint64,
                            membership_lifetime_fee: uint64
                        }
                    ));

                    var account_transfer_operation_fee_parameters = (exports.account_transfer_operation_fee_parameters = new Serializer(
                        "account_transfer_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_create_operation_fee_parameters = (exports.asset_create_operation_fee_parameters = new Serializer(
                        "asset_create_operation_fee_parameters",
                        {
                            symbol3: uint64,
                            symbol4: uint64,
                            long_symbol: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var asset_update_operation_fee_parameters = (exports.asset_update_operation_fee_parameters = new Serializer(
                        "asset_update_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var asset_update_bitasset_operation_fee_parameters = (exports.asset_update_bitasset_operation_fee_parameters = new Serializer(
                        "asset_update_bitasset_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_update_feed_producers_operation_fee_parameters = (exports.asset_update_feed_producers_operation_fee_parameters = new Serializer(
                        "asset_update_feed_producers_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_issue_operation_fee_parameters = (exports.asset_issue_operation_fee_parameters = new Serializer(
                        "asset_issue_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var asset_reserve_operation_fee_parameters = (exports.asset_reserve_operation_fee_parameters = new Serializer(
                        "asset_reserve_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_fund_fee_pool_operation_fee_parameters = (exports.asset_fund_fee_pool_operation_fee_parameters = new Serializer(
                        "asset_fund_fee_pool_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_settle_operation_fee_parameters = (exports.asset_settle_operation_fee_parameters = new Serializer(
                        "asset_settle_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_global_settle_operation_fee_parameters = (exports.asset_global_settle_operation_fee_parameters = new Serializer(
                        "asset_global_settle_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_publish_feed_operation_fee_parameters = (exports.asset_publish_feed_operation_fee_parameters = new Serializer(
                        "asset_publish_feed_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var witness_create_operation_fee_parameters = (exports.witness_create_operation_fee_parameters = new Serializer(
                        "witness_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var witness_update_operation_fee_parameters = (exports.witness_update_operation_fee_parameters = new Serializer(
                        "witness_update_operation_fee_parameters",
                        {fee: int64}
                    ));

                    var proposal_create_operation_fee_parameters = (exports.proposal_create_operation_fee_parameters = new Serializer(
                        "proposal_create_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var proposal_update_operation_fee_parameters = (exports.proposal_update_operation_fee_parameters = new Serializer(
                        "proposal_update_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var proposal_delete_operation_fee_parameters = (exports.proposal_delete_operation_fee_parameters = new Serializer(
                        "proposal_delete_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var withdraw_permission_create_operation_fee_parameters = (exports.withdraw_permission_create_operation_fee_parameters = new Serializer(
                        "withdraw_permission_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var withdraw_permission_update_operation_fee_parameters = (exports.withdraw_permission_update_operation_fee_parameters = new Serializer(
                        "withdraw_permission_update_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var withdraw_permission_claim_operation_fee_parameters = (exports.withdraw_permission_claim_operation_fee_parameters = new Serializer(
                        "withdraw_permission_claim_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var withdraw_permission_delete_operation_fee_parameters = (exports.withdraw_permission_delete_operation_fee_parameters = new Serializer(
                        "withdraw_permission_delete_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var committee_member_create_operation_fee_parameters = (exports.committee_member_create_operation_fee_parameters = new Serializer(
                        "committee_member_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var committee_member_update_operation_fee_parameters = (exports.committee_member_update_operation_fee_parameters = new Serializer(
                        "committee_member_update_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var committee_member_update_global_parameters_operation_fee_parameters = (exports.committee_member_update_global_parameters_operation_fee_parameters = new Serializer(
                        "committee_member_update_global_parameters_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var vesting_balance_create_operation_fee_parameters = (exports.vesting_balance_create_operation_fee_parameters = new Serializer(
                        "vesting_balance_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var vesting_balance_withdraw_operation_fee_parameters = (exports.vesting_balance_withdraw_operation_fee_parameters = new Serializer(
                        "vesting_balance_withdraw_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var worker_create_operation_fee_parameters = (exports.worker_create_operation_fee_parameters = new Serializer(
                        "worker_create_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var custom_operation_fee_parameters = (exports.custom_operation_fee_parameters = new Serializer(
                        "custom_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var assert_operation_fee_parameters = (exports.assert_operation_fee_parameters = new Serializer(
                        "assert_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var balance_claim_operation_fee_parameters = (exports.balance_claim_operation_fee_parameters = new Serializer(
                        "balance_claim_operation_fee_parameters"
                    ));

                    var override_transfer_operation_fee_parameters = (exports.override_transfer_operation_fee_parameters = new Serializer(
                        "override_transfer_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_kbyte: uint32
                        }
                    ));

                    var transfer_to_blind_operation_fee_parameters = (exports.transfer_to_blind_operation_fee_parameters = new Serializer(
                        "transfer_to_blind_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_output: uint32
                        }
                    ));

                    var blind_transfer_operation_fee_parameters = (exports.blind_transfer_operation_fee_parameters = new Serializer(
                        "blind_transfer_operation_fee_parameters",
                        {
                            fee: uint64,
                            price_per_output: uint32
                        }
                    ));

                    var transfer_from_blind_operation_fee_parameters = (exports.transfer_from_blind_operation_fee_parameters = new Serializer(
                        "transfer_from_blind_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var asset_settle_cancel_operation_fee_parameters = (exports.asset_settle_cancel_operation_fee_parameters = new Serializer(
                        "asset_settle_cancel_operation_fee_parameters"
                    ));

                    var asset_claim_fees_operation_fee_parameters = (exports.asset_claim_fees_operation_fee_parameters = new Serializer(
                        "asset_claim_fees_operation_fee_parameters",
                        {fee: uint64}
                    ));

                    var fee_parameters = static_variant([
                        transfer_operation_fee_parameters,
                        limit_order_create_operation_fee_parameters,
                        limit_order_cancel_operation_fee_parameters,
                        call_order_update_operation_fee_parameters,
                        fill_order_operation_fee_parameters,
                        account_create_operation_fee_parameters,
                        account_update_operation_fee_parameters,
                        account_whitelist_operation_fee_parameters,
                        account_upgrade_operation_fee_parameters,
                        account_transfer_operation_fee_parameters,
                        asset_create_operation_fee_parameters,
                        asset_update_operation_fee_parameters,
                        asset_update_bitasset_operation_fee_parameters,
                        asset_update_feed_producers_operation_fee_parameters,
                        asset_issue_operation_fee_parameters,
                        asset_reserve_operation_fee_parameters,
                        asset_fund_fee_pool_operation_fee_parameters,
                        asset_settle_operation_fee_parameters,
                        asset_global_settle_operation_fee_parameters,
                        asset_publish_feed_operation_fee_parameters,
                        witness_create_operation_fee_parameters,
                        witness_update_operation_fee_parameters,
                        proposal_create_operation_fee_parameters,
                        proposal_update_operation_fee_parameters,
                        proposal_delete_operation_fee_parameters,
                        withdraw_permission_create_operation_fee_parameters,
                        withdraw_permission_update_operation_fee_parameters,
                        withdraw_permission_claim_operation_fee_parameters,
                        withdraw_permission_delete_operation_fee_parameters,
                        committee_member_create_operation_fee_parameters,
                        committee_member_update_operation_fee_parameters,
                        committee_member_update_global_parameters_operation_fee_parameters,
                        vesting_balance_create_operation_fee_parameters,
                        vesting_balance_withdraw_operation_fee_parameters,
                        worker_create_operation_fee_parameters,
                        custom_operation_fee_parameters,
                        assert_operation_fee_parameters,
                        balance_claim_operation_fee_parameters,
                        override_transfer_operation_fee_parameters,
                        transfer_to_blind_operation_fee_parameters,
                        blind_transfer_operation_fee_parameters,
                        transfer_from_blind_operation_fee_parameters,
                        asset_settle_cancel_operation_fee_parameters,
                        asset_claim_fees_operation_fee_parameters
                    ]);

                    var fee_schedule = (exports.fee_schedule = new Serializer(
                        "fee_schedule",
                        {
                            parameters: set(fee_parameters),
                            scale: uint32
                        }
                    ));

                    var void_result = (exports.void_result = new Serializer(
                        "void_result"
                    ));

                    var asset = (exports.asset = new Serializer("asset", {
                        amount: int64,
                        asset_id: protocol_id_type("asset")
                    }));

                    var operation_result = static_variant([
                        void_result,
                        object_id_type,
                        asset
                    ]);

                    var processed_transaction = (exports.processed_transaction = new Serializer(
                        "processed_transaction",
                        {
                            ref_block_num: uint16,
                            ref_block_prefix: uint32,
                            expiration: time_point_sec,
                            operations: array(operation),
                            extensions: set(future_extensions),
                            signatures: array(bytes(65)),
                            operation_results: array(operation_result)
                        }
                    ));

                    var signed_block = (exports.signed_block = new Serializer(
                        "signed_block",
                        {
                            previous: bytes(20),
                            timestamp: time_point_sec,
                            witness: protocol_id_type("witness"),
                            transaction_merkle_root: bytes(20),
                            extensions: set(future_extensions),
                            witness_signature: bytes(65),
                            transactions: array(processed_transaction)
                        }
                    ));

                    var block_header = (exports.block_header = new Serializer(
                        "block_header",
                        {
                            previous: bytes(20),
                            timestamp: time_point_sec,
                            witness: protocol_id_type("witness"),
                            transaction_merkle_root: bytes(20),
                            extensions: set(future_extensions)
                        }
                    ));

                    var signed_block_header = (exports.signed_block_header = new Serializer(
                        "signed_block_header",
                        {
                            previous: bytes(20),
                            timestamp: time_point_sec,
                            witness: protocol_id_type("witness"),
                            transaction_merkle_root: bytes(20),
                            extensions: set(future_extensions),
                            witness_signature: bytes(65)
                        }
                    ));

                    var memo_data = (exports.memo_data = new Serializer(
                        "memo_data",
                        {
                            from: public_key,
                            to: public_key,
                            nonce: uint64,
                            message: bytes()
                        }
                    ));

                    var transfer = (exports.transfer = new Serializer(
                        "transfer",
                        {
                            fee: asset,
                            from: protocol_id_type("account"),
                            to: protocol_id_type("account"),
                            amount: asset,
                            memo: optional(memo_data),
                            extensions: set(future_extensions)
                        }
                    ));

                    var limit_order_create = (exports.limit_order_create = new Serializer(
                        "limit_order_create",
                        {
                            fee: asset,
                            seller: protocol_id_type("account"),
                            amount_to_sell: asset,
                            min_to_receive: asset,
                            expiration: time_point_sec,
                            fill_or_kill: bool,
                            extensions: set(future_extensions)
                        }
                    ));

                    var limit_order_cancel = (exports.limit_order_cancel = new Serializer(
                        "limit_order_cancel",
                        {
                            fee: asset,
                            fee_paying_account: protocol_id_type("account"),
                            order: protocol_id_type("limit_order"),
                            extensions: set(future_extensions)
                        }
                    ));

                    var call_order_update = (exports.call_order_update = new Serializer(
                        "call_order_update",
                        {
                            fee: asset,
                            funding_account: protocol_id_type("account"),
                            delta_collateral: asset,
                            delta_debt: asset,
                            extensions: set(future_extensions)
                        }
                    ));

                    var fill_order = (exports.fill_order = new Serializer(
                        "fill_order",
                        {
                            fee: asset,
                            order_id: object_id_type,
                            account_id: protocol_id_type("account"),
                            pays: asset,
                            receives: asset
                        }
                    ));

                    var authority = (exports.authority = new Serializer(
                        "authority",
                        {
                            weight_threshold: uint32,
                            account_auths: map(
                                protocol_id_type("account"),
                                uint16
                            ),
                            key_auths: map(public_key, uint16),
                            address_auths: map(address, uint16)
                        }
                    ));

                    var account_options = (exports.account_options = new Serializer(
                        "account_options",
                        {
                            memo_key: public_key,
                            voting_account: protocol_id_type("account"),
                            num_witness: uint16,
                            num_committee: uint16,
                            votes: set(vote_id),
                            extensions: set(future_extensions)
                        }
                    ));

                    var account_create = (exports.account_create = new Serializer(
                        "account_create",
                        {
                            fee: asset,
                            registrar: protocol_id_type("account"),
                            referrer: protocol_id_type("account"),
                            referrer_percent: uint16,
                            name: string,
                            owner: authority,
                            active: authority,
                            options: account_options,
                            extensions: set(future_extensions)
                        }
                    ));

                    var account_update = (exports.account_update = new Serializer(
                        "account_update",
                        {
                            fee: asset,
                            account: protocol_id_type("account"),
                            owner: optional(authority),
                            active: optional(authority),
                            new_options: optional(account_options),
                            extensions: set(future_extensions)
                        }
                    ));

                    var account_whitelist = (exports.account_whitelist = new Serializer(
                        "account_whitelist",
                        {
                            fee: asset,
                            authorizing_account: protocol_id_type("account"),
                            account_to_list: protocol_id_type("account"),
                            new_listing: uint8,
                            extensions: set(future_extensions)
                        }
                    ));

                    var account_upgrade = (exports.account_upgrade = new Serializer(
                        "account_upgrade",
                        {
                            fee: asset,
                            account_to_upgrade: protocol_id_type("account"),
                            upgrade_to_lifetime_member: bool,
                            extensions: set(future_extensions)
                        }
                    ));

                    var account_transfer = (exports.account_transfer = new Serializer(
                        "account_transfer",
                        {
                            fee: asset,
                            account_id: protocol_id_type("account"),
                            new_owner: protocol_id_type("account"),
                            extensions: set(future_extensions)
                        }
                    ));

                    var price = (exports.price = new Serializer("price", {
                        base: asset,
                        quote: asset
                    }));

                    var asset_options = (exports.asset_options = new Serializer(
                        "asset_options",
                        {
                            max_supply: int64,
                            market_fee_percent: uint16,
                            max_market_fee: int64,
                            issuer_permissions: uint16,
                            flags: uint16,
                            core_exchange_rate: price,
                            whitelist_authorities: set(
                                protocol_id_type("account")
                            ),
                            blacklist_authorities: set(
                                protocol_id_type("account")
                            ),
                            whitelist_markets: set(protocol_id_type("asset")),
                            blacklist_markets: set(protocol_id_type("asset")),
                            description: string,
                            extensions: set(future_extensions)
                        }
                    ));

                    var bitasset_options = (exports.bitasset_options = new Serializer(
                        "bitasset_options",
                        {
                            feed_lifetime_sec: uint32,
                            minimum_feeds: uint8,
                            force_settlement_delay_sec: uint32,
                            force_settlement_offset_percent: uint16,
                            maximum_force_settlement_volume: uint16,
                            short_backing_asset: protocol_id_type("asset"),
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_create = (exports.asset_create = new Serializer(
                        "asset_create",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            symbol: string,
                            precision: uint8,
                            common_options: asset_options,
                            bitasset_opts: optional(bitasset_options),
                            is_prediction_market: bool,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_update = (exports.asset_update = new Serializer(
                        "asset_update",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            asset_to_update: protocol_id_type("asset"),
                            new_issuer: optional(protocol_id_type("account")),
                            new_options: asset_options,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_update_bitasset = (exports.asset_update_bitasset = new Serializer(
                        "asset_update_bitasset",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            asset_to_update: protocol_id_type("asset"),
                            new_options: bitasset_options,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_update_feed_producers = (exports.asset_update_feed_producers = new Serializer(
                        "asset_update_feed_producers",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            asset_to_update: protocol_id_type("asset"),
                            new_feed_producers: set(
                                protocol_id_type("account")
                            ),
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_issue = (exports.asset_issue = new Serializer(
                        "asset_issue",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            asset_to_issue: asset,
                            issue_to_account: protocol_id_type("account"),
                            memo: optional(memo_data),
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_reserve = (exports.asset_reserve = new Serializer(
                        "asset_reserve",
                        {
                            fee: asset,
                            payer: protocol_id_type("account"),
                            amount_to_reserve: asset,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_fund_fee_pool = (exports.asset_fund_fee_pool = new Serializer(
                        "asset_fund_fee_pool",
                        {
                            fee: asset,
                            from_account: protocol_id_type("account"),
                            asset_id: protocol_id_type("asset"),
                            amount: int64,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_settle = (exports.asset_settle = new Serializer(
                        "asset_settle",
                        {
                            fee: asset,
                            account: protocol_id_type("account"),
                            amount: asset,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_global_settle = (exports.asset_global_settle = new Serializer(
                        "asset_global_settle",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            asset_to_settle: protocol_id_type("asset"),
                            settle_price: price,
                            extensions: set(future_extensions)
                        }
                    ));

                    var price_feed = (exports.price_feed = new Serializer(
                        "price_feed",
                        {
                            settlement_price: price,
                            maintenance_collateral_ratio: uint16,
                            maximum_short_squeeze_ratio: uint16,
                            core_exchange_rate: price
                        }
                    ));

                    var asset_publish_feed = (exports.asset_publish_feed = new Serializer(
                        "asset_publish_feed",
                        {
                            fee: asset,
                            publisher: protocol_id_type("account"),
                            asset_id: protocol_id_type("asset"),
                            feed: price_feed,
                            extensions: set(future_extensions)
                        }
                    ));

                    var witness_create = (exports.witness_create = new Serializer(
                        "witness_create",
                        {
                            fee: asset,
                            witness_account: protocol_id_type("account"),
                            url: string,
                            block_signing_key: public_key
                        }
                    ));

                    var witness_update = (exports.witness_update = new Serializer(
                        "witness_update",
                        {
                            fee: asset,
                            witness: protocol_id_type("witness"),
                            witness_account: protocol_id_type("account"),
                            new_url: optional(string),
                            new_signing_key: optional(public_key)
                        }
                    ));

                    var op_wrapper = (exports.op_wrapper = new Serializer(
                        "op_wrapper",
                        {op: operation}
                    ));

                    var proposal_create = (exports.proposal_create = new Serializer(
                        "proposal_create",
                        {
                            fee: asset,
                            fee_paying_account: protocol_id_type("account"),
                            expiration_time: time_point_sec,
                            proposed_ops: array(op_wrapper),
                            review_period_seconds: optional(uint32),
                            extensions: set(future_extensions)
                        }
                    ));

                    var proposal_update = (exports.proposal_update = new Serializer(
                        "proposal_update",
                        {
                            fee: asset,
                            fee_paying_account: protocol_id_type("account"),
                            proposal: protocol_id_type("proposal"),
                            active_approvals_to_add: set(
                                protocol_id_type("account")
                            ),
                            active_approvals_to_remove: set(
                                protocol_id_type("account")
                            ),
                            owner_approvals_to_add: set(
                                protocol_id_type("account")
                            ),
                            owner_approvals_to_remove: set(
                                protocol_id_type("account")
                            ),
                            key_approvals_to_add: set(public_key),
                            key_approvals_to_remove: set(public_key),
                            extensions: set(future_extensions)
                        }
                    ));

                    var proposal_delete = (exports.proposal_delete = new Serializer(
                        "proposal_delete",
                        {
                            fee: asset,
                            fee_paying_account: protocol_id_type("account"),
                            using_owner_authority: bool,
                            proposal: protocol_id_type("proposal"),
                            extensions: set(future_extensions)
                        }
                    ));

                    var withdraw_permission_create = (exports.withdraw_permission_create = new Serializer(
                        "withdraw_permission_create",
                        {
                            fee: asset,
                            withdraw_from_account: protocol_id_type("account"),
                            authorized_account: protocol_id_type("account"),
                            withdrawal_limit: asset,
                            withdrawal_period_sec: uint32,
                            periods_until_expiration: uint32,
                            period_start_time: time_point_sec
                        }
                    ));

                    var withdraw_permission_update = (exports.withdraw_permission_update = new Serializer(
                        "withdraw_permission_update",
                        {
                            fee: asset,
                            withdraw_from_account: protocol_id_type("account"),
                            authorized_account: protocol_id_type("account"),
                            permission_to_update: protocol_id_type(
                                "withdraw_permission"
                            ),
                            withdrawal_limit: asset,
                            withdrawal_period_sec: uint32,
                            period_start_time: time_point_sec,
                            periods_until_expiration: uint32
                        }
                    ));

                    var withdraw_permission_claim = (exports.withdraw_permission_claim = new Serializer(
                        "withdraw_permission_claim",
                        {
                            fee: asset,
                            withdraw_permission: protocol_id_type(
                                "withdraw_permission"
                            ),
                            withdraw_from_account: protocol_id_type("account"),
                            withdraw_to_account: protocol_id_type("account"),
                            amount_to_withdraw: asset,
                            memo: optional(memo_data)
                        }
                    ));

                    var withdraw_permission_delete = (exports.withdraw_permission_delete = new Serializer(
                        "withdraw_permission_delete",
                        {
                            fee: asset,
                            withdraw_from_account: protocol_id_type("account"),
                            authorized_account: protocol_id_type("account"),
                            withdrawal_permission: protocol_id_type(
                                "withdraw_permission"
                            )
                        }
                    ));

                    var committee_member_create = (exports.committee_member_create = new Serializer(
                        "committee_member_create",
                        {
                            fee: asset,
                            committee_member_account: protocol_id_type(
                                "account"
                            ),
                            url: string
                        }
                    ));

                    var committee_member_update = (exports.committee_member_update = new Serializer(
                        "committee_member_update",
                        {
                            fee: asset,
                            committee_member: protocol_id_type(
                                "committee_member"
                            ),
                            committee_member_account: protocol_id_type(
                                "account"
                            ),
                            new_url: optional(string)
                        }
                    ));

                    var chain_parameters = (exports.chain_parameters = new Serializer(
                        "chain_parameters",
                        {
                            current_fees: fee_schedule,
                            block_interval: uint8,
                            maintenance_interval: uint32,
                            maintenance_skip_slots: uint8,
                            committee_proposal_review_period: uint32,
                            maximum_transaction_size: uint32,
                            maximum_block_size: uint32,
                            maximum_time_until_expiration: uint32,
                            maximum_proposal_lifetime: uint32,
                            maximum_asset_whitelist_authorities: uint8,
                            maximum_asset_feed_publishers: uint8,
                            maximum_witness_count: uint16,
                            maximum_committee_count: uint16,
                            maximum_authority_membership: uint16,
                            reserve_percent_of_fee: uint16,
                            network_percent_of_fee: uint16,
                            lifetime_referrer_percent_of_fee: uint16,
                            cashback_vesting_period_seconds: uint32,
                            cashback_vesting_threshold: int64,
                            count_non_member_votes: bool,
                            allow_non_member_whitelists: bool,
                            witness_pay_per_block: int64,
                            worker_budget_per_day: int64,
                            max_predicate_opcode: uint16,
                            fee_liquidation_threshold: int64,
                            accounts_per_fee_scale: uint16,
                            account_fee_scale_bitshifts: uint8,
                            max_authority_depth: uint8,
                            extensions: set(future_extensions)
                        }
                    ));

                    var committee_member_update_global_parameters = (exports.committee_member_update_global_parameters = new Serializer(
                        "committee_member_update_global_parameters",
                        {
                            fee: asset,
                            new_parameters: chain_parameters
                        }
                    ));

                    var linear_vesting_policy_initializer = (exports.linear_vesting_policy_initializer = new Serializer(
                        "linear_vesting_policy_initializer",
                        {
                            begin_timestamp: time_point_sec,
                            vesting_cliff_seconds: uint32,
                            vesting_duration_seconds: uint32
                        }
                    ));

                    var cdd_vesting_policy_initializer = (exports.cdd_vesting_policy_initializer = new Serializer(
                        "cdd_vesting_policy_initializer",
                        {
                            start_claim: time_point_sec,
                            vesting_seconds: uint32
                        }
                    ));

                    var vesting_policy_initializer = static_variant([
                        linear_vesting_policy_initializer,
                        cdd_vesting_policy_initializer
                    ]);

                    var vesting_balance_create = (exports.vesting_balance_create = new Serializer(
                        "vesting_balance_create",
                        {
                            fee: asset,
                            creator: protocol_id_type("account"),
                            owner: protocol_id_type("account"),
                            amount: asset,
                            policy: vesting_policy_initializer
                        }
                    ));

                    var vesting_balance_withdraw = (exports.vesting_balance_withdraw = new Serializer(
                        "vesting_balance_withdraw",
                        {
                            fee: asset,
                            vesting_balance: protocol_id_type(
                                "vesting_balance"
                            ),
                            owner: protocol_id_type("account"),
                            amount: asset
                        }
                    ));

                    var refund_worker_initializer = (exports.refund_worker_initializer = new Serializer(
                        "refund_worker_initializer"
                    ));

                    var vesting_balance_worker_initializer = (exports.vesting_balance_worker_initializer = new Serializer(
                        "vesting_balance_worker_initializer",
                        {pay_vesting_period_days: uint16}
                    ));

                    var burn_worker_initializer = (exports.burn_worker_initializer = new Serializer(
                        "burn_worker_initializer"
                    ));

                    var worker_initializer = static_variant([
                        refund_worker_initializer,
                        vesting_balance_worker_initializer,
                        burn_worker_initializer
                    ]);

                    var worker_create = (exports.worker_create = new Serializer(
                        "worker_create",
                        {
                            fee: asset,
                            owner: protocol_id_type("account"),
                            work_begin_date: time_point_sec,
                            work_end_date: time_point_sec,
                            daily_pay: int64,
                            name: string,
                            url: string,
                            initializer: worker_initializer
                        }
                    ));

                    var custom = (exports.custom = new Serializer("custom", {
                        fee: asset,
                        payer: protocol_id_type("account"),
                        required_auths: set(protocol_id_type("account")),
                        id: uint16,
                        data: bytes()
                    }));

                    var account_name_eq_lit_predicate = (exports.account_name_eq_lit_predicate = new Serializer(
                        "account_name_eq_lit_predicate",
                        {
                            account_id: protocol_id_type("account"),
                            name: string
                        }
                    ));

                    var asset_symbol_eq_lit_predicate = (exports.asset_symbol_eq_lit_predicate = new Serializer(
                        "asset_symbol_eq_lit_predicate",
                        {
                            asset_id: protocol_id_type("asset"),
                            symbol: string
                        }
                    ));

                    var block_id_predicate = (exports.block_id_predicate = new Serializer(
                        "block_id_predicate",
                        {id: bytes(20)}
                    ));

                    var predicate = static_variant([
                        account_name_eq_lit_predicate,
                        asset_symbol_eq_lit_predicate,
                        block_id_predicate
                    ]);

                    var assert = (exports.assert = new Serializer("assert", {
                        fee: asset,
                        fee_paying_account: protocol_id_type("account"),
                        predicates: array(predicate),
                        required_auths: set(protocol_id_type("account")),
                        extensions: set(future_extensions)
                    }));

                    var balance_claim = (exports.balance_claim = new Serializer(
                        "balance_claim",
                        {
                            fee: asset,
                            deposit_to_account: protocol_id_type("account"),
                            balance_to_claim: protocol_id_type("balance"),
                            balance_owner_key: public_key,
                            total_claimed: asset
                        }
                    ));

                    var override_transfer = (exports.override_transfer = new Serializer(
                        "override_transfer",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            from: protocol_id_type("account"),
                            to: protocol_id_type("account"),
                            amount: asset,
                            memo: optional(memo_data),
                            extensions: set(future_extensions)
                        }
                    ));

                    var stealth_confirmation = (exports.stealth_confirmation = new Serializer(
                        "stealth_confirmation",
                        {
                            one_time_key: public_key,
                            to: optional(public_key),
                            encrypted_memo: bytes()
                        }
                    ));

                    var blind_output = (exports.blind_output = new Serializer(
                        "blind_output",
                        {
                            commitment: bytes(33),
                            range_proof: bytes(),
                            owner: authority,
                            stealth_memo: optional(stealth_confirmation)
                        }
                    ));

                    var transfer_to_blind = (exports.transfer_to_blind = new Serializer(
                        "transfer_to_blind",
                        {
                            fee: asset,
                            amount: asset,
                            from: protocol_id_type("account"),
                            blinding_factor: bytes(32),
                            outputs: array(blind_output)
                        }
                    ));

                    var blind_input = (exports.blind_input = new Serializer(
                        "blind_input",
                        {
                            commitment: bytes(33),
                            owner: authority
                        }
                    ));

                    var blind_transfer = (exports.blind_transfer = new Serializer(
                        "blind_transfer",
                        {
                            fee: asset,
                            inputs: array(blind_input),
                            outputs: array(blind_output)
                        }
                    ));

                    var transfer_from_blind = (exports.transfer_from_blind = new Serializer(
                        "transfer_from_blind",
                        {
                            fee: asset,
                            amount: asset,
                            to: protocol_id_type("account"),
                            blinding_factor: bytes(32),
                            inputs: array(blind_input)
                        }
                    ));

                    var asset_settle_cancel = (exports.asset_settle_cancel = new Serializer(
                        "asset_settle_cancel",
                        {
                            fee: asset,
                            settlement: protocol_id_type("force_settlement"),
                            account: protocol_id_type("account"),
                            amount: asset,
                            extensions: set(future_extensions)
                        }
                    ));

                    var asset_claim_fees = (exports.asset_claim_fees = new Serializer(
                        "asset_claim_fees",
                        {
                            fee: asset,
                            issuer: protocol_id_type("account"),
                            amount_to_claim: asset,
                            extensions: set(future_extensions)
                        }
                    ));

                    operation.st_operations = [
                        transfer,
                        limit_order_create,
                        limit_order_cancel,
                        call_order_update,
                        fill_order,
                        account_create,
                        account_update,
                        account_whitelist,
                        account_upgrade,
                        account_transfer,
                        asset_create,
                        asset_update,
                        asset_update_bitasset,
                        asset_update_feed_producers,
                        asset_issue,
                        asset_reserve,
                        asset_fund_fee_pool,
                        asset_settle,
                        asset_global_settle,
                        asset_publish_feed,
                        witness_create,
                        witness_update,
                        proposal_create,
                        proposal_update,
                        proposal_delete,
                        withdraw_permission_create,
                        withdraw_permission_update,
                        withdraw_permission_claim,
                        withdraw_permission_delete,
                        committee_member_create,
                        committee_member_update,
                        committee_member_update_global_parameters,
                        vesting_balance_create,
                        vesting_balance_withdraw,
                        worker_create,
                        custom,
                        assert,
                        balance_claim,
                        override_transfer,
                        transfer_to_blind,
                        blind_transfer,
                        transfer_from_blind,
                        asset_settle_cancel,
                        asset_claim_fees
                    ];

                    var transaction = (exports.transaction = new Serializer(
                        "transaction",
                        {
                            ref_block_num: uint16,
                            ref_block_prefix: uint32,
                            expiration: time_point_sec,
                            operations: array(operation),
                            extensions: set(future_extensions)
                        }
                    ));

                    var signed_transaction = (exports.signed_transaction = new Serializer(
                        "signed_transaction",
                        {
                            ref_block_num: uint16,
                            ref_block_prefix: uint32,
                            expiration: time_point_sec,
                            operations: array(operation),
                            extensions: set(future_extensions),
                            signatures: array(bytes(65))
                        }
                    ));
                    //# -------------------------------
                    //#  Generated code end
                    //# -------------------------------

                    // Custom Types

                    var stealth_memo_data = (exports.stealth_memo_data = new Serializer(
                        "stealth_memo_data",
                        {
                            from: optional(public_key),
                            amount: asset,
                            blinding_factor: bytes(32),
                            commitment: bytes(33),
                            check: uint32
                        }
                    ));
                    // var stealth_confirmation = new Serializer(
                    //     "stealth_confirmation", {
                    //     one_time_key: public_key,
                    //     to: optional( public_key ),
                    //     encrypted_memo: stealth_memo_data
                    // })
                },
                {
                    "./serializer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/serializer.js",
                    "./types":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/types.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/serializer.js": [
                function(require, module, exports) {
                    (function(process, Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _bytebuffer = require("bytebuffer");

                        var _bytebuffer2 = _interopRequireDefault(_bytebuffer);

                        var _error_with_cause = require("./error_with_cause");

                        var _error_with_cause2 = _interopRequireDefault(
                            _error_with_cause
                        );

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var HEX_DUMP =
                            process.env
                                .npm_config__graphene_serializer_hex_dump;

                        var Serializer = (function() {
                            function Serializer(operation_name, types) {
                                _classCallCheck(this, Serializer);

                                this.operation_name = operation_name;
                                this.types = types;
                                if (this.types)
                                    this.keys = Object.keys(this.types);

                                Serializer.printDebug = true;
                            }

                            Serializer.prototype.fromByteBuffer = function fromByteBuffer(
                                b
                            ) {
                                var object = {};
                                var field = null;
                                try {
                                    var iterable = this.keys;
                                    for (
                                        var i = 0, field;
                                        i < iterable.length;
                                        i++
                                    ) {
                                        field = iterable[i];
                                        var type = this.types[field];
                                        try {
                                            if (HEX_DUMP) {
                                                if (type.operation_name) {
                                                    console.error(
                                                        type.operation_name
                                                    );
                                                } else {
                                                    var o1 = b.offset;
                                                    type.fromByteBuffer(b);
                                                    var o2 = b.offset;
                                                    b.offset = o1;
                                                    //b.reset()
                                                    var _b = b.copy(o1, o2);
                                                    console.error(
                                                        this.operation_name +
                                                            "." +
                                                            field +
                                                            "\t",
                                                        _b.toHex()
                                                    );
                                                }
                                            }
                                            object[field] = type.fromByteBuffer(
                                                b
                                            );
                                        } catch (e) {
                                            if (Serializer.printDebug) {
                                                console.error(
                                                    "Error reading " +
                                                        this.operation_name +
                                                        "." +
                                                        field +
                                                        " in data:"
                                                );
                                                b.printDebug();
                                            }
                                            throw e;
                                        }
                                    }
                                } catch (error) {
                                    _error_with_cause2.default.throw(
                                        this.operation_name + "." + field,
                                        error
                                    );
                                }

                                return object;
                            };

                            Serializer.prototype.appendByteBuffer = function appendByteBuffer(
                                b,
                                object
                            ) {
                                var field = null;
                                try {
                                    var iterable = this.keys;
                                    for (
                                        var i = 0, field;
                                        i < iterable.length;
                                        i++
                                    ) {
                                        field = iterable[i];
                                        var type = this.types[field];
                                        type.appendByteBuffer(b, object[field]);
                                    }
                                } catch (error) {
                                    try {
                                        _error_with_cause2.default.throw(
                                            this.operation_name +
                                                "." +
                                                field +
                                                " = " +
                                                JSON.stringify(object[field]),
                                            error
                                        );
                                    } catch (e) {
                                        // circular ref
                                        _error_with_cause2.default.throw(
                                            this.operation_name +
                                                "." +
                                                field +
                                                " = " +
                                                object[field],
                                            error
                                        );
                                    }
                                }
                                return;
                            };

                            Serializer.prototype.fromObject = function fromObject(
                                serialized_object
                            ) {
                                var result = {};
                                var field = null;
                                try {
                                    var iterable = this.keys;
                                    for (
                                        var i = 0, field;
                                        i < iterable.length;
                                        i++
                                    ) {
                                        field = iterable[i];
                                        var type = this.types[field];
                                        var value = serialized_object[field];
                                        //DEBUG value = value.resolve if value.resolve
                                        //DEBUG console.log('... value',field,value)
                                        var object = type.fromObject(value);
                                        result[field] = object;
                                    }
                                } catch (error) {
                                    _error_with_cause2.default.throw(
                                        this.operation_name + "." + field,
                                        error
                                    );
                                }

                                return result;
                            };

                            /**
        @arg {boolean} [debug.use_default = false] - more template friendly
        @arg {boolean} [debug.annotate = false] - add user-friendly information
    */

                            Serializer.prototype.toObject = function toObject() {
                                var serialized_object =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : {};
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {use_default: false, annotate: false};

                                var result = {};
                                var field = null;
                                try {
                                    if (!this.types) return result;

                                    var iterable = this.keys;
                                    for (
                                        var i = 0, field;
                                        i < iterable.length;
                                        i++
                                    ) {
                                        field = iterable[i];
                                        var type = this.types[field];
                                        var object = type.toObject(
                                            typeof serialized_object !==
                                                "undefined" &&
                                            serialized_object !== null
                                                ? serialized_object[field]
                                                : undefined,
                                            debug
                                        );
                                        result[field] = object;
                                        if (HEX_DUMP) {
                                            var b = new _bytebuffer2.default(
                                                _bytebuffer2.default.DEFAULT_CAPACITY,
                                                _bytebuffer2.default.LITTLE_ENDIAN
                                            );
                                            type.appendByteBuffer(
                                                b,
                                                typeof serialized_object !==
                                                    "undefined" &&
                                                serialized_object !== null
                                                    ? serialized_object[field]
                                                    : undefined
                                            );
                                            b = b.copy(0, b.offset);
                                            console.error(
                                                this.operation_name +
                                                    "." +
                                                    field,
                                                b.toHex()
                                            );
                                        }
                                    }
                                } catch (error) {
                                    _error_with_cause2.default.throw(
                                        this.operation_name + "." + field,
                                        error
                                    );
                                }

                                return result;
                            };

                            /** Sort by the first element in a operation */

                            Serializer.prototype.compare = function compare(
                                a,
                                b
                            ) {
                                var first_key = this.keys[0];
                                var first_type = this.types[first_key];

                                var valA = a[first_key];
                                var valB = b[first_key];

                                if (first_type.compare)
                                    return first_type.compare(valA, valB);

                                if (
                                    typeof valA === "number" &&
                                    typeof valB === "number"
                                )
                                    return valA - valB;

                                var encoding = void 0;
                                if (
                                    Buffer.isBuffer(valA) &&
                                    Buffer.isBuffer(valB)
                                ) {
                                    // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
                                    encoding = "hex";
                                }

                                var strA = valA.toString(encoding);
                                var strB = valB.toString(encoding);
                                return strA > strB ? 1 : strA < strB ? -1 : 0;
                            };

                            // <helper_functions>

                            Serializer.prototype.fromHex = function fromHex(
                                hex
                            ) {
                                var b = _bytebuffer2.default.fromHex(
                                    hex,
                                    _bytebuffer2.default.LITTLE_ENDIAN
                                );
                                return this.fromByteBuffer(b);
                            };

                            Serializer.prototype.fromBuffer = function fromBuffer(
                                buffer
                            ) {
                                var b = _bytebuffer2.default.fromBinary(
                                    buffer.toString("binary"),
                                    _bytebuffer2.default.LITTLE_ENDIAN
                                );
                                return this.fromByteBuffer(b);
                            };

                            Serializer.prototype.toHex = function toHex(
                                object
                            ) {
                                // return this.toBuffer(object).toString("hex")
                                var b = this.toByteBuffer(object);
                                return b.toHex();
                            };

                            Serializer.prototype.toByteBuffer = function toByteBuffer(
                                object
                            ) {
                                var b = new _bytebuffer2.default(
                                    _bytebuffer2.default.DEFAULT_CAPACITY,
                                    _bytebuffer2.default.LITTLE_ENDIAN
                                );
                                this.appendByteBuffer(b, object);
                                return b.copy(0, b.offset);
                            };

                            Serializer.prototype.toBuffer = function toBuffer(
                                object
                            ) {
                                return new Buffer(
                                    this.toByteBuffer(object).toBinary(),
                                    "binary"
                                );
                            };

                            return Serializer;
                        })();

                        exports.default = Serializer;
                        module.exports = exports["default"];
                    }.call(
                        this,
                        require("_process"),
                        require("buffer").Buffer
                    ));
                },
                {
                    "./error_with_cause":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/error_with_cause.js",
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    bytebuffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bytebuffer/dist/bytebuffer.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/template.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.default = template;

                    /** Console print any transaction object with zero default values. */
                    function template(op) {
                        var object = op.toObject(void 0, {
                            use_default: true,
                            annotate: true
                        });

                        // visual (with descriptions)
                        console.error(JSON.stringify(object, null, 4));

                        // usable in a copy-paste

                        object = op.toObject(void 0, {
                            use_default: true,
                            annotate: false
                        });

                        // copy-paste one-lineer
                        console.error(JSON.stringify(object));
                    }
                    module.exports = exports["default"];
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/types.js": [
                function(require, module, exports) {
                    (function(process, Buffer) {
                        "use strict";

                        exports.__esModule = true;

                        var _typeof =
                            typeof Symbol === "function" &&
                            typeof Symbol.iterator === "symbol"
                                ? function(obj) {
                                      return typeof obj;
                                  }
                                : function(obj) {
                                      return obj &&
                                          typeof Symbol === "function" &&
                                          obj.constructor === Symbol &&
                                          obj !== Symbol.prototype
                                          ? "symbol"
                                          : typeof obj;
                                  }; // Low-level types that make up operations

                        var _SerializerValidation = require("./SerializerValidation");

                        var _SerializerValidation2 = _interopRequireDefault(
                            _SerializerValidation
                        );

                        var _FastParser = require("./FastParser");

                        var _FastParser2 = _interopRequireDefault(_FastParser);

                        var _ChainTypes = require("../../chain/src/ChainTypes");

                        var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

                        var _ObjectId = require("../../chain/src/ObjectId");

                        var _ObjectId2 = _interopRequireDefault(_ObjectId);

                        var _ecc = require("../../ecc");

                        var _bitsharesjsWs = require("bitsharesjs-ws");

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        var Types = {};

                        var HEX_DUMP =
                            process.env
                                .npm_config__graphene_serializer_hex_dump;

                        Types.uint8 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint8();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xff,
                                    object,
                                    "uint8 " + object
                                );
                                b.writeUint8(object);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xff,
                                    object,
                                    "uint8 " + object
                                );
                                return object;
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return 0;
                                }
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xff,
                                    object,
                                    "uint8 " + object
                                );
                                return parseInt(object);
                            }
                        };

                        Types.uint16 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint16();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffff,
                                    object,
                                    "uint16 " + object
                                );
                                b.writeUint16(object);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffff,
                                    object,
                                    "uint16 " + object
                                );
                                return object;
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return 0;
                                }
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffff,
                                    object,
                                    "uint16 " + object
                                );
                                return parseInt(object);
                            }
                        };

                        Types.uint32 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint32();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffffffff,
                                    object,
                                    "uint32 " + object
                                );
                                b.writeUint32(object);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffffffff,
                                    object,
                                    "uint32 " + object
                                );
                                return object;
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return 0;
                                }
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffffffff,
                                    object,
                                    "uint32 " + object
                                );
                                return parseInt(object);
                            }
                        };

                        var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
                        var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

                        Types.varint32 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readVarint32();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.require_range(
                                    MIN_SIGNED_32,
                                    MAX_SIGNED_32,
                                    object,
                                    "uint32 " + object
                                );
                                b.writeVarint32(object);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.require_range(
                                    MIN_SIGNED_32,
                                    MAX_SIGNED_32,
                                    object,
                                    "uint32 " + object
                                );
                                return object;
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return 0;
                                }
                                _SerializerValidation2.default.require_range(
                                    MIN_SIGNED_32,
                                    MAX_SIGNED_32,
                                    object,
                                    "uint32 " + object
                                );
                                return parseInt(object);
                            }
                        };

                        Types.int64 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readInt64();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.required(object);
                                b.writeInt64(
                                    _SerializerValidation2.default.to_long(
                                        object
                                    )
                                );
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(object);
                                return _SerializerValidation2.default.to_long(
                                    object
                                );
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return "0";
                                }
                                _SerializerValidation2.default.required(object);
                                return _SerializerValidation2.default
                                    .to_long(object)
                                    .toString();
                            }
                        };

                        Types.uint64 = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint64();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                b.writeUint64(
                                    _SerializerValidation2.default.to_long(
                                        _SerializerValidation2.default.unsigned(
                                            object
                                        ),
                                        undefined,
                                        true
                                    )
                                );
                                return;
                            },
                            fromObject: function fromObject(object) {
                                return _SerializerValidation2.default.to_long(
                                    _SerializerValidation2.default.unsigned(
                                        object
                                    ),
                                    undefined,
                                    true
                                );
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return "0";
                                }
                                return _SerializerValidation2.default
                                    .to_long(object, undefined, true)
                                    .toString();
                            }
                        };

                        Types.string = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                var b_copy;
                                var len = b.readVarint32();
                                (b_copy = b.copy(b.offset, b.offset + len)),
                                    b.skip(len);
                                return new Buffer(b_copy.toBinary(), "binary");
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.required(object);
                                b.writeVarint32(object.length);
                                b.append(object.toString("binary"), "binary");
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(object);
                                return new Buffer(object);
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return "";
                                }
                                return object.toString();
                            }
                        };

                        Types.bytes = function(size) {
                            return {
                                fromByteBuffer: function fromByteBuffer(b) {
                                    if (size === undefined) {
                                        var b_copy;
                                        var len = b.readVarint32();
                                        (b_copy = b.copy(
                                            b.offset,
                                            b.offset + len
                                        )),
                                            b.skip(len);
                                        return new Buffer(
                                            b_copy.toBinary(),
                                            "binary"
                                        );
                                    } else {
                                        (b_copy = b.copy(
                                            b.offset,
                                            b.offset + size
                                        )),
                                            b.skip(size);
                                        return new Buffer(
                                            b_copy.toBinary(),
                                            "binary"
                                        );
                                    }
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    if (typeof object === "string")
                                        object = new Buffer(object, "hex");

                                    if (size === undefined) {
                                        b.writeVarint32(object.length);
                                    }
                                    b.append(
                                        object.toString("binary"),
                                        "binary"
                                    );
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    if (Buffer.isBuffer(object)) return object;

                                    return new Buffer(object, "hex");
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        var zeros = function zeros(num) {
                                            return new Array(num).join("00");
                                        };
                                        return zeros(size);
                                    }
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    return object.toString("hex");
                                }
                            };
                        };

                        Types.bool = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint8() === 1;
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                // supports boolean or integer
                                b.writeUint8(JSON.parse(object) ? 1 : 0);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                return JSON.parse(object) ? true : false;
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return false;
                                }
                                return JSON.parse(object) ? true : false;
                            }
                        };

                        Types.void = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                throw new Error("(void) undefined type");
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                throw new Error("(void) undefined type");
                            },
                            fromObject: function fromObject(object) {
                                throw new Error("(void) undefined type");
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return undefined;
                                }
                                throw new Error("(void) undefined type");
                            }
                        };

                        Types.array = function(st_operation) {
                            return {
                                fromByteBuffer: function fromByteBuffer(b) {
                                    var size = b.readVarint32();
                                    if (HEX_DUMP) {
                                        console.log(
                                            "varint32 size = " +
                                                size.toString(16)
                                        );
                                    }
                                    var result = [];
                                    for (
                                        var i = 0;
                                        0 < size ? i < size : i > size;
                                        0 < size ? i++ : i++
                                    ) {
                                        result.push(
                                            st_operation.fromByteBuffer(b)
                                        );
                                    }
                                    return sortOperation(result, st_operation);
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    object = sortOperation(
                                        object,
                                        st_operation
                                    );
                                    b.writeVarint32(object.length);
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        st_operation.appendByteBuffer(b, o);
                                    }
                                },
                                fromObject: function fromObject(object) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    object = sortOperation(
                                        object,
                                        st_operation
                                    );
                                    var result = [];
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        result.push(st_operation.fromObject(o));
                                    }
                                    return result;
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        return [
                                            st_operation.toObject(object, debug)
                                        ];
                                    }
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    object = sortOperation(
                                        object,
                                        st_operation
                                    );

                                    var result = [];
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        result.push(
                                            st_operation.toObject(o, debug)
                                        );
                                    }
                                    return result;
                                }
                            };
                        };

                        Types.time_point_sec = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return b.readUint32();
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                if (typeof object !== "number")
                                    object = Types.time_point_sec.fromObject(
                                        object
                                    );

                                b.writeUint32(object);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(object);

                                if (typeof object === "number") return object;

                                if (object.getTime)
                                    return Math.floor(object.getTime() / 1000);

                                if (typeof object !== "string")
                                    throw new Error(
                                        "Unknown date type: " + object
                                    );

                                if (
                                    /T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/.test(
                                        object
                                    )
                                )
                                    object = object + "Z";

                                return Math.floor(
                                    new Date(object).getTime() / 1000
                                );
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined)
                                    return new Date(0)
                                        .toISOString()
                                        .split(".")[0];

                                _SerializerValidation2.default.required(object);

                                if (typeof object === "string") return object;

                                if (object.getTime)
                                    return object.toISOString().split(".")[0];

                                var int = parseInt(object);
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffffffff,
                                    int,
                                    "uint32 " + object
                                );
                                return new Date(int * 1000)
                                    .toISOString()
                                    .split(".")[0];
                            }
                        };

                        Types.set = function(st_operation) {
                            return {
                                validate: function validate(array) {
                                    var dup_map = {};
                                    for (var i = 0, o; i < array.length; i++) {
                                        o = array[i];
                                        var ref;
                                        if (
                                            ((ref =
                                                typeof o === "undefined"
                                                    ? "undefined"
                                                    : _typeof(o)),
                                            ["string", "number"].indexOf(ref) >=
                                                0)
                                        ) {
                                            if (dup_map[o] !== undefined) {
                                                throw new Error(
                                                    "duplicate (set)"
                                                );
                                            }
                                            dup_map[o] = true;
                                        }
                                    }
                                    return sortOperation(array, st_operation);
                                },
                                fromByteBuffer: function fromByteBuffer(b) {
                                    var size = b.readVarint32();
                                    if (HEX_DUMP) {
                                        console.log(
                                            "varint32 size = " +
                                                size.toString(16)
                                        );
                                    }
                                    return this.validate(
                                        (function() {
                                            var result = [];
                                            for (
                                                var i = 0;
                                                0 < size ? i < size : i > size;
                                                0 < size ? i++ : i++
                                            ) {
                                                result.push(
                                                    st_operation.fromByteBuffer(
                                                        b
                                                    )
                                                );
                                            }
                                            return result;
                                        })()
                                    );
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    if (!object) {
                                        object = [];
                                    }
                                    b.writeVarint32(object.length);
                                    var iterable = this.validate(object);
                                    for (
                                        var i = 0, o;
                                        i < iterable.length;
                                        i++
                                    ) {
                                        o = iterable[i];
                                        st_operation.appendByteBuffer(b, o);
                                    }
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    if (!object) {
                                        object = [];
                                    }
                                    return this.validate(
                                        (function() {
                                            var result = [];
                                            for (
                                                var i = 0, o;
                                                i < object.length;
                                                i++
                                            ) {
                                                o = object[i];
                                                result.push(
                                                    st_operation.fromObject(o)
                                                );
                                            }
                                            return result;
                                        })()
                                    );
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        return [
                                            st_operation.toObject(object, debug)
                                        ];
                                    }
                                    if (!object) {
                                        object = [];
                                    }
                                    return this.validate(
                                        (function() {
                                            var result = [];
                                            for (
                                                var i = 0, o;
                                                i < object.length;
                                                i++
                                            ) {
                                                o = object[i];
                                                result.push(
                                                    st_operation.toObject(
                                                        o,
                                                        debug
                                                    )
                                                );
                                            }
                                            return result;
                                        })()
                                    );
                                }
                            };
                        };

                        // global_parameters_update_operation current_fees
                        Types.fixed_array = function(count, st_operation) {
                            return {
                                fromByteBuffer: function fromByteBuffer(b) {
                                    var i, j, ref, results;
                                    results = [];
                                    for (
                                        i = j = 0, ref = count;
                                        j < ref;
                                        i = j += 1
                                    ) {
                                        results.push(
                                            st_operation.fromByteBuffer(b)
                                        );
                                    }
                                    return sortOperation(results, st_operation);
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    var i, j, ref;
                                    if (count !== 0) {
                                        _SerializerValidation2.default.required(
                                            object
                                        );
                                        object = sortOperation(
                                            object,
                                            st_operation
                                        );
                                    }
                                    for (
                                        i = j = 0, ref = count;
                                        j < ref;
                                        i = j += 1
                                    ) {
                                        st_operation.appendByteBuffer(
                                            b,
                                            object[i]
                                        );
                                    }
                                },
                                fromObject: function fromObject(object) {
                                    var i, j, ref, results;
                                    if (count !== 0) {
                                        _SerializerValidation2.default.required(
                                            object
                                        );
                                    }
                                    results = [];
                                    for (
                                        i = j = 0, ref = count;
                                        j < ref;
                                        i = j += 1
                                    ) {
                                        results.push(
                                            st_operation.fromObject(object[i])
                                        );
                                    }
                                    return results;
                                },
                                toObject: function toObject(object, debug) {
                                    var i, j, k, ref, ref1, results, results1;
                                    if (debug == null) {
                                        debug = {};
                                    }
                                    if (
                                        debug.use_default &&
                                        object === void 0
                                    ) {
                                        results = [];
                                        for (
                                            i = j = 0, ref = count;
                                            j < ref;
                                            i = j += 1
                                        ) {
                                            results.push(
                                                st_operation.toObject(
                                                    void 0,
                                                    debug
                                                )
                                            );
                                        }
                                        return results;
                                    }
                                    if (count !== 0) {
                                        _SerializerValidation2.default.required(
                                            object
                                        );
                                    }
                                    results1 = [];
                                    for (
                                        i = k = 0, ref1 = count;
                                        k < ref1;
                                        i = k += 1
                                    ) {
                                        results1.push(
                                            st_operation.toObject(
                                                object[i],
                                                debug
                                            )
                                        );
                                    }
                                    return results1;
                                }
                            };
                        };

                        /* Supports instance numbers (11) or object types (1.2.11).  Object type
Validation is enforced when an object type is used. */
                        var id_type = function id_type(
                            reserved_spaces,
                            object_type
                        ) {
                            _SerializerValidation2.default.required(
                                reserved_spaces,
                                "reserved_spaces"
                            );
                            _SerializerValidation2.default.required(
                                object_type,
                                "object_type"
                            );
                            return {
                                fromByteBuffer: function fromByteBuffer(b) {
                                    return b.readVarint32();
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    if (object.resolve !== undefined) {
                                        object = object.resolve;
                                    }
                                    // convert 1.2.n into just n
                                    if (
                                        /^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)
                                    ) {
                                        object = _SerializerValidation2.default.get_instance(
                                            reserved_spaces,
                                            object_type,
                                            object
                                        );
                                    }
                                    b.writeVarint32(
                                        _SerializerValidation2.default.to_number(
                                            object
                                        )
                                    );
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    if (object.resolve !== undefined) {
                                        object = object.resolve;
                                    }
                                    if (
                                        _SerializerValidation2.default.is_digits(
                                            object
                                        )
                                    ) {
                                        return _SerializerValidation2.default.to_number(
                                            object
                                        );
                                    }
                                    return _SerializerValidation2.default.get_instance(
                                        reserved_spaces,
                                        object_type,
                                        object
                                    );
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    var object_type_id =
                                        _ChainTypes2.default.object_type[
                                            object_type
                                        ];
                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        return (
                                            reserved_spaces +
                                            "." +
                                            object_type_id +
                                            ".0"
                                        );
                                    }
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    if (object.resolve !== undefined) {
                                        object = object.resolve;
                                    }
                                    if (
                                        /^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)
                                    ) {
                                        object = _SerializerValidation2.default.get_instance(
                                            reserved_spaces,
                                            object_type,
                                            object
                                        );
                                    }

                                    return (
                                        reserved_spaces +
                                        "." +
                                        object_type_id +
                                        "." +
                                        object
                                    );
                                }
                            };
                        };

                        Types.protocol_id_type = function(name) {
                            _SerializerValidation2.default.required(
                                name,
                                "name"
                            );
                            return id_type(
                                _ChainTypes2.default.reserved_spaces
                                    .protocol_ids,
                                name
                            );
                        };

                        Types.object_id_type = {
                            fromByteBuffer: function fromByteBuffer(b) {
                                return _ObjectId2.default.fromByteBuffer(b);
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.required(object);
                                if (object.resolve !== undefined) {
                                    object = object.resolve;
                                }
                                object = _ObjectId2.default.fromString(object);
                                object.appendByteBuffer(b);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(object);
                                if (object.resolve !== undefined) {
                                    object = object.resolve;
                                }
                                return _ObjectId2.default.fromString(object);
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return "0.0.0";
                                }
                                _SerializerValidation2.default.required(object);
                                if (object.resolve !== undefined) {
                                    object = object.resolve;
                                }
                                object = _ObjectId2.default.fromString(object);
                                return object.toString();
                            }
                        };

                        Types.vote_id = {
                            TYPE: 0x000000ff,
                            ID: 0xffffff00,
                            fromByteBuffer: function fromByteBuffer(b) {
                                var value = b.readUint32();
                                return {
                                    type: value & this.TYPE,
                                    id: value & this.ID
                                };
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.required(object);
                                if (object === "string")
                                    object = Types.vote_id.fromObject(object);

                                var value = (object.id << 8) | object.type;
                                b.writeUint32(value);
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(
                                    object,
                                    "(type vote_id)"
                                );
                                if (
                                    (typeof object === "undefined"
                                        ? "undefined"
                                        : _typeof(object)) === "object"
                                ) {
                                    _SerializerValidation2.default.required(
                                        object.type,
                                        "type"
                                    );
                                    _SerializerValidation2.default.required(
                                        object.id,
                                        "id"
                                    );
                                    return object;
                                }
                                _SerializerValidation2.default.require_test(
                                    /^[0-9]+:[0-9]+$/,
                                    object,
                                    "vote_id format " + object
                                );

                                var _object$split = object.split(":"),
                                    type = _object$split[0],
                                    id = _object$split[1];

                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xff,
                                    type,
                                    "vote type " + object
                                );
                                _SerializerValidation2.default.require_range(
                                    0,
                                    0xffffff,
                                    id,
                                    "vote id " + object
                                );
                                return {type: type, id: id};
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return "0:0";
                                }
                                _SerializerValidation2.default.required(object);
                                if (typeof object === "string")
                                    object = Types.vote_id.fromObject(object);

                                return object.type + ":" + object.id;
                            },
                            compare: function compare(a, b) {
                                if (
                                    (typeof a === "undefined"
                                        ? "undefined"
                                        : _typeof(a)) !== "object"
                                )
                                    a = Types.vote_id.fromObject(a);
                                if (
                                    (typeof b === "undefined"
                                        ? "undefined"
                                        : _typeof(b)) !== "object"
                                )
                                    b = Types.vote_id.fromObject(b);
                                return parseInt(a.id) - parseInt(b.id);
                            }
                        };

                        Types.optional = function(st_operation) {
                            _SerializerValidation2.default.required(
                                st_operation,
                                "st_operation"
                            );
                            return {
                                fromByteBuffer: function fromByteBuffer(b) {
                                    if (!(b.readUint8() === 1)) {
                                        return undefined;
                                    }
                                    return st_operation.fromByteBuffer(b);
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    if (
                                        object !== null &&
                                        object !== undefined
                                    ) {
                                        b.writeUint8(1);
                                        st_operation.appendByteBuffer(
                                            b,
                                            object
                                        );
                                    } else {
                                        b.writeUint8(0);
                                    }
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    if (object === undefined) {
                                        return undefined;
                                    }
                                    return st_operation.fromObject(object);
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    // toObject is only null save if use_default is true
                                    var result_object = (function() {
                                        if (
                                            !debug.use_default &&
                                            object === undefined
                                        ) {
                                            return undefined;
                                        } else {
                                            return st_operation.toObject(
                                                object,
                                                debug
                                            );
                                        }
                                    })();

                                    if (debug.annotate) {
                                        if (
                                            (typeof result_object ===
                                            "undefined"
                                                ? "undefined"
                                                : _typeof(result_object)) ===
                                            "object"
                                        ) {
                                            result_object.__optional =
                                                "parent is optional";
                                        } else {
                                            result_object = {
                                                __optional: result_object
                                            };
                                        }
                                    }
                                    return result_object;
                                }
                            };
                        };

                        Types.static_variant = function(_st_operations) {
                            return {
                                nosort: true,
                                st_operations: _st_operations,
                                fromByteBuffer: function fromByteBuffer(b) {
                                    var type_id = b.readVarint32();
                                    var st_operation = this.st_operations[
                                        type_id
                                    ];
                                    if (HEX_DUMP) {
                                        console.error(
                                            "static_variant id 0x" +
                                                type_id.toString(16) +
                                                " (" +
                                                type_id +
                                                ")"
                                        );
                                    }
                                    _SerializerValidation2.default.required(
                                        st_operation,
                                        "operation " + type_id
                                    );
                                    return [
                                        type_id,
                                        st_operation.fromByteBuffer(b)
                                    ];
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    var type_id = object[0];
                                    var st_operation = this.st_operations[
                                        type_id
                                    ];
                                    _SerializerValidation2.default.required(
                                        st_operation,
                                        "operation " + type_id
                                    );
                                    b.writeVarint32(type_id);
                                    st_operation.appendByteBuffer(b, object[1]);
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    var type_id = object[0];
                                    var st_operation = this.st_operations[
                                        type_id
                                    ];
                                    _SerializerValidation2.default.required(
                                        st_operation,
                                        "operation " + type_id
                                    );
                                    return [
                                        type_id,
                                        st_operation.fromObject(object[1])
                                    ];
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        return [
                                            0,
                                            this.st_operations[0].toObject(
                                                undefined,
                                                debug
                                            )
                                        ];
                                    }
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    var type_id = object[0];
                                    var st_operation = this.st_operations[
                                        type_id
                                    ];
                                    _SerializerValidation2.default.required(
                                        st_operation,
                                        "operation " + type_id
                                    );
                                    return [
                                        type_id,
                                        st_operation.toObject(object[1], debug)
                                    ];
                                }
                            };
                        };

                        Types.map = function(
                            key_st_operation,
                            value_st_operation
                        ) {
                            return {
                                validate: function validate(array) {
                                    if (!Array.isArray(array)) {
                                        throw new Error("expecting array");
                                    }
                                    var dup_map = {};
                                    for (var i = 0, o; i < array.length; i++) {
                                        o = array[i];
                                        var ref;
                                        if (!(o.length === 2)) {
                                            throw new Error(
                                                "expecting two elements"
                                            );
                                        }
                                        if (
                                            ((ref = _typeof(o[0])),
                                            ["number", "string"].indexOf(ref) >=
                                                0)
                                        ) {
                                            if (dup_map[o[0]] !== undefined) {
                                                throw new Error(
                                                    "duplicate (map)"
                                                );
                                            }
                                            dup_map[o[0]] = true;
                                        }
                                    }
                                    return sortOperation(
                                        array,
                                        key_st_operation
                                    );
                                },
                                fromByteBuffer: function fromByteBuffer(b) {
                                    var result = [];
                                    var end = b.readVarint32();
                                    for (
                                        var i = 0;
                                        0 < end ? i < end : i > end;
                                        0 < end ? i++ : i++
                                    ) {
                                        result.push([
                                            key_st_operation.fromByteBuffer(b),
                                            value_st_operation.fromByteBuffer(b)
                                        ]);
                                    }
                                    return this.validate(result);
                                },
                                appendByteBuffer: function appendByteBuffer(
                                    b,
                                    object
                                ) {
                                    this.validate(object);
                                    b.writeVarint32(object.length);
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        key_st_operation.appendByteBuffer(
                                            b,
                                            o[0]
                                        );
                                        value_st_operation.appendByteBuffer(
                                            b,
                                            o[1]
                                        );
                                    }
                                    return;
                                },
                                fromObject: function fromObject(object) {
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    var result = [];
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        result.push([
                                            key_st_operation.fromObject(o[0]),
                                            value_st_operation.fromObject(o[1])
                                        ]);
                                    }
                                    return this.validate(result);
                                },
                                toObject: function toObject(object) {
                                    var debug =
                                        arguments.length > 1 &&
                                        arguments[1] !== undefined
                                            ? arguments[1]
                                            : {};

                                    if (
                                        debug.use_default &&
                                        object === undefined
                                    ) {
                                        return [
                                            [
                                                key_st_operation.toObject(
                                                    undefined,
                                                    debug
                                                ),
                                                value_st_operation.toObject(
                                                    undefined,
                                                    debug
                                                )
                                            ]
                                        ];
                                    }
                                    _SerializerValidation2.default.required(
                                        object
                                    );
                                    object = this.validate(object);
                                    var result = [];
                                    for (var i = 0, o; i < object.length; i++) {
                                        o = object[i];
                                        result.push([
                                            key_st_operation.toObject(
                                                o[0],
                                                debug
                                            ),
                                            value_st_operation.toObject(
                                                o[1],
                                                debug
                                            )
                                        ]);
                                    }
                                    return result;
                                }
                            };
                        };

                        Types.public_key = {
                            toPublic: function toPublic(object) {
                                if (object.resolve !== undefined) {
                                    object = object.resolve;
                                }
                                return object == null
                                    ? object
                                    : object.Q
                                        ? object
                                        : _ecc.PublicKey.fromStringOrThrow(
                                              object
                                          );
                            },
                            fromByteBuffer: function fromByteBuffer(b) {
                                return _FastParser2.default.public_key(b);
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _SerializerValidation2.default.required(object);
                                _FastParser2.default.public_key(
                                    b,
                                    Types.public_key.toPublic(object)
                                );
                                return;
                            },
                            fromObject: function fromObject(object) {
                                _SerializerValidation2.default.required(object);
                                if (object.Q) {
                                    return object;
                                }
                                return Types.public_key.toPublic(object);
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return (
                                        _bitsharesjsWs.ChainConfig
                                            .address_prefix +
                                        "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM"
                                    );
                                }
                                _SerializerValidation2.default.required(object);
                                return object.toString();
                            },
                            compare: function compare(a, b) {
                                return Types.public_key
                                    .fromObject(a)
                                    .toBlockchainAddress()
                                    .compare(
                                        Types.public_key
                                            .fromObject(b)
                                            .toBlockchainAddress()
                                    );
                            }
                        };

                        Types.address = {
                            _to_address: function _to_address(object) {
                                _SerializerValidation2.default.required(object);
                                if (object.addy) {
                                    return object;
                                }
                                return _ecc.Address.fromString(object);
                            },
                            fromByteBuffer: function fromByteBuffer(b) {
                                return new _ecc.Address(
                                    _FastParser2.default.ripemd160(b)
                                );
                            },
                            appendByteBuffer: function appendByteBuffer(
                                b,
                                object
                            ) {
                                _FastParser2.default.ripemd160(
                                    b,
                                    Types.address._to_address(object).toBuffer()
                                );
                                return;
                            },
                            fromObject: function fromObject(object) {
                                return Types.address._to_address(object);
                            },
                            toObject: function toObject(object) {
                                var debug =
                                    arguments.length > 1 &&
                                    arguments[1] !== undefined
                                        ? arguments[1]
                                        : {};

                                if (debug.use_default && object === undefined) {
                                    return (
                                        _bitsharesjsWs.ChainConfig
                                            .address_prefix +
                                        "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S"
                                    );
                                }
                                return Types.address
                                    ._to_address(object)
                                    .toString();
                            },
                            compare: function compare(a, b) {
                                return strCmp(a.toString(), b.toString());
                            }
                        };

                        var strCmp = function strCmp(a, b) {
                            return a > b ? 1 : a < b ? -1 : 0;
                        };
                        var firstEl = function firstEl(el) {
                            return Array.isArray(el) ? el[0] : el;
                        };
                        var sortOperation = function sortOperation(
                            array,
                            st_operation
                        ) {
                            return st_operation.nosort
                                ? array
                                : st_operation.compare
                                    ? array.sort(function(a, b) {
                                          return st_operation.compare(
                                              firstEl(a),
                                              firstEl(b)
                                          );
                                      }) // custom compare operation
                                    : array.sort(function(a, b) {
                                          return typeof firstEl(a) ===
                                              "number" &&
                                              typeof firstEl(b) === "number"
                                              ? firstEl(a) - firstEl(b) // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
                                              : Buffer.isBuffer(firstEl(a)) &&
                                                Buffer.isBuffer(firstEl(b))
                                                  ? strCmp(
                                                        firstEl(a).toString(
                                                            "hex"
                                                        ),
                                                        firstEl(b).toString(
                                                            "hex"
                                                        )
                                                    )
                                                  : strCmp(
                                                        firstEl(a).toString(),
                                                        firstEl(b).toString()
                                                    );
                                      });
                        };

                        exports.default = Types;
                        module.exports = exports["default"];
                    }.call(
                        this,
                        require("_process"),
                        require("buffer").Buffer
                    ));
                },
                {
                    "../../chain/src/ChainTypes":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ChainTypes.js",
                    "../../chain/src/ObjectId":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/chain/src/ObjectId.js",
                    "../../ecc":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/ecc/index.js",
                    "./FastParser":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/FastParser.js",
                    "./SerializerValidation":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/dist/serializer/src/SerializerValidation.js",
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    "bitsharesjs-ws":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js": [
                function(require, module, exports) {
                    (function(global) {
                        "use strict";

                        // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                        // original notice:

                        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                        function compare(a, b) {
                            if (a === b) {
                                return 0;
                            }

                            var x = a.length;
                            var y = b.length;

                            for (
                                var i = 0, len = Math.min(x, y);
                                i < len;
                                ++i
                            ) {
                                if (a[i] !== b[i]) {
                                    x = a[i];
                                    y = b[i];
                                    break;
                                }
                            }

                            if (x < y) {
                                return -1;
                            }
                            if (y < x) {
                                return 1;
                            }
                            return 0;
                        }
                        function isBuffer(b) {
                            if (
                                global.Buffer &&
                                typeof global.Buffer.isBuffer === "function"
                            ) {
                                return global.Buffer.isBuffer(b);
                            }
                            return !!(b != null && b._isBuffer);
                        }

                        // based on node assert, original notice:

                        // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
                        //
                        // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
                        //
                        // Originally from narwhal.js (http://narwhaljs.org)
                        // Copyright (c) 2009 Thomas Robinson <280north.com>
                        //
                        // Permission is hereby granted, free of charge, to any person obtaining a copy
                        // of this software and associated documentation files (the 'Software'), to
                        // deal in the Software without restriction, including without limitation the
                        // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                        // sell copies of the Software, and to permit persons to whom the Software is
                        // furnished to do so, subject to the following conditions:
                        //
                        // The above copyright notice and this permission notice shall be included in
                        // all copies or substantial portions of the Software.
                        //
                        // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                        // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                        // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

                        var util = require("util/");
                        var hasOwn = Object.prototype.hasOwnProperty;
                        var pSlice = Array.prototype.slice;
                        var functionsHaveNames = (function() {
                            return function foo() {}.name === "foo";
                        })();
                        function pToString(obj) {
                            return Object.prototype.toString.call(obj);
                        }
                        function isView(arrbuf) {
                            if (isBuffer(arrbuf)) {
                                return false;
                            }
                            if (typeof global.ArrayBuffer !== "function") {
                                return false;
                            }
                            if (typeof ArrayBuffer.isView === "function") {
                                return ArrayBuffer.isView(arrbuf);
                            }
                            if (!arrbuf) {
                                return false;
                            }
                            if (arrbuf instanceof DataView) {
                                return true;
                            }
                            if (
                                arrbuf.buffer &&
                                arrbuf.buffer instanceof ArrayBuffer
                            ) {
                                return true;
                            }
                            return false;
                        }
                        // 1. The assert module provides functions that throw
                        // AssertionError's when particular conditions are not met. The
                        // assert module must conform to the following interface.

                        var assert = (module.exports = ok);

                        // 2. The AssertionError is defined in assert.
                        // new assert.AssertionError({ message: message,
                        //                             actual: actual,
                        //                             expected: expected })

                        var regex = /\s*function\s+([^\(\s]*)\s*/;
                        // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
                        function getName(func) {
                            if (!util.isFunction(func)) {
                                return;
                            }
                            if (functionsHaveNames) {
                                return func.name;
                            }
                            var str = func.toString();
                            var match = str.match(regex);
                            return match && match[1];
                        }
                        assert.AssertionError = function AssertionError(
                            options
                        ) {
                            this.name = "AssertionError";
                            this.actual = options.actual;
                            this.expected = options.expected;
                            this.operator = options.operator;
                            if (options.message) {
                                this.message = options.message;
                                this.generatedMessage = false;
                            } else {
                                this.message = getMessage(this);
                                this.generatedMessage = true;
                            }
                            var stackStartFunction =
                                options.stackStartFunction || fail;
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(
                                    this,
                                    stackStartFunction
                                );
                            } else {
                                // non v8 browsers so we can have a stacktrace
                                var err = new Error();
                                if (err.stack) {
                                    var out = err.stack;

                                    // try to strip useless frames
                                    var fn_name = getName(stackStartFunction);
                                    var idx = out.indexOf("\n" + fn_name);
                                    if (idx >= 0) {
                                        // once we have located the function frame
                                        // we need to strip out everything before it (and its line)
                                        var next_line = out.indexOf(
                                            "\n",
                                            idx + 1
                                        );
                                        out = out.substring(next_line + 1);
                                    }

                                    this.stack = out;
                                }
                            }
                        };

                        // assert.AssertionError instanceof Error
                        util.inherits(assert.AssertionError, Error);

                        function truncate(s, n) {
                            if (typeof s === "string") {
                                return s.length < n ? s : s.slice(0, n);
                            } else {
                                return s;
                            }
                        }
                        function inspect(something) {
                            if (
                                functionsHaveNames ||
                                !util.isFunction(something)
                            ) {
                                return util.inspect(something);
                            }
                            var rawname = getName(something);
                            var name = rawname ? ": " + rawname : "";
                            return "[Function" + name + "]";
                        }
                        function getMessage(self) {
                            return (
                                truncate(inspect(self.actual), 128) +
                                " " +
                                self.operator +
                                " " +
                                truncate(inspect(self.expected), 128)
                            );
                        }

                        // At present only the three keys mentioned above are used and
                        // understood by the spec. Implementations or sub modules can pass
                        // other keys to the AssertionError's constructor - they will be
                        // ignored.

                        // 3. All of the following functions must throw an AssertionError
                        // when a corresponding condition is not met, with a message that
                        // may be undefined if not provided.  All assertion methods provide
                        // both the actual and expected values to the assertion error for
                        // display purposes.

                        function fail(
                            actual,
                            expected,
                            message,
                            operator,
                            stackStartFunction
                        ) {
                            throw new assert.AssertionError({
                                message: message,
                                actual: actual,
                                expected: expected,
                                operator: operator,
                                stackStartFunction: stackStartFunction
                            });
                        }

                        // EXTENSION! allows for well behaved errors defined elsewhere.
                        assert.fail = fail;

                        // 4. Pure assertion tests whether a value is truthy, as determined
                        // by !!guard.
                        // assert.ok(guard, message_opt);
                        // This statement is equivalent to assert.equal(true, !!guard,
                        // message_opt);. To test strictly for the value true, use
                        // assert.strictEqual(true, guard, message_opt);.

                        function ok(value, message) {
                            if (!value)
                                fail(value, true, message, "==", assert.ok);
                        }
                        assert.ok = ok;

                        // 5. The equality assertion tests shallow, coercive equality with
                        // ==.
                        // assert.equal(actual, expected, message_opt);

                        assert.equal = function equal(
                            actual,
                            expected,
                            message
                        ) {
                            if (actual != expected)
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "==",
                                    assert.equal
                                );
                        };

                        // 6. The non-equality assertion tests for whether two objects are not equal
                        // with != assert.notEqual(actual, expected, message_opt);

                        assert.notEqual = function notEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (actual == expected) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "!=",
                                    assert.notEqual
                                );
                            }
                        };

                        // 7. The equivalence assertion tests a deep equality relation.
                        // assert.deepEqual(actual, expected, message_opt);

                        assert.deepEqual = function deepEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (!_deepEqual(actual, expected, false)) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "deepEqual",
                                    assert.deepEqual
                                );
                            }
                        };

                        assert.deepStrictEqual = function deepStrictEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (!_deepEqual(actual, expected, true)) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "deepStrictEqual",
                                    assert.deepStrictEqual
                                );
                            }
                        };

                        function _deepEqual(actual, expected, strict, memos) {
                            // 7.1. All identical values are equivalent, as determined by ===.
                            if (actual === expected) {
                                return true;
                            } else if (isBuffer(actual) && isBuffer(expected)) {
                                return compare(actual, expected) === 0;

                                // 7.2. If the expected value is a Date object, the actual value is
                                // equivalent if it is also a Date object that refers to the same time.
                            } else if (
                                util.isDate(actual) &&
                                util.isDate(expected)
                            ) {
                                return actual.getTime() === expected.getTime();

                                // 7.3 If the expected value is a RegExp object, the actual value is
                                // equivalent if it is also a RegExp object with the same source and
                                // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
                            } else if (
                                util.isRegExp(actual) &&
                                util.isRegExp(expected)
                            ) {
                                return (
                                    actual.source === expected.source &&
                                    actual.global === expected.global &&
                                    actual.multiline === expected.multiline &&
                                    actual.lastIndex === expected.lastIndex &&
                                    actual.ignoreCase === expected.ignoreCase
                                );

                                // 7.4. Other pairs that do not both pass typeof value == 'object',
                                // equivalence is determined by ==.
                            } else if (
                                (actual === null ||
                                    typeof actual !== "object") &&
                                (expected === null ||
                                    typeof expected !== "object")
                            ) {
                                return strict
                                    ? actual === expected
                                    : actual == expected;

                                // If both values are instances of typed arrays, wrap their underlying
                                // ArrayBuffers in a Buffer each to increase performance
                                // This optimization requires the arrays to have the same type as checked by
                                // Object.prototype.toString (aka pToString). Never perform binary
                                // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
                                // bit patterns are not identical.
                            } else if (
                                isView(actual) &&
                                isView(expected) &&
                                pToString(actual) === pToString(expected) &&
                                !(
                                    actual instanceof Float32Array ||
                                    actual instanceof Float64Array
                                )
                            ) {
                                return (
                                    compare(
                                        new Uint8Array(actual.buffer),
                                        new Uint8Array(expected.buffer)
                                    ) === 0
                                );

                                // 7.5 For all other Object pairs, including Array objects, equivalence is
                                // determined by having the same number of owned properties (as verified
                                // with Object.prototype.hasOwnProperty.call), the same set of keys
                                // (although not necessarily the same order), equivalent values for every
                                // corresponding key, and an identical 'prototype' property. Note: this
                                // accounts for both named and indexed properties on Arrays.
                            } else if (
                                isBuffer(actual) !== isBuffer(expected)
                            ) {
                                return false;
                            } else {
                                memos = memos || {actual: [], expected: []};

                                var actualIndex = memos.actual.indexOf(actual);
                                if (actualIndex !== -1) {
                                    if (
                                        actualIndex ===
                                        memos.expected.indexOf(expected)
                                    ) {
                                        return true;
                                    }
                                }

                                memos.actual.push(actual);
                                memos.expected.push(expected);

                                return objEquiv(
                                    actual,
                                    expected,
                                    strict,
                                    memos
                                );
                            }
                        }

                        function isArguments(object) {
                            return (
                                Object.prototype.toString.call(object) ==
                                "[object Arguments]"
                            );
                        }

                        function objEquiv(a, b, strict, actualVisitedObjects) {
                            if (
                                a === null ||
                                a === undefined ||
                                b === null ||
                                b === undefined
                            )
                                return false;
                            // if one is a primitive, the other must be same
                            if (util.isPrimitive(a) || util.isPrimitive(b))
                                return a === b;
                            if (
                                strict &&
                                Object.getPrototypeOf(a) !==
                                    Object.getPrototypeOf(b)
                            )
                                return false;
                            var aIsArgs = isArguments(a);
                            var bIsArgs = isArguments(b);
                            if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
                                return false;
                            if (aIsArgs) {
                                a = pSlice.call(a);
                                b = pSlice.call(b);
                                return _deepEqual(a, b, strict);
                            }
                            var ka = objectKeys(a);
                            var kb = objectKeys(b);
                            var key, i;
                            // having the same number of owned properties (keys incorporates
                            // hasOwnProperty)
                            if (ka.length !== kb.length) return false;
                            //the same set of keys (although not necessarily the same order),
                            ka.sort();
                            kb.sort();
                            //~~~cheap key test
                            for (i = ka.length - 1; i >= 0; i--) {
                                if (ka[i] !== kb[i]) return false;
                            }
                            //equivalent values for every corresponding key, and
                            //~~~possibly expensive deep test
                            for (i = ka.length - 1; i >= 0; i--) {
                                key = ka[i];
                                if (
                                    !_deepEqual(
                                        a[key],
                                        b[key],
                                        strict,
                                        actualVisitedObjects
                                    )
                                )
                                    return false;
                            }
                            return true;
                        }

                        // 8. The non-equivalence assertion tests for any deep inequality.
                        // assert.notDeepEqual(actual, expected, message_opt);

                        assert.notDeepEqual = function notDeepEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (_deepEqual(actual, expected, false)) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "notDeepEqual",
                                    assert.notDeepEqual
                                );
                            }
                        };

                        assert.notDeepStrictEqual = notDeepStrictEqual;
                        function notDeepStrictEqual(actual, expected, message) {
                            if (_deepEqual(actual, expected, true)) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "notDeepStrictEqual",
                                    notDeepStrictEqual
                                );
                            }
                        }

                        // 9. The strict equality assertion tests strict equality, as determined by ===.
                        // assert.strictEqual(actual, expected, message_opt);

                        assert.strictEqual = function strictEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (actual !== expected) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "===",
                                    assert.strictEqual
                                );
                            }
                        };

                        // 10. The strict non-equality assertion tests for strict inequality, as
                        // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

                        assert.notStrictEqual = function notStrictEqual(
                            actual,
                            expected,
                            message
                        ) {
                            if (actual === expected) {
                                fail(
                                    actual,
                                    expected,
                                    message,
                                    "!==",
                                    assert.notStrictEqual
                                );
                            }
                        };

                        function expectedException(actual, expected) {
                            if (!actual || !expected) {
                                return false;
                            }

                            if (
                                Object.prototype.toString.call(expected) ==
                                "[object RegExp]"
                            ) {
                                return expected.test(actual);
                            }

                            try {
                                if (actual instanceof expected) {
                                    return true;
                                }
                            } catch (e) {
                                // Ignore.  The instanceof check doesn't work for arrow functions.
                            }

                            if (Error.isPrototypeOf(expected)) {
                                return false;
                            }

                            return expected.call({}, actual) === true;
                        }

                        function _tryBlock(block) {
                            var error;
                            try {
                                block();
                            } catch (e) {
                                error = e;
                            }
                            return error;
                        }

                        function _throws(
                            shouldThrow,
                            block,
                            expected,
                            message
                        ) {
                            var actual;

                            if (typeof block !== "function") {
                                throw new TypeError(
                                    '"block" argument must be a function'
                                );
                            }

                            if (typeof expected === "string") {
                                message = expected;
                                expected = null;
                            }

                            actual = _tryBlock(block);

                            message =
                                (expected && expected.name
                                    ? " (" + expected.name + ")."
                                    : ".") + (message ? " " + message : ".");

                            if (shouldThrow && !actual) {
                                fail(
                                    actual,
                                    expected,
                                    "Missing expected exception" + message
                                );
                            }

                            var userProvidedMessage =
                                typeof message === "string";
                            var isUnwantedException =
                                !shouldThrow && util.isError(actual);
                            var isUnexpectedException =
                                !shouldThrow && actual && !expected;

                            if (
                                (isUnwantedException &&
                                    userProvidedMessage &&
                                    expectedException(actual, expected)) ||
                                isUnexpectedException
                            ) {
                                fail(
                                    actual,
                                    expected,
                                    "Got unwanted exception" + message
                                );
                            }

                            if (
                                (shouldThrow &&
                                    actual &&
                                    expected &&
                                    !expectedException(actual, expected)) ||
                                (!shouldThrow && actual)
                            ) {
                                throw actual;
                            }
                        }

                        // 11. Expected to throw an error:
                        // assert.throws(block, Error_opt, message_opt);

                        assert.throws = function(
                            block,
                            /*optional*/ error,
                            /*optional*/ message
                        ) {
                            _throws(true, block, error, message);
                        };

                        // EXTENSION! This is annoying to write outside this module.
                        assert.doesNotThrow = function(
                            block,
                            /*optional*/ error,
                            /*optional*/ message
                        ) {
                            _throws(false, block, error, message);
                        };

                        assert.ifError = function(err) {
                            if (err) throw err;
                        };

                        var objectKeys =
                            Object.keys ||
                            function(obj) {
                                var keys = [];
                                for (var key in obj) {
                                    if (hasOwn.call(obj, key)) keys.push(key);
                                }
                                return keys;
                            };
                    }.call(
                        this,
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {
                    "util/":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/util.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/base-x/index.js": [
                function(require, module, exports) {
                    // base-x encoding
                    // Forked from https://github.com/cryptocoinjs/bs58
                    // Originally written by Mike Hearn for BitcoinJ
                    // Copyright (c) 2011 Google Inc
                    // Ported to JavaScript by Stefan Thomas
                    // Merged Buffer refactorings from base58-native by Stephen Pair
                    // Copyright (c) 2013 BitPay Inc

                    var Buffer = require("safe-buffer").Buffer;

                    module.exports = function base(ALPHABET) {
                        var ALPHABET_MAP = {};
                        var BASE = ALPHABET.length;
                        var LEADER = ALPHABET.charAt(0);

                        // pre-compute lookup table
                        for (var z = 0; z < ALPHABET.length; z++) {
                            var x = ALPHABET.charAt(z);

                            if (ALPHABET_MAP[x] !== undefined)
                                throw new TypeError(x + " is ambiguous");
                            ALPHABET_MAP[x] = z;
                        }

                        function encode(source) {
                            if (source.length === 0) return "";

                            var digits = [0];
                            for (var i = 0; i < source.length; ++i) {
                                for (
                                    var j = 0, carry = source[i];
                                    j < digits.length;
                                    ++j
                                ) {
                                    carry += digits[j] << 8;
                                    digits[j] = carry % BASE;
                                    carry = (carry / BASE) | 0;
                                }

                                while (carry > 0) {
                                    digits.push(carry % BASE);
                                    carry = (carry / BASE) | 0;
                                }
                            }

                            var string = "";

                            // deal with leading zeros
                            for (
                                var k = 0;
                                source[k] === 0 && k < source.length - 1;
                                ++k
                            )
                                string += ALPHABET[0];
                            // convert digits to a string
                            for (var q = digits.length - 1; q >= 0; --q)
                                string += ALPHABET[digits[q]];

                            return string;
                        }

                        function decodeUnsafe(string) {
                            if (string.length === 0)
                                return Buffer.allocUnsafe(0);

                            var bytes = [0];
                            for (var i = 0; i < string.length; i++) {
                                var value = ALPHABET_MAP[string[i]];
                                if (value === undefined) return;

                                for (
                                    var j = 0, carry = value;
                                    j < bytes.length;
                                    ++j
                                ) {
                                    carry += bytes[j] * BASE;
                                    bytes[j] = carry & 0xff;
                                    carry >>= 8;
                                }

                                while (carry > 0) {
                                    bytes.push(carry & 0xff);
                                    carry >>= 8;
                                }
                            }

                            // deal with leading zeros
                            for (
                                var k = 0;
                                string[k] === LEADER && k < string.length - 1;
                                ++k
                            ) {
                                bytes.push(0);
                            }

                            return Buffer.from(bytes.reverse());
                        }

                        function decode(string) {
                            var buffer = decodeUnsafe(string);
                            if (buffer) return buffer;

                            throw new Error("Non-base" + BASE + " character");
                        }

                        return {
                            encode: encode,
                            decodeUnsafe: decodeUnsafe,
                            decode: decode
                        };
                    };
                },
                {
                    "safe-buffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/base64-js/index.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.byteLength = byteLength;
                    exports.toByteArray = toByteArray;
                    exports.fromByteArray = fromByteArray;

                    var lookup = [];
                    var revLookup = [];
                    var Arr =
                        typeof Uint8Array !== "undefined" ? Uint8Array : Array;

                    var code =
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    for (var i = 0, len = code.length; i < len; ++i) {
                        lookup[i] = code[i];
                        revLookup[code.charCodeAt(i)] = i;
                    }

                    revLookup["-".charCodeAt(0)] = 62;
                    revLookup["_".charCodeAt(0)] = 63;

                    function placeHoldersCount(b64) {
                        var len = b64.length;
                        if (len % 4 > 0) {
                            throw new Error(
                                "Invalid string. Length must be a multiple of 4"
                            );
                        }

                        // the number of equal signs (place holders)
                        // if there are two placeholders, than the two characters before it
                        // represent one byte
                        // if there is only one, then the three characters before it represent 2 bytes
                        // this is just a cheap hack to not do indexOf twice
                        return b64[len - 2] === "="
                            ? 2
                            : b64[len - 1] === "="
                                ? 1
                                : 0;
                    }

                    function byteLength(b64) {
                        // base64 is 4/3 + up to two characters of the original data
                        return b64.length * 3 / 4 - placeHoldersCount(b64);
                    }

                    function toByteArray(b64) {
                        var i, j, l, tmp, placeHolders, arr;
                        var len = b64.length;
                        placeHolders = placeHoldersCount(b64);

                        arr = new Arr(len * 3 / 4 - placeHolders);

                        // if there are placeholders, only get up to the last complete 4 chars
                        l = placeHolders > 0 ? len - 4 : len;

                        var L = 0;

                        for (i = 0, j = 0; i < l; i += 4, j += 3) {
                            tmp =
                                (revLookup[b64.charCodeAt(i)] << 18) |
                                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                                revLookup[b64.charCodeAt(i + 3)];
                            arr[L++] = (tmp >> 16) & 0xff;
                            arr[L++] = (tmp >> 8) & 0xff;
                            arr[L++] = tmp & 0xff;
                        }

                        if (placeHolders === 2) {
                            tmp =
                                (revLookup[b64.charCodeAt(i)] << 2) |
                                (revLookup[b64.charCodeAt(i + 1)] >> 4);
                            arr[L++] = tmp & 0xff;
                        } else if (placeHolders === 1) {
                            tmp =
                                (revLookup[b64.charCodeAt(i)] << 10) |
                                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                                (revLookup[b64.charCodeAt(i + 2)] >> 2);
                            arr[L++] = (tmp >> 8) & 0xff;
                            arr[L++] = tmp & 0xff;
                        }

                        return arr;
                    }

                    function tripletToBase64(num) {
                        return (
                            lookup[(num >> 18) & 0x3f] +
                            lookup[(num >> 12) & 0x3f] +
                            lookup[(num >> 6) & 0x3f] +
                            lookup[num & 0x3f]
                        );
                    }

                    function encodeChunk(uint8, start, end) {
                        var tmp;
                        var output = [];
                        for (var i = start; i < end; i += 3) {
                            tmp =
                                (uint8[i] << 16) +
                                (uint8[i + 1] << 8) +
                                uint8[i + 2];
                            output.push(tripletToBase64(tmp));
                        }
                        return output.join("");
                    }

                    function fromByteArray(uint8) {
                        var tmp;
                        var len = uint8.length;
                        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
                        var output = "";
                        var parts = [];
                        var maxChunkLength = 16383; // must be multiple of 3

                        // go through the array every three bytes, we'll deal with trailing stuff later
                        for (
                            var i = 0, len2 = len - extraBytes;
                            i < len2;
                            i += maxChunkLength
                        ) {
                            parts.push(
                                encodeChunk(
                                    uint8,
                                    i,
                                    i + maxChunkLength > len2
                                        ? len2
                                        : i + maxChunkLength
                                )
                            );
                        }

                        // pad the end with zeros, but make sure to not forget the extra bytes
                        if (extraBytes === 1) {
                            tmp = uint8[len - 1];
                            output += lookup[tmp >> 2];
                            output += lookup[(tmp << 4) & 0x3f];
                            output += "==";
                        } else if (extraBytes === 2) {
                            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                            output += lookup[tmp >> 10];
                            output += lookup[(tmp >> 4) & 0x3f];
                            output += lookup[(tmp << 2) & 0x3f];
                            output += "=";
                        }

                        parts.push(output);

                        return parts.join("");
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/bigi.js": [
                function(require, module, exports) {
                    // (public) Constructor
                    function BigInteger(a, b, c) {
                        if (!(this instanceof BigInteger))
                            return new BigInteger(a, b, c);

                        if (a != null) {
                            if ("number" == typeof a) this.fromNumber(a, b, c);
                            else if (b == null && "string" != typeof a)
                                this.fromString(a, 256);
                            else this.fromString(a, b);
                        }
                    }

                    var proto = BigInteger.prototype;

                    // duck-typed isBigInteger
                    proto.__bigi = require("../package.json").version;
                    BigInteger.isBigInteger = function(obj, check_ver) {
                        return (
                            obj &&
                            obj.__bigi &&
                            (!check_ver || obj.__bigi === proto.__bigi)
                        );
                    };

                    // Bits per digit
                    var dbits;

                    // am: Compute w_j += (x*this_i), propagate carries,
                    // c is initial carry, returns final carry.
                    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
                    // We need to select the fastest one that works in this environment.

                    // am1: use a single mult and divide to get the high bits,
                    // max digit bits should be 26 because
                    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
                    function am1(i, x, w, j, c, n) {
                        while (--n >= 0) {
                            var v = x * this[i++] + w[j] + c;
                            c = Math.floor(v / 0x4000000);
                            w[j++] = v & 0x3ffffff;
                        }
                        return c;
                    }
                    // am2 avoids a big mult-and-extract completely.
                    // Max digit bits should be <= 30 because we do bitwise ops
                    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
                    function am2(i, x, w, j, c, n) {
                        var xl = x & 0x7fff,
                            xh = x >> 15;
                        while (--n >= 0) {
                            var l = this[i] & 0x7fff;
                            var h = this[i++] >> 15;
                            var m = xh * l + h * xl;
                            l =
                                xl * l +
                                ((m & 0x7fff) << 15) +
                                w[j] +
                                (c & 0x3fffffff);
                            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
                            w[j++] = l & 0x3fffffff;
                        }
                        return c;
                    }
                    // Alternately, set max digit bits to 28 since some
                    // browsers slow down when dealing with 32-bit numbers.
                    function am3(i, x, w, j, c, n) {
                        var xl = x & 0x3fff,
                            xh = x >> 14;
                        while (--n >= 0) {
                            var l = this[i] & 0x3fff;
                            var h = this[i++] >> 14;
                            var m = xh * l + h * xl;
                            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
                            c = (l >> 28) + (m >> 14) + xh * h;
                            w[j++] = l & 0xfffffff;
                        }
                        return c;
                    }

                    // wtf?
                    BigInteger.prototype.am = am1;
                    dbits = 26;

                    BigInteger.prototype.DB = dbits;
                    BigInteger.prototype.DM = (1 << dbits) - 1;
                    var DV = (BigInteger.prototype.DV = 1 << dbits);

                    var BI_FP = 52;
                    BigInteger.prototype.FV = Math.pow(2, BI_FP);
                    BigInteger.prototype.F1 = BI_FP - dbits;
                    BigInteger.prototype.F2 = 2 * dbits - BI_FP;

                    // Digit conversions
                    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
                    var BI_RC = new Array();
                    var rr, vv;
                    rr = "0".charCodeAt(0);
                    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
                    rr = "a".charCodeAt(0);
                    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
                    rr = "A".charCodeAt(0);
                    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

                    function int2char(n) {
                        return BI_RM.charAt(n);
                    }

                    function intAt(s, i) {
                        var c = BI_RC[s.charCodeAt(i)];
                        return c == null ? -1 : c;
                    }

                    // (protected) copy this to r
                    function bnpCopyTo(r) {
                        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
                        r.t = this.t;
                        r.s = this.s;
                    }

                    // (protected) set from integer value x, -DV <= x < DV
                    function bnpFromInt(x) {
                        this.t = 1;
                        this.s = x < 0 ? -1 : 0;
                        if (x > 0) this[0] = x;
                        else if (x < -1) this[0] = x + DV;
                        else this.t = 0;
                    }

                    // return bigint initialized to value
                    function nbv(i) {
                        var r = new BigInteger();
                        r.fromInt(i);
                        return r;
                    }

                    // (protected) set from string and radix
                    function bnpFromString(s, b) {
                        var self = this;

                        var k;
                        if (b == 16) k = 4;
                        else if (b == 8) k = 3;
                        else if (b == 256) k = 8;
                        // byte array
                        else if (b == 2) k = 1;
                        else if (b == 32) k = 5;
                        else if (b == 4) k = 2;
                        else {
                            self.fromRadix(s, b);
                            return;
                        }
                        self.t = 0;
                        self.s = 0;
                        var i = s.length,
                            mi = false,
                            sh = 0;
                        while (--i >= 0) {
                            var x = k == 8 ? s[i] & 0xff : intAt(s, i);
                            if (x < 0) {
                                if (s.charAt(i) == "-") mi = true;
                                continue;
                            }
                            mi = false;
                            if (sh == 0) self[self.t++] = x;
                            else if (sh + k > self.DB) {
                                self[self.t - 1] |=
                                    (x & ((1 << (self.DB - sh)) - 1)) << sh;
                                self[self.t++] = x >> (self.DB - sh);
                            } else self[self.t - 1] |= x << sh;
                            sh += k;
                            if (sh >= self.DB) sh -= self.DB;
                        }
                        if (k == 8 && (s[0] & 0x80) != 0) {
                            self.s = -1;
                            if (sh > 0)
                                self[self.t - 1] |=
                                    ((1 << (self.DB - sh)) - 1) << sh;
                        }
                        self.clamp();
                        if (mi) BigInteger.ZERO.subTo(self, self);
                    }

                    // (protected) clamp off excess high words
                    function bnpClamp() {
                        var c = this.s & this.DM;
                        while (this.t > 0 && this[this.t - 1] == c) --this.t;
                    }

                    // (public) return string representation in given radix
                    function bnToString(b) {
                        var self = this;
                        if (self.s < 0) return "-" + self.negate().toString(b);
                        var k;
                        if (b == 16) k = 4;
                        else if (b == 8) k = 3;
                        else if (b == 2) k = 1;
                        else if (b == 32) k = 5;
                        else if (b == 4) k = 2;
                        else return self.toRadix(b);
                        var km = (1 << k) - 1,
                            d,
                            m = false,
                            r = "",
                            i = self.t;
                        var p = self.DB - (i * self.DB) % k;
                        if (i-- > 0) {
                            if (p < self.DB && (d = self[i] >> p) > 0) {
                                m = true;
                                r = int2char(d);
                            }
                            while (i >= 0) {
                                if (p < k) {
                                    d = (self[i] & ((1 << p) - 1)) << (k - p);
                                    d |= self[--i] >> (p += self.DB - k);
                                } else {
                                    d = (self[i] >> (p -= k)) & km;
                                    if (p <= 0) {
                                        p += self.DB;
                                        --i;
                                    }
                                }
                                if (d > 0) m = true;
                                if (m) r += int2char(d);
                            }
                        }
                        return m ? r : "0";
                    }

                    // (public) -this
                    function bnNegate() {
                        var r = new BigInteger();
                        BigInteger.ZERO.subTo(this, r);
                        return r;
                    }

                    // (public) |this|
                    function bnAbs() {
                        return this.s < 0 ? this.negate() : this;
                    }

                    // (public) return + if this > a, - if this < a, 0 if equal
                    function bnCompareTo(a) {
                        var r = this.s - a.s;
                        if (r != 0) return r;
                        var i = this.t;
                        r = i - a.t;
                        if (r != 0) return this.s < 0 ? -r : r;
                        while (--i >= 0)
                            if ((r = this[i] - a[i]) != 0) return r;
                        return 0;
                    }

                    // returns bit length of the integer x
                    function nbits(x) {
                        var r = 1,
                            t;
                        if ((t = x >>> 16) != 0) {
                            x = t;
                            r += 16;
                        }
                        if ((t = x >> 8) != 0) {
                            x = t;
                            r += 8;
                        }
                        if ((t = x >> 4) != 0) {
                            x = t;
                            r += 4;
                        }
                        if ((t = x >> 2) != 0) {
                            x = t;
                            r += 2;
                        }
                        if ((t = x >> 1) != 0) {
                            x = t;
                            r += 1;
                        }
                        return r;
                    }

                    // (public) return the number of bits in "this"
                    function bnBitLength() {
                        if (this.t <= 0) return 0;
                        return (
                            this.DB * (this.t - 1) +
                            nbits(this[this.t - 1] ^ (this.s & this.DM))
                        );
                    }

                    // (public) return the number of bytes in "this"
                    function bnByteLength() {
                        return this.bitLength() >> 3;
                    }

                    // (protected) r = this << n*DB
                    function bnpDLShiftTo(n, r) {
                        var i;
                        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
                        for (i = n - 1; i >= 0; --i) r[i] = 0;
                        r.t = this.t + n;
                        r.s = this.s;
                    }

                    // (protected) r = this >> n*DB
                    function bnpDRShiftTo(n, r) {
                        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
                        r.t = Math.max(this.t - n, 0);
                        r.s = this.s;
                    }

                    // (protected) r = this << n
                    function bnpLShiftTo(n, r) {
                        var self = this;
                        var bs = n % self.DB;
                        var cbs = self.DB - bs;
                        var bm = (1 << cbs) - 1;
                        var ds = Math.floor(n / self.DB),
                            c = (self.s << bs) & self.DM,
                            i;
                        for (i = self.t - 1; i >= 0; --i) {
                            r[i + ds + 1] = (self[i] >> cbs) | c;
                            c = (self[i] & bm) << bs;
                        }
                        for (i = ds - 1; i >= 0; --i) r[i] = 0;
                        r[ds] = c;
                        r.t = self.t + ds + 1;
                        r.s = self.s;
                        r.clamp();
                    }

                    // (protected) r = this >> n
                    function bnpRShiftTo(n, r) {
                        var self = this;
                        r.s = self.s;
                        var ds = Math.floor(n / self.DB);
                        if (ds >= self.t) {
                            r.t = 0;
                            return;
                        }
                        var bs = n % self.DB;
                        var cbs = self.DB - bs;
                        var bm = (1 << bs) - 1;
                        r[0] = self[ds] >> bs;
                        for (var i = ds + 1; i < self.t; ++i) {
                            r[i - ds - 1] |= (self[i] & bm) << cbs;
                            r[i - ds] = self[i] >> bs;
                        }
                        if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs;
                        r.t = self.t - ds;
                        r.clamp();
                    }

                    // (protected) r = this - a
                    function bnpSubTo(a, r) {
                        var self = this;
                        var i = 0,
                            c = 0,
                            m = Math.min(a.t, self.t);
                        while (i < m) {
                            c += self[i] - a[i];
                            r[i++] = c & self.DM;
                            c >>= self.DB;
                        }
                        if (a.t < self.t) {
                            c -= a.s;
                            while (i < self.t) {
                                c += self[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB;
                            }
                            c += self.s;
                        } else {
                            c += self.s;
                            while (i < a.t) {
                                c -= a[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB;
                            }
                            c -= a.s;
                        }
                        r.s = c < 0 ? -1 : 0;
                        if (c < -1) r[i++] = self.DV + c;
                        else if (c > 0) r[i++] = c;
                        r.t = i;
                        r.clamp();
                    }

                    // (protected) r = this * a, r != this,a (HAC 14.12)
                    // "this" should be the larger one if appropriate.
                    function bnpMultiplyTo(a, r) {
                        var x = this.abs(),
                            y = a.abs();
                        var i = x.t;
                        r.t = i + y.t;
                        while (--i >= 0) r[i] = 0;
                        for (i = 0; i < y.t; ++i)
                            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
                        r.s = 0;
                        r.clamp();
                        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
                    }

                    // (protected) r = this^2, r != this (HAC 14.16)
                    function bnpSquareTo(r) {
                        var x = this.abs();
                        var i = (r.t = 2 * x.t);
                        while (--i >= 0) r[i] = 0;
                        for (i = 0; i < x.t - 1; ++i) {
                            var c = x.am(i, x[i], r, 2 * i, 0, 1);
                            if (
                                (r[i + x.t] += x.am(
                                    i + 1,
                                    2 * x[i],
                                    r,
                                    2 * i + 1,
                                    c,
                                    x.t - i - 1
                                )) >= x.DV
                            ) {
                                r[i + x.t] -= x.DV;
                                r[i + x.t + 1] = 1;
                            }
                        }
                        if (r.t > 0)
                            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
                        r.s = 0;
                        r.clamp();
                    }

                    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
                    // r != q, this != m.  q or r may be null.
                    function bnpDivRemTo(m, q, r) {
                        var self = this;
                        var pm = m.abs();
                        if (pm.t <= 0) return;
                        var pt = self.abs();
                        if (pt.t < pm.t) {
                            if (q != null) q.fromInt(0);
                            if (r != null) self.copyTo(r);
                            return;
                        }
                        if (r == null) r = new BigInteger();
                        var y = new BigInteger(),
                            ts = self.s,
                            ms = m.s;
                        var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
                        if (nsh > 0) {
                            pm.lShiftTo(nsh, y);
                            pt.lShiftTo(nsh, r);
                        } else {
                            pm.copyTo(y);
                            pt.copyTo(r);
                        }
                        var ys = y.t;
                        var y0 = y[ys - 1];
                        if (y0 == 0) return;
                        var yt =
                            y0 * (1 << self.F1) +
                            (ys > 1 ? y[ys - 2] >> self.F2 : 0);
                        var d1 = self.FV / yt,
                            d2 = (1 << self.F1) / yt,
                            e = 1 << self.F2;
                        var i = r.t,
                            j = i - ys,
                            t = q == null ? new BigInteger() : q;
                        y.dlShiftTo(j, t);
                        if (r.compareTo(t) >= 0) {
                            r[r.t++] = 1;
                            r.subTo(t, r);
                        }
                        BigInteger.ONE.dlShiftTo(ys, t);
                        t.subTo(y, y); // "negative" y so we can replace sub with am later
                        while (y.t < ys) y[y.t++] = 0;
                        while (--j >= 0) {
                            // Estimate quotient digit
                            var qd =
                                r[--i] == y0
                                    ? self.DM
                                    : Math.floor(
                                          r[i] * d1 + (r[i - 1] + e) * d2
                                      );
                            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                                // Try it out
                                y.dlShiftTo(j, t);
                                r.subTo(t, r);
                                while (r[i] < --qd) r.subTo(t, r);
                            }
                        }
                        if (q != null) {
                            r.drShiftTo(ys, q);
                            if (ts != ms) BigInteger.ZERO.subTo(q, q);
                        }
                        r.t = ys;
                        r.clamp();
                        if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
                        if (ts < 0) BigInteger.ZERO.subTo(r, r);
                    }

                    // (public) this mod a
                    function bnMod(a) {
                        var r = new BigInteger();
                        this.abs().divRemTo(a, null, r);
                        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
                            a.subTo(r, r);
                        return r;
                    }

                    // Modular reduction using "classic" algorithm
                    function Classic(m) {
                        this.m = m;
                    }

                    function cConvert(x) {
                        if (x.s < 0 || x.compareTo(this.m) >= 0)
                            return x.mod(this.m);
                        else return x;
                    }

                    function cRevert(x) {
                        return x;
                    }

                    function cReduce(x) {
                        x.divRemTo(this.m, null, x);
                    }

                    function cMulTo(x, y, r) {
                        x.multiplyTo(y, r);
                        this.reduce(r);
                    }

                    function cSqrTo(x, r) {
                        x.squareTo(r);
                        this.reduce(r);
                    }

                    Classic.prototype.convert = cConvert;
                    Classic.prototype.revert = cRevert;
                    Classic.prototype.reduce = cReduce;
                    Classic.prototype.mulTo = cMulTo;
                    Classic.prototype.sqrTo = cSqrTo;

                    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
                    // justification:
                    //         xy == 1 (mod m)
                    //         xy =  1+km
                    //   xy(2-xy) = (1+km)(1-km)
                    // x[y(2-xy)] = 1-k^2m^2
                    // x[y(2-xy)] == 1 (mod m^2)
                    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
                    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
                    // JS multiply "overflows" differently from C/C++, so care is needed here.
                    function bnpInvDigit() {
                        if (this.t < 1) return 0;
                        var x = this[0];
                        if ((x & 1) == 0) return 0;
                        var y = x & 3; // y == 1/x mod 2^2
                        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
                        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
                        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
                        // last step - calculate inverse mod DV directly
                        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
                        y = (y * (2 - (x * y) % this.DV)) % this.DV; // y == 1/x mod 2^dbits
                        // we really want the negative inverse, and -DV < y < DV
                        return y > 0 ? this.DV - y : -y;
                    }

                    // Montgomery reduction
                    function Montgomery(m) {
                        this.m = m;
                        this.mp = m.invDigit();
                        this.mpl = this.mp & 0x7fff;
                        this.mph = this.mp >> 15;
                        this.um = (1 << (m.DB - 15)) - 1;
                        this.mt2 = 2 * m.t;
                    }

                    // xR mod m
                    function montConvert(x) {
                        var r = new BigInteger();
                        x.abs().dlShiftTo(this.m.t, r);
                        r.divRemTo(this.m, null, r);
                        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
                            this.m.subTo(r, r);
                        return r;
                    }

                    // x/R mod m
                    function montRevert(x) {
                        var r = new BigInteger();
                        x.copyTo(r);
                        this.reduce(r);
                        return r;
                    }

                    // x = x/R mod m (HAC 14.32)
                    function montReduce(x) {
                        while (
                            x.t <= this.mt2 // pad x so am has enough room later
                        )
                            x[x.t++] = 0;
                        for (var i = 0; i < this.m.t; ++i) {
                            // faster way of calculating u0 = x[i]*mp mod DV
                            var j = x[i] & 0x7fff;
                            var u0 =
                                (j * this.mpl +
                                    (((j * this.mph + (x[i] >> 15) * this.mpl) &
                                        this.um) <<
                                        15)) &
                                x.DM;
                            // use am to combine the multiply-shift-add into one call
                            j = i + this.m.t;
                            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                            // propagate carry
                            while (x[j] >= x.DV) {
                                x[j] -= x.DV;
                                x[++j]++;
                            }
                        }
                        x.clamp();
                        x.drShiftTo(this.m.t, x);
                        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
                    }

                    // r = "x^2/R mod m"; x != r
                    function montSqrTo(x, r) {
                        x.squareTo(r);
                        this.reduce(r);
                    }

                    // r = "xy/R mod m"; x,y != r
                    function montMulTo(x, y, r) {
                        x.multiplyTo(y, r);
                        this.reduce(r);
                    }

                    Montgomery.prototype.convert = montConvert;
                    Montgomery.prototype.revert = montRevert;
                    Montgomery.prototype.reduce = montReduce;
                    Montgomery.prototype.mulTo = montMulTo;
                    Montgomery.prototype.sqrTo = montSqrTo;

                    // (protected) true iff this is even
                    function bnpIsEven() {
                        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
                    }

                    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
                    function bnpExp(e, z) {
                        if (e > 0xffffffff || e < 1) return BigInteger.ONE;
                        var r = new BigInteger(),
                            r2 = new BigInteger(),
                            g = z.convert(this),
                            i = nbits(e) - 1;
                        g.copyTo(r);
                        while (--i >= 0) {
                            z.sqrTo(r, r2);
                            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
                            else {
                                var t = r;
                                r = r2;
                                r2 = t;
                            }
                        }
                        return z.revert(r);
                    }

                    // (public) this^e % m, 0 <= e < 2^32
                    function bnModPowInt(e, m) {
                        var z;
                        if (e < 256 || m.isEven()) z = new Classic(m);
                        else z = new Montgomery(m);
                        return this.exp(e, z);
                    }

                    // protected
                    proto.copyTo = bnpCopyTo;
                    proto.fromInt = bnpFromInt;
                    proto.fromString = bnpFromString;
                    proto.clamp = bnpClamp;
                    proto.dlShiftTo = bnpDLShiftTo;
                    proto.drShiftTo = bnpDRShiftTo;
                    proto.lShiftTo = bnpLShiftTo;
                    proto.rShiftTo = bnpRShiftTo;
                    proto.subTo = bnpSubTo;
                    proto.multiplyTo = bnpMultiplyTo;
                    proto.squareTo = bnpSquareTo;
                    proto.divRemTo = bnpDivRemTo;
                    proto.invDigit = bnpInvDigit;
                    proto.isEven = bnpIsEven;
                    proto.exp = bnpExp;

                    // public
                    proto.toString = bnToString;
                    proto.negate = bnNegate;
                    proto.abs = bnAbs;
                    proto.compareTo = bnCompareTo;
                    proto.bitLength = bnBitLength;
                    proto.byteLength = bnByteLength;
                    proto.mod = bnMod;
                    proto.modPowInt = bnModPowInt;

                    // (public)
                    function bnClone() {
                        var r = new BigInteger();
                        this.copyTo(r);
                        return r;
                    }

                    // (public) return value as integer
                    function bnIntValue() {
                        if (this.s < 0) {
                            if (this.t == 1) return this[0] - this.DV;
                            else if (this.t == 0) return -1;
                        } else if (this.t == 1) return this[0];
                        else if (this.t == 0) return 0;
                        // assumes 16 < DB < 32
                        return (
                            ((this[1] & ((1 << (32 - this.DB)) - 1)) <<
                                this.DB) |
                            this[0]
                        );
                    }

                    // (public) return value as byte
                    function bnByteValue() {
                        return this.t == 0 ? this.s : (this[0] << 24) >> 24;
                    }

                    // (public) return value as short (assumes DB>=16)
                    function bnShortValue() {
                        return this.t == 0 ? this.s : (this[0] << 16) >> 16;
                    }

                    // (protected) return x s.t. r^x < DV
                    function bnpChunkSize(r) {
                        return Math.floor(Math.LN2 * this.DB / Math.log(r));
                    }

                    // (public) 0 if this == 0, 1 if this > 0
                    function bnSigNum() {
                        if (this.s < 0) return -1;
                        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0))
                            return 0;
                        else return 1;
                    }

                    // (protected) convert to radix string
                    function bnpToRadix(b) {
                        if (b == null) b = 10;
                        if (this.signum() == 0 || b < 2 || b > 36) return "0";
                        var cs = this.chunkSize(b);
                        var a = Math.pow(b, cs);
                        var d = nbv(a),
                            y = new BigInteger(),
                            z = new BigInteger(),
                            r = "";
                        this.divRemTo(d, y, z);
                        while (y.signum() > 0) {
                            r = (a + z.intValue()).toString(b).substr(1) + r;
                            y.divRemTo(d, y, z);
                        }
                        return z.intValue().toString(b) + r;
                    }

                    // (protected) convert from radix string
                    function bnpFromRadix(s, b) {
                        var self = this;
                        self.fromInt(0);
                        if (b == null) b = 10;
                        var cs = self.chunkSize(b);
                        var d = Math.pow(b, cs),
                            mi = false,
                            j = 0,
                            w = 0;
                        for (var i = 0; i < s.length; ++i) {
                            var x = intAt(s, i);
                            if (x < 0) {
                                if (s.charAt(i) == "-" && self.signum() == 0)
                                    mi = true;
                                continue;
                            }
                            w = b * w + x;
                            if (++j >= cs) {
                                self.dMultiply(d);
                                self.dAddOffset(w, 0);
                                j = 0;
                                w = 0;
                            }
                        }
                        if (j > 0) {
                            self.dMultiply(Math.pow(b, j));
                            self.dAddOffset(w, 0);
                        }
                        if (mi) BigInteger.ZERO.subTo(self, self);
                    }

                    // (protected) alternate constructor
                    function bnpFromNumber(a, b, c) {
                        var self = this;
                        if ("number" == typeof b) {
                            // new BigInteger(int,int,RNG)
                            if (a < 2) self.fromInt(1);
                            else {
                                self.fromNumber(a, c);
                                if (!self.testBit(a - 1))
                                    // force MSB set
                                    self.bitwiseTo(
                                        BigInteger.ONE.shiftLeft(a - 1),
                                        op_or,
                                        self
                                    );
                                if (self.isEven()) self.dAddOffset(1, 0); // force odd
                                while (!self.isProbablePrime(b)) {
                                    self.dAddOffset(2, 0);
                                    if (self.bitLength() > a)
                                        self.subTo(
                                            BigInteger.ONE.shiftLeft(a - 1),
                                            self
                                        );
                                }
                            }
                        } else {
                            // new BigInteger(int,RNG)
                            var x = new Array(),
                                t = a & 7;
                            x.length = (a >> 3) + 1;
                            b.nextBytes(x);
                            if (t > 0) x[0] &= (1 << t) - 1;
                            else x[0] = 0;
                            self.fromString(x, 256);
                        }
                    }

                    // (public) convert to bigendian byte array
                    function bnToByteArray() {
                        var self = this;
                        var i = self.t,
                            r = new Array();
                        r[0] = self.s;
                        var p = self.DB - (i * self.DB) % 8,
                            d,
                            k = 0;
                        if (i-- > 0) {
                            if (
                                p < self.DB &&
                                (d = self[i] >> p) != (self.s & self.DM) >> p
                            )
                                r[k++] = d | (self.s << (self.DB - p));
                            while (i >= 0) {
                                if (p < 8) {
                                    d = (self[i] & ((1 << p) - 1)) << (8 - p);
                                    d |= self[--i] >> (p += self.DB - 8);
                                } else {
                                    d = (self[i] >> (p -= 8)) & 0xff;
                                    if (p <= 0) {
                                        p += self.DB;
                                        --i;
                                    }
                                }
                                if ((d & 0x80) != 0) d |= -256;
                                if (k === 0 && (self.s & 0x80) != (d & 0x80))
                                    ++k;
                                if (k > 0 || d != self.s) r[k++] = d;
                            }
                        }
                        return r;
                    }

                    function bnEquals(a) {
                        return this.compareTo(a) == 0;
                    }

                    function bnMin(a) {
                        return this.compareTo(a) < 0 ? this : a;
                    }

                    function bnMax(a) {
                        return this.compareTo(a) > 0 ? this : a;
                    }

                    // (protected) r = this op a (bitwise)
                    function bnpBitwiseTo(a, op, r) {
                        var self = this;
                        var i,
                            f,
                            m = Math.min(a.t, self.t);
                        for (i = 0; i < m; ++i) r[i] = op(self[i], a[i]);
                        if (a.t < self.t) {
                            f = a.s & self.DM;
                            for (i = m; i < self.t; ++i) r[i] = op(self[i], f);
                            r.t = self.t;
                        } else {
                            f = self.s & self.DM;
                            for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
                            r.t = a.t;
                        }
                        r.s = op(self.s, a.s);
                        r.clamp();
                    }

                    // (public) this & a
                    function op_and(x, y) {
                        return x & y;
                    }

                    function bnAnd(a) {
                        var r = new BigInteger();
                        this.bitwiseTo(a, op_and, r);
                        return r;
                    }

                    // (public) this | a
                    function op_or(x, y) {
                        return x | y;
                    }

                    function bnOr(a) {
                        var r = new BigInteger();
                        this.bitwiseTo(a, op_or, r);
                        return r;
                    }

                    // (public) this ^ a
                    function op_xor(x, y) {
                        return x ^ y;
                    }

                    function bnXor(a) {
                        var r = new BigInteger();
                        this.bitwiseTo(a, op_xor, r);
                        return r;
                    }

                    // (public) this & ~a
                    function op_andnot(x, y) {
                        return x & ~y;
                    }

                    function bnAndNot(a) {
                        var r = new BigInteger();
                        this.bitwiseTo(a, op_andnot, r);
                        return r;
                    }

                    // (public) ~this
                    function bnNot() {
                        var r = new BigInteger();
                        for (var i = 0; i < this.t; ++i)
                            r[i] = this.DM & ~this[i];
                        r.t = this.t;
                        r.s = ~this.s;
                        return r;
                    }

                    // (public) this << n
                    function bnShiftLeft(n) {
                        var r = new BigInteger();
                        if (n < 0) this.rShiftTo(-n, r);
                        else this.lShiftTo(n, r);
                        return r;
                    }

                    // (public) this >> n
                    function bnShiftRight(n) {
                        var r = new BigInteger();
                        if (n < 0) this.lShiftTo(-n, r);
                        else this.rShiftTo(n, r);
                        return r;
                    }

                    // return index of lowest 1-bit in x, x < 2^31
                    function lbit(x) {
                        if (x == 0) return -1;
                        var r = 0;
                        if ((x & 0xffff) == 0) {
                            x >>= 16;
                            r += 16;
                        }
                        if ((x & 0xff) == 0) {
                            x >>= 8;
                            r += 8;
                        }
                        if ((x & 0xf) == 0) {
                            x >>= 4;
                            r += 4;
                        }
                        if ((x & 3) == 0) {
                            x >>= 2;
                            r += 2;
                        }
                        if ((x & 1) == 0) ++r;
                        return r;
                    }

                    // (public) returns index of lowest 1-bit (or -1 if none)
                    function bnGetLowestSetBit() {
                        for (var i = 0; i < this.t; ++i)
                            if (this[i] != 0)
                                return i * this.DB + lbit(this[i]);
                        if (this.s < 0) return this.t * this.DB;
                        return -1;
                    }

                    // return number of 1 bits in x
                    function cbit(x) {
                        var r = 0;
                        while (x != 0) {
                            x &= x - 1;
                            ++r;
                        }
                        return r;
                    }

                    // (public) return number of set bits
                    function bnBitCount() {
                        var r = 0,
                            x = this.s & this.DM;
                        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
                        return r;
                    }

                    // (public) true iff nth bit is set
                    function bnTestBit(n) {
                        var j = Math.floor(n / this.DB);
                        if (j >= this.t) return this.s != 0;
                        return (this[j] & (1 << (n % this.DB))) != 0;
                    }

                    // (protected) this op (1<<n)
                    function bnpChangeBit(n, op) {
                        var r = BigInteger.ONE.shiftLeft(n);
                        this.bitwiseTo(r, op, r);
                        return r;
                    }

                    // (public) this | (1<<n)
                    function bnSetBit(n) {
                        return this.changeBit(n, op_or);
                    }

                    // (public) this & ~(1<<n)
                    function bnClearBit(n) {
                        return this.changeBit(n, op_andnot);
                    }

                    // (public) this ^ (1<<n)
                    function bnFlipBit(n) {
                        return this.changeBit(n, op_xor);
                    }

                    // (protected) r = this + a
                    function bnpAddTo(a, r) {
                        var self = this;

                        var i = 0,
                            c = 0,
                            m = Math.min(a.t, self.t);
                        while (i < m) {
                            c += self[i] + a[i];
                            r[i++] = c & self.DM;
                            c >>= self.DB;
                        }
                        if (a.t < self.t) {
                            c += a.s;
                            while (i < self.t) {
                                c += self[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB;
                            }
                            c += self.s;
                        } else {
                            c += self.s;
                            while (i < a.t) {
                                c += a[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB;
                            }
                            c += a.s;
                        }
                        r.s = c < 0 ? -1 : 0;
                        if (c > 0) r[i++] = c;
                        else if (c < -1) r[i++] = self.DV + c;
                        r.t = i;
                        r.clamp();
                    }

                    // (public) this + a
                    function bnAdd(a) {
                        var r = new BigInteger();
                        this.addTo(a, r);
                        return r;
                    }

                    // (public) this - a
                    function bnSubtract(a) {
                        var r = new BigInteger();
                        this.subTo(a, r);
                        return r;
                    }

                    // (public) this * a
                    function bnMultiply(a) {
                        var r = new BigInteger();
                        this.multiplyTo(a, r);
                        return r;
                    }

                    // (public) this^2
                    function bnSquare() {
                        var r = new BigInteger();
                        this.squareTo(r);
                        return r;
                    }

                    // (public) this / a
                    function bnDivide(a) {
                        var r = new BigInteger();
                        this.divRemTo(a, r, null);
                        return r;
                    }

                    // (public) this % a
                    function bnRemainder(a) {
                        var r = new BigInteger();
                        this.divRemTo(a, null, r);
                        return r;
                    }

                    // (public) [this/a,this%a]
                    function bnDivideAndRemainder(a) {
                        var q = new BigInteger(),
                            r = new BigInteger();
                        this.divRemTo(a, q, r);
                        return new Array(q, r);
                    }

                    // (protected) this *= n, this >= 0, 1 < n < DV
                    function bnpDMultiply(n) {
                        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
                        ++this.t;
                        this.clamp();
                    }

                    // (protected) this += n << w words, this >= 0
                    function bnpDAddOffset(n, w) {
                        if (n == 0) return;
                        while (this.t <= w) this[this.t++] = 0;
                        this[w] += n;
                        while (this[w] >= this.DV) {
                            this[w] -= this.DV;
                            if (++w >= this.t) this[this.t++] = 0;
                            ++this[w];
                        }
                    }

                    // A "null" reducer
                    function NullExp() {}

                    function nNop(x) {
                        return x;
                    }

                    function nMulTo(x, y, r) {
                        x.multiplyTo(y, r);
                    }

                    function nSqrTo(x, r) {
                        x.squareTo(r);
                    }

                    NullExp.prototype.convert = nNop;
                    NullExp.prototype.revert = nNop;
                    NullExp.prototype.mulTo = nMulTo;
                    NullExp.prototype.sqrTo = nSqrTo;

                    // (public) this^e
                    function bnPow(e) {
                        return this.exp(e, new NullExp());
                    }

                    // (protected) r = lower n words of "this * a", a.t <= n
                    // "this" should be the larger one if appropriate.
                    function bnpMultiplyLowerTo(a, n, r) {
                        var i = Math.min(this.t + a.t, n);
                        r.s = 0; // assumes a,this >= 0
                        r.t = i;
                        while (i > 0) r[--i] = 0;
                        var j;
                        for (j = r.t - this.t; i < j; ++i)
                            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
                        for (j = Math.min(a.t, n); i < j; ++i)
                            this.am(0, a[i], r, i, 0, n - i);
                        r.clamp();
                    }

                    // (protected) r = "this * a" without lower n words, n > 0
                    // "this" should be the larger one if appropriate.
                    function bnpMultiplyUpperTo(a, n, r) {
                        --n;
                        var i = (r.t = this.t + a.t - n);
                        r.s = 0; // assumes a,this >= 0
                        while (--i >= 0) r[i] = 0;
                        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
                            r[this.t + i - n] = this.am(
                                n - i,
                                a[i],
                                r,
                                0,
                                0,
                                this.t + i - n
                            );
                        r.clamp();
                        r.drShiftTo(1, r);
                    }

                    // Barrett modular reduction
                    function Barrett(m) {
                        // setup Barrett
                        this.r2 = new BigInteger();
                        this.q3 = new BigInteger();
                        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
                        this.mu = this.r2.divide(m);
                        this.m = m;
                    }

                    function barrettConvert(x) {
                        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
                        else if (x.compareTo(this.m) < 0) return x;
                        else {
                            var r = new BigInteger();
                            x.copyTo(r);
                            this.reduce(r);
                            return r;
                        }
                    }

                    function barrettRevert(x) {
                        return x;
                    }

                    // x = x mod m (HAC 14.42)
                    function barrettReduce(x) {
                        var self = this;
                        x.drShiftTo(self.m.t - 1, self.r2);
                        if (x.t > self.m.t + 1) {
                            x.t = self.m.t + 1;
                            x.clamp();
                        }
                        self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3);
                        self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2);
                        while (x.compareTo(self.r2) < 0)
                            x.dAddOffset(1, self.m.t + 1);
                        x.subTo(self.r2, x);
                        while (x.compareTo(self.m) >= 0) x.subTo(self.m, x);
                    }

                    // r = x^2 mod m; x != r
                    function barrettSqrTo(x, r) {
                        x.squareTo(r);
                        this.reduce(r);
                    }

                    // r = x*y mod m; x,y != r
                    function barrettMulTo(x, y, r) {
                        x.multiplyTo(y, r);
                        this.reduce(r);
                    }

                    Barrett.prototype.convert = barrettConvert;
                    Barrett.prototype.revert = barrettRevert;
                    Barrett.prototype.reduce = barrettReduce;
                    Barrett.prototype.mulTo = barrettMulTo;
                    Barrett.prototype.sqrTo = barrettSqrTo;

                    // (public) this^e % m (HAC 14.85)
                    function bnModPow(e, m) {
                        var i = e.bitLength(),
                            k,
                            r = nbv(1),
                            z;
                        if (i <= 0) return r;
                        else if (i < 18) k = 1;
                        else if (i < 48) k = 3;
                        else if (i < 144) k = 4;
                        else if (i < 768) k = 5;
                        else k = 6;
                        if (i < 8) z = new Classic(m);
                        else if (m.isEven()) z = new Barrett(m);
                        else z = new Montgomery(m);

                        // precomputation
                        var g = new Array(),
                            n = 3,
                            k1 = k - 1,
                            km = (1 << k) - 1;
                        g[1] = z.convert(this);
                        if (k > 1) {
                            var g2 = new BigInteger();
                            z.sqrTo(g[1], g2);
                            while (n <= km) {
                                g[n] = new BigInteger();
                                z.mulTo(g2, g[n - 2], g[n]);
                                n += 2;
                            }
                        }

                        var j = e.t - 1,
                            w,
                            is1 = true,
                            r2 = new BigInteger(),
                            t;
                        i = nbits(e[j]) - 1;
                        while (j >= 0) {
                            if (i >= k1) w = (e[j] >> (i - k1)) & km;
                            else {
                                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                                if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
                            }

                            n = k;
                            while ((w & 1) == 0) {
                                w >>= 1;
                                --n;
                            }
                            if ((i -= n) < 0) {
                                i += this.DB;
                                --j;
                            }
                            if (is1) {
                                // ret == 1, don't bother squaring or multiplying it
                                g[w].copyTo(r);
                                is1 = false;
                            } else {
                                while (n > 1) {
                                    z.sqrTo(r, r2);
                                    z.sqrTo(r2, r);
                                    n -= 2;
                                }
                                if (n > 0) z.sqrTo(r, r2);
                                else {
                                    t = r;
                                    r = r2;
                                    r2 = t;
                                }
                                z.mulTo(r2, g[w], r);
                            }

                            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                                z.sqrTo(r, r2);
                                t = r;
                                r = r2;
                                r2 = t;
                                if (--i < 0) {
                                    i = this.DB - 1;
                                    --j;
                                }
                            }
                        }
                        return z.revert(r);
                    }

                    // (public) gcd(this,a) (HAC 14.54)
                    function bnGCD(a) {
                        var x = this.s < 0 ? this.negate() : this.clone();
                        var y = a.s < 0 ? a.negate() : a.clone();
                        if (x.compareTo(y) < 0) {
                            var t = x;
                            x = y;
                            y = t;
                        }
                        var i = x.getLowestSetBit(),
                            g = y.getLowestSetBit();
                        if (g < 0) return x;
                        if (i < g) g = i;
                        if (g > 0) {
                            x.rShiftTo(g, x);
                            y.rShiftTo(g, y);
                        }
                        while (x.signum() > 0) {
                            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
                            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
                            if (x.compareTo(y) >= 0) {
                                x.subTo(y, x);
                                x.rShiftTo(1, x);
                            } else {
                                y.subTo(x, y);
                                y.rShiftTo(1, y);
                            }
                        }
                        if (g > 0) y.lShiftTo(g, y);
                        return y;
                    }

                    // (protected) this % n, n < 2^26
                    function bnpModInt(n) {
                        if (n <= 0) return 0;
                        var d = this.DV % n,
                            r = this.s < 0 ? n - 1 : 0;
                        if (this.t > 0)
                            if (d == 0) r = this[0] % n;
                            else
                                for (var i = this.t - 1; i >= 0; --i)
                                    r = (d * r + this[i]) % n;
                        return r;
                    }

                    // (public) 1/this % m (HAC 14.61)
                    function bnModInverse(m) {
                        var ac = m.isEven();
                        if (this.signum() === 0)
                            throw new Error("division by zero");
                        if ((this.isEven() && ac) || m.signum() == 0)
                            return BigInteger.ZERO;
                        var u = m.clone(),
                            v = this.clone();
                        var a = nbv(1),
                            b = nbv(0),
                            c = nbv(0),
                            d = nbv(1);
                        while (u.signum() != 0) {
                            while (u.isEven()) {
                                u.rShiftTo(1, u);
                                if (ac) {
                                    if (!a.isEven() || !b.isEven()) {
                                        a.addTo(this, a);
                                        b.subTo(m, b);
                                    }
                                    a.rShiftTo(1, a);
                                } else if (!b.isEven()) b.subTo(m, b);
                                b.rShiftTo(1, b);
                            }
                            while (v.isEven()) {
                                v.rShiftTo(1, v);
                                if (ac) {
                                    if (!c.isEven() || !d.isEven()) {
                                        c.addTo(this, c);
                                        d.subTo(m, d);
                                    }
                                    c.rShiftTo(1, c);
                                } else if (!d.isEven()) d.subTo(m, d);
                                d.rShiftTo(1, d);
                            }
                            if (u.compareTo(v) >= 0) {
                                u.subTo(v, u);
                                if (ac) a.subTo(c, a);
                                b.subTo(d, b);
                            } else {
                                v.subTo(u, v);
                                if (ac) c.subTo(a, c);
                                d.subTo(b, d);
                            }
                        }
                        if (v.compareTo(BigInteger.ONE) != 0)
                            return BigInteger.ZERO;
                        while (d.compareTo(m) >= 0) d.subTo(m, d);
                        while (d.signum() < 0) d.addTo(m, d);
                        return d;
                    }

                    var lowprimes = [
                        2,
                        3,
                        5,
                        7,
                        11,
                        13,
                        17,
                        19,
                        23,
                        29,
                        31,
                        37,
                        41,
                        43,
                        47,
                        53,
                        59,
                        61,
                        67,
                        71,
                        73,
                        79,
                        83,
                        89,
                        97,
                        101,
                        103,
                        107,
                        109,
                        113,
                        127,
                        131,
                        137,
                        139,
                        149,
                        151,
                        157,
                        163,
                        167,
                        173,
                        179,
                        181,
                        191,
                        193,
                        197,
                        199,
                        211,
                        223,
                        227,
                        229,
                        233,
                        239,
                        241,
                        251,
                        257,
                        263,
                        269,
                        271,
                        277,
                        281,
                        283,
                        293,
                        307,
                        311,
                        313,
                        317,
                        331,
                        337,
                        347,
                        349,
                        353,
                        359,
                        367,
                        373,
                        379,
                        383,
                        389,
                        397,
                        401,
                        409,
                        419,
                        421,
                        431,
                        433,
                        439,
                        443,
                        449,
                        457,
                        461,
                        463,
                        467,
                        479,
                        487,
                        491,
                        499,
                        503,
                        509,
                        521,
                        523,
                        541,
                        547,
                        557,
                        563,
                        569,
                        571,
                        577,
                        587,
                        593,
                        599,
                        601,
                        607,
                        613,
                        617,
                        619,
                        631,
                        641,
                        643,
                        647,
                        653,
                        659,
                        661,
                        673,
                        677,
                        683,
                        691,
                        701,
                        709,
                        719,
                        727,
                        733,
                        739,
                        743,
                        751,
                        757,
                        761,
                        769,
                        773,
                        787,
                        797,
                        809,
                        811,
                        821,
                        823,
                        827,
                        829,
                        839,
                        853,
                        857,
                        859,
                        863,
                        877,
                        881,
                        883,
                        887,
                        907,
                        911,
                        919,
                        929,
                        937,
                        941,
                        947,
                        953,
                        967,
                        971,
                        977,
                        983,
                        991,
                        997
                    ];

                    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

                    // (public) test primality with certainty >= 1-.5^t
                    function bnIsProbablePrime(t) {
                        var i,
                            x = this.abs();
                        if (
                            x.t == 1 &&
                            x[0] <= lowprimes[lowprimes.length - 1]
                        ) {
                            for (i = 0; i < lowprimes.length; ++i)
                                if (x[0] == lowprimes[i]) return true;
                            return false;
                        }
                        if (x.isEven()) return false;
                        i = 1;
                        while (i < lowprimes.length) {
                            var m = lowprimes[i],
                                j = i + 1;
                            while (j < lowprimes.length && m < lplim)
                                m *= lowprimes[j++];
                            m = x.modInt(m);
                            while (i < j)
                                if (m % lowprimes[i++] == 0) return false;
                        }
                        return x.millerRabin(t);
                    }

                    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
                    function bnpMillerRabin(t) {
                        var n1 = this.subtract(BigInteger.ONE);
                        var k = n1.getLowestSetBit();
                        if (k <= 0) return false;
                        var r = n1.shiftRight(k);
                        t = (t + 1) >> 1;
                        if (t > lowprimes.length) t = lowprimes.length;
                        var a = new BigInteger(null);
                        var j,
                            bases = [];
                        for (var i = 0; i < t; ++i) {
                            for (;;) {
                                j =
                                    lowprimes[
                                        Math.floor(
                                            Math.random() * lowprimes.length
                                        )
                                    ];
                                if (bases.indexOf(j) == -1) break;
                            }
                            bases.push(j);
                            a.fromInt(j);
                            var y = a.modPow(r, this);
                            if (
                                y.compareTo(BigInteger.ONE) != 0 &&
                                y.compareTo(n1) != 0
                            ) {
                                var j = 1;
                                while (j++ < k && y.compareTo(n1) != 0) {
                                    y = y.modPowInt(2, this);
                                    if (y.compareTo(BigInteger.ONE) == 0)
                                        return false;
                                }
                                if (y.compareTo(n1) != 0) return false;
                            }
                        }
                        return true;
                    }

                    // protected
                    proto.chunkSize = bnpChunkSize;
                    proto.toRadix = bnpToRadix;
                    proto.fromRadix = bnpFromRadix;
                    proto.fromNumber = bnpFromNumber;
                    proto.bitwiseTo = bnpBitwiseTo;
                    proto.changeBit = bnpChangeBit;
                    proto.addTo = bnpAddTo;
                    proto.dMultiply = bnpDMultiply;
                    proto.dAddOffset = bnpDAddOffset;
                    proto.multiplyLowerTo = bnpMultiplyLowerTo;
                    proto.multiplyUpperTo = bnpMultiplyUpperTo;
                    proto.modInt = bnpModInt;
                    proto.millerRabin = bnpMillerRabin;

                    // public
                    proto.clone = bnClone;
                    proto.intValue = bnIntValue;
                    proto.byteValue = bnByteValue;
                    proto.shortValue = bnShortValue;
                    proto.signum = bnSigNum;
                    proto.toByteArray = bnToByteArray;
                    proto.equals = bnEquals;
                    proto.min = bnMin;
                    proto.max = bnMax;
                    proto.and = bnAnd;
                    proto.or = bnOr;
                    proto.xor = bnXor;
                    proto.andNot = bnAndNot;
                    proto.not = bnNot;
                    proto.shiftLeft = bnShiftLeft;
                    proto.shiftRight = bnShiftRight;
                    proto.getLowestSetBit = bnGetLowestSetBit;
                    proto.bitCount = bnBitCount;
                    proto.testBit = bnTestBit;
                    proto.setBit = bnSetBit;
                    proto.clearBit = bnClearBit;
                    proto.flipBit = bnFlipBit;
                    proto.add = bnAdd;
                    proto.subtract = bnSubtract;
                    proto.multiply = bnMultiply;
                    proto.divide = bnDivide;
                    proto.remainder = bnRemainder;
                    proto.divideAndRemainder = bnDivideAndRemainder;
                    proto.modPow = bnModPow;
                    proto.modInverse = bnModInverse;
                    proto.pow = bnPow;
                    proto.gcd = bnGCD;
                    proto.isProbablePrime = bnIsProbablePrime;

                    // JSBN-specific extension
                    proto.square = bnSquare;

                    // constants
                    BigInteger.ZERO = nbv(0);
                    BigInteger.ONE = nbv(1);
                    BigInteger.valueOf = nbv;

                    module.exports = BigInteger;
                },
                {
                    "../package.json":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/package.json"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/convert.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        // FIXME: Kind of a weird way to throw exceptions, consider removing
                        var assert = require("assert");
                        var BigInteger = require("./bigi");

                        /**
                         * Turns a byte array into a big integer.
                         *
                         * This function will interpret a byte array as a big integer in big
                         * endian notation.
                         */
                        BigInteger.fromByteArrayUnsigned = function(byteArray) {
                            // BigInteger expects a DER integer conformant byte array
                            if (byteArray[0] & 0x80) {
                                return new BigInteger([0].concat(byteArray));
                            }

                            return new BigInteger(byteArray);
                        };

                        /**
                         * Returns a byte array representation of the big integer.
                         *
                         * This returns the absolute of the contained value in big endian
                         * form. A value of zero results in an empty array.
                         */
                        BigInteger.prototype.toByteArrayUnsigned = function() {
                            var byteArray = this.toByteArray();
                            return byteArray[0] === 0
                                ? byteArray.slice(1)
                                : byteArray;
                        };

                        BigInteger.fromDERInteger = function(byteArray) {
                            return new BigInteger(byteArray);
                        };

                        /*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
                        BigInteger.prototype.toDERInteger =
                            BigInteger.prototype.toByteArray;

                        BigInteger.fromBuffer = function(buffer) {
                            // BigInteger expects a DER integer conformant byte array
                            if (buffer[0] & 0x80) {
                                var byteArray = Array.prototype.slice.call(
                                    buffer
                                );

                                return new BigInteger([0].concat(byteArray));
                            }

                            return new BigInteger(buffer);
                        };

                        BigInteger.fromHex = function(hex) {
                            if (hex === "") return BigInteger.ZERO;

                            assert.equal(
                                hex,
                                hex.match(/^[A-Fa-f0-9]+/),
                                "Invalid hex string"
                            );
                            assert.equal(hex.length % 2, 0, "Incomplete hex");
                            return new BigInteger(hex, 16);
                        };

                        BigInteger.prototype.toBuffer = function(size) {
                            var byteArray = this.toByteArrayUnsigned();
                            var zeros = [];

                            var padding = size - byteArray.length;
                            while (zeros.length < padding) zeros.push(0);

                            return new Buffer(zeros.concat(byteArray));
                        };

                        BigInteger.prototype.toHex = function(size) {
                            return this.toBuffer(size).toString("hex");
                        };
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./bigi":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/bigi.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js": [
                function(require, module, exports) {
                    var BigInteger = require("./bigi");

                    //addons
                    require("./convert");

                    module.exports = BigInteger;
                },
                {
                    "./bigi":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/bigi.js",
                    "./convert":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/convert.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/package.json": [
                function(require, module, exports) {
                    module.exports = {
                        _args: [
                            [
                                "bigi@1.4.2",
                                "/home/sigve/Dev/Bitshares/bitsharesjs"
                            ]
                        ],
                        _from: "bigi@1.4.2",
                        _id: "bigi@1.4.2",
                        _inBundle: false,
                        _integrity: "sha1-nGZalfiLiwj8Bc/XMfVhhZ1yWCU=",
                        _location: "/bigi",
                        _phantomChildren: {},
                        _requested: {
                            type: "version",
                            registry: true,
                            raw: "bigi@1.4.2",
                            name: "bigi",
                            escapedName: "bigi",
                            rawSpec: "1.4.2",
                            saveSpec: null,
                            fetchSpec: "1.4.2"
                        },
                        _requiredBy: ["/", "/ecurve"],
                        _resolved:
                            "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz",
                        _spec: "1.4.2",
                        _where: "/home/sigve/Dev/Bitshares/bitsharesjs",
                        bugs: {
                            url: "https://github.com/cryptocoinjs/bigi/issues"
                        },
                        dependencies: {},
                        description: "Big integers.",
                        devDependencies: {
                            coveralls: "^2.11.2",
                            istanbul: "^0.3.5",
                            jshint: "^2.5.1",
                            mocha: "^2.1.0",
                            mochify: "^2.1.0"
                        },
                        homepage: "https://github.com/cryptocoinjs/bigi#readme",
                        keywords: [
                            "cryptography",
                            "math",
                            "bitcoin",
                            "arbitrary",
                            "precision",
                            "arithmetic",
                            "big",
                            "integer",
                            "int",
                            "number",
                            "biginteger",
                            "bigint",
                            "bignumber",
                            "decimal",
                            "float"
                        ],
                        main: "./lib/index.js",
                        name: "bigi",
                        repository: {
                            url: "git+https://github.com/cryptocoinjs/bigi.git",
                            type: "git"
                        },
                        scripts: {
                            "browser-test": "mochify --wd -R spec",
                            coverage:
                                "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
                            coveralls:
                                "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info",
                            jshint:
                                "jshint --config jshint.json lib/*.js ; true",
                            test: "_mocha -- test/*.js",
                            unit: "mocha"
                        },
                        testling: {
                            files: "test/*.js",
                            harness: "mocha",
                            browsers: [
                                "ie/9..latest",
                                "firefox/latest",
                                "chrome/latest",
                                "safari/6.0..latest",
                                "iphone/6.0..latest",
                                "android-browser/4.2..latest"
                            ]
                        },
                        version: "1.4.2"
                    };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/index.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;
                    exports.Manager = exports.ChainConfig = exports.Apis = undefined;

                    var _ApiInstances = require("./src/ApiInstances");

                    var _ApiInstances2 = _interopRequireDefault(_ApiInstances);

                    var _ConnectionManager = require("./src/ConnectionManager");

                    var _ConnectionManager2 = _interopRequireDefault(
                        _ConnectionManager
                    );

                    var _ChainConfig = require("./src/ChainConfig");

                    var _ChainConfig2 = _interopRequireDefault(_ChainConfig);

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    exports.Apis = _ApiInstances2.default;
                    exports.ChainConfig = _ChainConfig2.default;
                    exports.Manager = _ConnectionManager2.default;
                },
                {
                    "./src/ApiInstances":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ApiInstances.js",
                    "./src/ChainConfig":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainConfig.js",
                    "./src/ConnectionManager":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ConnectionManager.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ApiInstances.js": [
                function(require, module, exports) {
                    (function(global) {
                        "use strict";

                        exports.__esModule = true;

                        var _ChainWebSocket = require("./ChainWebSocket");

                        var _ChainWebSocket2 = _interopRequireDefault(
                            _ChainWebSocket
                        );

                        var _GrapheneApi = require("./GrapheneApi");

                        var _GrapheneApi2 = _interopRequireDefault(
                            _GrapheneApi
                        );

                        var _ChainConfig = require("./ChainConfig");

                        var _ChainConfig2 = _interopRequireDefault(
                            _ChainConfig
                        );

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {default: obj};
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        } // var { List } = require("immutable");

                        if (global) {
                            global.inst = "";
                        } else {
                            var _inst = void 0;
                        }
                        var autoReconnect = false; // by default don't use reconnecting-websocket
                        /**
    Configure: configure as follows `Apis.instance("ws://localhost:8090").init_promise`.  This returns a promise, once resolved the connection is ready.

    Import: import { Apis } from "@graphene/chain"

    Short-hand: Apis.db("method", "parm1", 2, 3, ...).  Returns a promise with results.

    Additional usage: Apis.instance().db_api().exec("method", ["method", "parm1", 2, 3, ...]).  Returns a promise with results.
*/

                        exports.default = {
                            setRpcConnectionStatusCallback: function setRpcConnectionStatusCallback(
                                callback
                            ) {
                                this.statusCb = callback;
                                if (inst)
                                    inst.setRpcConnectionStatusCallback(
                                        callback
                                    );
                            },

                            /**
        @arg {boolean} auto means automatic reconnect if possible( browser case), default true
    */
                            setAutoReconnect: function setAutoReconnect(auto) {
                                autoReconnect = auto;
                            },

                            /**
        @arg {string} cs is only provided in the first call
        @return {Apis} singleton .. Check Apis.instance().init_promise to know when the connection is established
    */
                            reset: function reset() {
                                var cs =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : "ws://localhost:8090";
                                var connect = arguments[1];
                                var connectTimeout =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : 4000;

                                var _this = this;

                                var optionalApis = arguments[3];
                                var closeCb = arguments[4];

                                return this.close().then(function() {
                                    inst = new ApisInstance();
                                    inst.setRpcConnectionStatusCallback(
                                        _this.statusCb
                                    );

                                    if (inst && connect) {
                                        inst.connect(
                                            cs,
                                            connectTimeout,
                                            optionalApis,
                                            closeCb
                                        );
                                    }

                                    return inst;
                                });
                            },
                            instance: function instance() {
                                var cs =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : "ws://localhost:8090";
                                var connect = arguments[1];
                                var connectTimeout =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : 4000;
                                var optionalApis = arguments[3];
                                var closeCb = arguments[4];

                                if (!inst) {
                                    inst = new ApisInstance();
                                    inst.setRpcConnectionStatusCallback(
                                        this.statusCb
                                    );
                                }

                                if (inst && connect) {
                                    inst.connect(
                                        cs,
                                        connectTimeout,
                                        optionalApis
                                    );
                                }
                                if (closeCb) inst.closeCb = closeCb;
                                return inst;
                            },
                            chainId: function chainId() {
                                return Apis.instance().chain_id;
                            },

                            close: function close() {
                                if (inst) {
                                    return new Promise(function(res) {
                                        inst.close().then(function() {
                                            inst = null;
                                            res();
                                        });
                                    });
                                }

                                return Promise.resolve();
                            }
                            // db: (method, ...args) => Apis.instance().db_api().exec(method, toStrings(args)),
                            // network: (method, ...args) => Apis.instance().network_api().exec(method, toStrings(args)),
                            // history: (method, ...args) => Apis.instance().history_api().exec(method, toStrings(args)),
                            // crypto: (method, ...args) => Apis.instance().crypto_api().exec(method, toStrings(args))
                            // orders: (method, ...args) => Apis.instance().orders_api().exec(method, toStrings(args))
                        };

                        var ApisInstance = (function() {
                            function ApisInstance() {
                                _classCallCheck(this, ApisInstance);
                            }

                            /** @arg {string} connection .. */
                            ApisInstance.prototype.connect = function connect(
                                cs,
                                connectTimeout
                            ) {
                                var _this2 = this;

                                var optionalApis =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : {
                                              enableCrypto: false,
                                              enableOrders: false
                                          };

                                // console.log("INFO\tApiInstances\tconnect\t", cs);
                                this.url = cs;
                                var rpc_user = "",
                                    rpc_password = "";
                                if (
                                    typeof window !== "undefined" &&
                                    window.location &&
                                    window.location.protocol === "https:" &&
                                    cs.indexOf("wss://") < 0
                                ) {
                                    throw new Error(
                                        "Secure domains require wss connection"
                                    );
                                }

                                if (this.ws_rpc) {
                                    this.ws_rpc.statusCb = null;
                                }
                                this.ws_rpc = new _ChainWebSocket2.default(
                                    cs,
                                    this.statusCb,
                                    connectTimeout,
                                    autoReconnect,
                                    function(closed) {
                                        if (_this2._db && !closed) {
                                            _this2._db
                                                .exec("get_objects", [
                                                    ["2.1.0"]
                                                ])
                                                .catch(function(e) {});
                                        }
                                    }
                                );
                                this.init_promise = this.ws_rpc
                                    .login(rpc_user, rpc_password)
                                    .then(function() {
                                        console.log(
                                            "Connected to API node:",
                                            cs
                                        );
                                        _this2._db = new _GrapheneApi2.default(
                                            _this2.ws_rpc,
                                            "database"
                                        );
                                        _this2._net = new _GrapheneApi2.default(
                                            _this2.ws_rpc,
                                            "network_broadcast"
                                        );
                                        _this2._hist = new _GrapheneApi2.default(
                                            _this2.ws_rpc,
                                            "history"
                                        );
                                        if (optionalApis.enableOrders)
                                            _this2._orders = new _GrapheneApi2.default(
                                                _this2.ws_rpc,
                                                "orders"
                                            );
                                        if (optionalApis.enableCrypto)
                                            _this2._crypt = new _GrapheneApi2.default(
                                                _this2.ws_rpc,
                                                "crypto"
                                            );
                                        var db_promise = _this2._db
                                            .init()
                                            .then(function() {
                                                //https://github.com/cryptonomex/graphene/wiki/chain-locked-tx
                                                return _this2._db
                                                    .exec("get_chain_id", [])
                                                    .then(function(_chain_id) {
                                                        _this2.chain_id = _chain_id;
                                                        return _ChainConfig2.default.setChainId(
                                                            _chain_id
                                                        );
                                                        //DEBUG console.log("chain_id1",this.chain_id)
                                                    });
                                            });
                                        _this2.ws_rpc.on_reconnect = function() {
                                            if (!_this2.ws_rpc) return;
                                            _this2.ws_rpc
                                                .login("", "")
                                                .then(function() {
                                                    _this2._db
                                                        .init()
                                                        .then(function() {
                                                            if (_this2.statusCb)
                                                                _this2.statusCb(
                                                                    "reconnect"
                                                                );
                                                        });
                                                    _this2._net.init();
                                                    _this2._hist.init();
                                                    if (
                                                        optionalApis.enableOrders
                                                    )
                                                        _this2._orders.init();
                                                    if (
                                                        optionalApis.enableCrypto
                                                    )
                                                        _this2._crypt.init();
                                                });
                                        };
                                        _this2.ws_rpc.on_close = function() {
                                            _this2.close().then(function() {
                                                if (_this2.closeCb)
                                                    _this2.closeCb();
                                            });
                                        };
                                        var initPromises = [
                                            db_promise,
                                            _this2._net.init(),
                                            _this2._hist.init()
                                        ];

                                        if (optionalApis.enableOrders)
                                            initPromises.push(
                                                _this2._orders.init()
                                            );
                                        if (optionalApis.enableCrypto)
                                            initPromises.push(
                                                _this2._crypt.init()
                                            );
                                        return Promise.all(initPromises);
                                    })
                                    .catch(function(err) {
                                        console.error(
                                            cs,
                                            "Failed to initialize with error",
                                            err && err.message
                                        );
                                        return _this2.close().then(function() {
                                            throw err;
                                        });
                                    });
                            };

                            ApisInstance.prototype.close = function close() {
                                var _this3 = this;

                                if (
                                    this.ws_rpc &&
                                    this.ws_rpc.ws.readyState === 1
                                ) {
                                    return this.ws_rpc.close().then(function() {
                                        _this3.ws_rpc = null;
                                    });
                                }
                                this.ws_rpc = null;
                                return Promise.resolve();
                            };

                            ApisInstance.prototype.db_api = function db_api() {
                                return this._db;
                            };

                            ApisInstance.prototype.network_api = function network_api() {
                                return this._net;
                            };

                            ApisInstance.prototype.history_api = function history_api() {
                                return this._hist;
                            };

                            ApisInstance.prototype.crypto_api = function crypto_api() {
                                return this._crypt;
                            };

                            ApisInstance.prototype.orders_api = function orders_api() {
                                return this._orders;
                            };

                            ApisInstance.prototype.setRpcConnectionStatusCallback = function setRpcConnectionStatusCallback(
                                callback
                            ) {
                                this.statusCb = callback;
                            };

                            return ApisInstance;
                        })();

                        module.exports = exports["default"];
                    }.call(
                        this,
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {
                    "./ChainConfig":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainConfig.js",
                    "./ChainWebSocket":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainWebSocket.js",
                    "./GrapheneApi":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/GrapheneApi.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainConfig.js": [
                function(require, module, exports) {
                    (function(process) {
                        "use strict";

                        exports.__esModule = true;
                        var _this = void 0;

                        var ecc_config = {
                            address_prefix:
                                process.env
                                    .npm_config__graphene_ecc_default_address_prefix ||
                                "GPH"
                        };

                        _this = {
                            core_asset: "CORE",
                            address_prefix: "GPH",
                            expire_in_secs: 15,
                            expire_in_secs_proposal: 24 * 60 * 60,
                            review_in_secs_committee: 24 * 60 * 60,
                            networks: {
                                BitShares: {
                                    core_asset: "BTS",
                                    address_prefix: "BTS",
                                    chain_id:
                                        "4018d7844c78f6a6c41c6a552b898022310fc5dec06da467ee7905a8dad512c8"
                                },
                                Muse: {
                                    core_asset: "MUSE",
                                    address_prefix: "MUSE",
                                    chain_id:
                                        "45ad2d3f9ef92a49b55c2227eb06123f613bb35dd08bd876f2aea21925a67a67"
                                },
                                Test: {
                                    core_asset: "TEST",
                                    address_prefix: "TEST",
                                    chain_id:
                                        "39f5e2ede1f8bc1a3a54a7914414e3779e33193f1f5693510e73cb7a87617447"
                                },
                                Obelisk: {
                                    core_asset: "GOV",
                                    address_prefix: "FEW",
                                    chain_id:
                                        "1cfde7c388b9e8ac06462d68aadbd966b58f88797637d9af805b4560b0e9661e"
                                }
                            },

                            /** Set a few properties for known chain IDs. */
                            setChainId: function setChainId(chain_id) {
                                var i = void 0,
                                    len = void 0,
                                    network = void 0,
                                    network_name = void 0,
                                    ref = void 0;
                                ref = Object.keys(_this.networks);

                                for (i = 0, len = ref.length; i < len; i++) {
                                    network_name = ref[i];
                                    network = _this.networks[network_name];

                                    if (network.chain_id === chain_id) {
                                        _this.network_name = network_name;

                                        if (network.address_prefix) {
                                            _this.address_prefix =
                                                network.address_prefix;
                                            ecc_config.address_prefix =
                                                network.address_prefix;
                                        }

                                        // console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");

                                        return {
                                            network_name: network_name,
                                            network: network
                                        };
                                    }
                                }

                                if (!_this.network_name) {
                                    console.log(
                                        "Unknown chain id (this may be a testnet)",
                                        chain_id
                                    );
                                }
                            },

                            reset: function reset() {
                                _this.core_asset = "CORE";
                                _this.address_prefix = "GPH";
                                ecc_config.address_prefix = "GPH";
                                _this.expire_in_secs = 15;
                                _this.expire_in_secs_proposal = 24 * 60 * 60;

                                console.log("Chain config reset");
                            },

                            setPrefix: function setPrefix() {
                                var prefix =
                                    arguments.length > 0 &&
                                    arguments[0] !== undefined
                                        ? arguments[0]
                                        : "GPH";

                                _this.address_prefix = prefix;
                                ecc_config.address_prefix = prefix;
                            }
                        };

                        exports.default = _this;
                        module.exports = exports["default"];
                    }.call(this, require("_process")));
                },
                {
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainWebSocket.js": [
                function(require, module, exports) {
                    (function(process) {
                        "use strict";

                        exports.__esModule = true;

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                            }
                        }

                        var WebSocketClient = void 0;
                        if (
                            typeof WebSocket === "undefined" &&
                            !process.env.browser
                        ) {
                            WebSocketClient = require("ws");
                        } else {
                            WebSocketClient = WebSocket;
                        }

                        var SOCKET_DEBUG = false;

                        function getWebSocketClient(autoReconnect) {
                            if (
                                !autoReconnect &&
                                typeof WebSocket !== "undefined" &&
                                typeof document !== "undefined"
                            ) {
                                return WebSocket;
                            }
                            return WebSocketClient;
                        }

                        var keep_alive_interval = 5000;
                        var max_send_life = 5;
                        var max_recv_life = max_send_life * 2;

                        var ChainWebSocket = (function() {
                            function ChainWebSocket(ws_server, statusCb) {
                                var connectTimeout =
                                    arguments.length > 2 &&
                                    arguments[2] !== undefined
                                        ? arguments[2]
                                        : 5000;

                                var _this = this;

                                var autoReconnect =
                                    arguments.length > 3 &&
                                    arguments[3] !== undefined
                                        ? arguments[3]
                                        : true;
                                var keepAliveCb =
                                    arguments.length > 4 &&
                                    arguments[4] !== undefined
                                        ? arguments[4]
                                        : null;

                                _classCallCheck(this, ChainWebSocket);

                                this.url = ws_server;
                                this.statusCb = statusCb;
                                this.connectionTimeout = setTimeout(function() {
                                    if (_this.current_reject) {
                                        var reject = _this.current_reject;
                                        _this.current_reject = null;
                                        _this.close();
                                        reject(
                                            new Error(
                                                "Connection attempt timed out after " +
                                                    connectTimeout / 1000 +
                                                    "s"
                                            )
                                        );
                                    }
                                }, connectTimeout);

                                this.current_reject = null;
                                this.on_reconnect = null;
                                this.closed = false;
                                this.send_life = max_send_life;
                                this.recv_life = max_recv_life;
                                this.keepAliveCb = keepAliveCb;
                                this.connect_promise = new Promise(function(
                                    resolve,
                                    reject
                                ) {
                                    _this.current_reject = reject;
                                    var WsClient = getWebSocketClient(
                                        autoReconnect
                                    );
                                    try {
                                        _this.ws = new WsClient(ws_server);
                                    } catch (error) {
                                        _this.ws = {
                                            readyState: 3,
                                            close: function close() {}
                                        }; // DISCONNECTED
                                        reject(
                                            new Error(
                                                "Invalid url",
                                                ws_server,
                                                " closed"
                                            )
                                        );
                                        // return this.close().then(() => {
                                        //     console.log("Invalid url", ws_server, " closed");
                                        //     // throw new Error("Invalid url", ws_server, " closed")
                                        //     // return this.current_reject(Error("Invalid websocket url: " + ws_server));
                                        // })
                                    }

                                    _this.ws.onopen = function() {
                                        clearTimeout(_this.connectionTimeout);
                                        if (_this.statusCb)
                                            _this.statusCb("open");
                                        if (_this.on_reconnect)
                                            _this.on_reconnect();
                                        _this.keepalive_timer = setInterval(
                                            function() {
                                                _this.recv_life--;
                                                if (_this.recv_life == 0) {
                                                    console.error(
                                                        _this.url +
                                                            " connection is dead, terminating ws"
                                                    );
                                                    _this.close();
                                                    // clearInterval(this.keepalive_timer);
                                                    // this.keepalive_timer = undefined;
                                                    return;
                                                }
                                                _this.send_life--;
                                                if (_this.send_life == 0) {
                                                    // this.ws.ping('', false, true);
                                                    if (_this.keepAliveCb) {
                                                        _this.keepAliveCb(
                                                            _this.closed
                                                        );
                                                    }
                                                    _this.send_life = max_send_life;
                                                }
                                            },
                                            5000
                                        );
                                        _this.current_reject = null;
                                        resolve();
                                    };
                                    _this.ws.onerror = function(error) {
                                        if (_this.keepalive_timer) {
                                            clearInterval(
                                                _this.keepalive_timer
                                            );
                                            _this.keepalive_timer = undefined;
                                        }
                                        clearTimeout(_this.connectionTimeout);
                                        if (_this.statusCb)
                                            _this.statusCb("error");

                                        if (_this.current_reject) {
                                            _this.current_reject(error);
                                        }
                                    };
                                    _this.ws.onmessage = function(message) {
                                        _this.recv_life = max_recv_life;
                                        _this.listener(
                                            JSON.parse(message.data)
                                        );
                                    };
                                    _this.ws.onclose = function() {
                                        _this.closed = true;
                                        if (_this.keepalive_timer) {
                                            clearInterval(
                                                _this.keepalive_timer
                                            );
                                            _this.keepalive_timer = undefined;
                                        }
                                        var err = new Error(
                                            "connection closed"
                                        );
                                        for (
                                            var cbId = _this.responseCbId + 1;
                                            cbId <= _this.cbId;
                                            cbId += 1
                                        ) {
                                            _this.cbs[cbId].reject(err);
                                        }
                                        if (_this.statusCb)
                                            _this.statusCb("closed");
                                        if (_this._closeCb) _this._closeCb();
                                        if (_this.on_close) _this.on_close();
                                    };
                                });
                                this.cbId = 0;
                                this.responseCbId = 0;
                                this.cbs = {};
                                this.subs = {};
                                this.unsub = {};
                            }

                            ChainWebSocket.prototype.call = function call(
                                params
                            ) {
                                var _this2 = this;

                                if (this.ws.readyState !== 1) {
                                    return Promise.reject(
                                        new Error(
                                            "websocket state error:" +
                                                this.ws.readyState
                                        )
                                    );
                                }
                                var method = params[1];
                                if (SOCKET_DEBUG)
                                    console.log(
                                        '[ChainWebSocket] >---- call ----->  "id":' +
                                            (this.cbId + 1),
                                        JSON.stringify(params)
                                    );

                                this.cbId += 1;

                                if (
                                    method === "set_subscribe_callback" ||
                                    method === "subscribe_to_market" ||
                                    method ===
                                        "broadcast_transaction_with_callback" ||
                                    method ===
                                        "set_pending_transaction_callback"
                                ) {
                                    // Store callback in subs map
                                    this.subs[this.cbId] = {
                                        callback: params[2][0]
                                    };

                                    // Replace callback with the callback id
                                    params[2][0] = this.cbId;
                                }

                                if (
                                    method === "unsubscribe_from_market" ||
                                    method === "unsubscribe_from_accounts"
                                ) {
                                    if (typeof params[2][0] !== "function") {
                                        throw new Error(
                                            "First parameter of unsub must be the original callback"
                                        );
                                    }

                                    var unSubCb = params[2].splice(0, 1)[0];

                                    // Find the corresponding subscription
                                    for (var id in this.subs) {
                                        if (
                                            this.subs[id].callback === unSubCb
                                        ) {
                                            this.unsub[this.cbId] = id;
                                            break;
                                        }
                                    }
                                }

                                var request = {
                                    method: "call",
                                    params: params
                                };
                                request.id = this.cbId;
                                this.send_life = max_send_life;

                                return new Promise(function(resolve, reject) {
                                    _this2.cbs[_this2.cbId] = {
                                        time: new Date(),
                                        resolve: resolve,
                                        reject: reject
                                    };
                                    _this2.ws.send(JSON.stringify(request));
                                });
                            };

                            ChainWebSocket.prototype.listener = function listener(
                                response
                            ) {
                                if (SOCKET_DEBUG)
                                    console.log(
                                        "[ChainWebSocket] <---- reply ----<",
                                        JSON.stringify(response)
                                    );

                                var sub = false,
                                    callback = null;

                                if (response.method === "notice") {
                                    sub = true;
                                    response.id = response.params[0];
                                }

                                if (!sub) {
                                    callback = this.cbs[response.id];
                                    this.responseCbId = response.id;
                                } else {
                                    callback = this.subs[response.id].callback;
                                }

                                if (callback && !sub) {
                                    if (response.error) {
                                        callback.reject(response.error);
                                    } else {
                                        callback.resolve(response.result);
                                    }
                                    delete this.cbs[response.id];

                                    if (this.unsub[response.id]) {
                                        delete this.subs[
                                            this.unsub[response.id]
                                        ];
                                        delete this.unsub[response.id];
                                    }
                                } else if (callback && sub) {
                                    callback(response.params[1]);
                                } else {
                                    console.log(
                                        "Warning: unknown websocket response: ",
                                        response
                                    );
                                }
                            };

                            ChainWebSocket.prototype.login = function login(
                                user,
                                password
                            ) {
                                var _this3 = this;

                                return this.connect_promise.then(function() {
                                    return _this3.call([
                                        1,
                                        "login",
                                        [user, password]
                                    ]);
                                });
                            };

                            ChainWebSocket.prototype.close = function close() {
                                var _this4 = this;

                                return new Promise(function(res) {
                                    clearInterval(_this4.keepalive_timer);
                                    _this4.keepalive_timer = undefined;
                                    _this4._closeCb = function() {
                                        res();
                                        _this4._closeCb = null;
                                    };
                                    if (!_this4.ws) {
                                        console.log(
                                            "Websocket already cleared",
                                            _this4
                                        );
                                        return res();
                                    }
                                    if (_this4.ws.terminate) {
                                        _this4.ws.terminate();
                                    } else {
                                        _this4.ws.close();
                                    }
                                    if (_this4.ws.readyState === 3) res();
                                });
                            };

                            return ChainWebSocket;
                        })();

                        exports.default = ChainWebSocket;
                        module.exports = exports["default"];
                    }.call(this, require("_process")));
                },
                {
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    ws:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browser-resolve/empty.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ConnectionManager.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    var _ApiInstances = require("./ApiInstances");

                    var _ApiInstances2 = _interopRequireDefault(_ApiInstances);

                    var _ChainWebSocket = require("./ChainWebSocket");

                    var _ChainWebSocket2 = _interopRequireDefault(
                        _ChainWebSocket
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {default: obj};
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    var Manager = (function() {
                        function Manager(_ref) {
                            var url = _ref.url,
                                urls = _ref.urls,
                                autoFallback = _ref.autoFallback,
                                closeCb = _ref.closeCb,
                                optionalApis = _ref.optionalApis;

                            _classCallCheck(this, Manager);

                            this.url = url;
                            this.urls = urls.filter(function(a) {
                                return a !== url;
                            });
                            this.autoFallback = autoFallback;
                            this.closeCb = closeCb;
                            this.optionalApis = optionalApis || {};
                            this.isConnected = false;
                        }

                        Manager.prototype.setCloseCb = function setCloseCb(cb) {
                            this.closeCb = cb;
                        };

                        Manager.close = function close() {
                            return _ApiInstances2.default.close();
                        };

                        Manager.prototype.logFailure = function logFailure(
                            method,
                            url,
                            err
                        ) {
                            var message = err && err.message ? err.message : "";
                            console.error(
                                method,
                                "Failed to connect to " +
                                    url +
                                    (message
                                        ? " Error: " + JSON.stringify(message)
                                        : "")
                            );
                        };

                        Manager.prototype._onClose = function _onClose() {
                            this.isConnected = false;
                            if (this.closeCb) {
                                this.closeCb();
                                this.setCloseCb(null);
                            }
                            if (this.autoFallback) {
                                this.connectWithFallback();
                            }
                        };

                        Manager.prototype.connect = function connect() {
                            var _this = this;

                            var _connect =
                                arguments.length > 0 &&
                                arguments[0] !== undefined
                                    ? arguments[0]
                                    : true;

                            var url =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : this.url;

                            return new Promise(function(resolve, reject) {
                                _ApiInstances2.default
                                    .instance(
                                        url,
                                        _connect,
                                        undefined,
                                        _this.optionalApis,
                                        _this._onClose.bind(_this)
                                    )
                                    .init_promise.then(function(res) {
                                        _this.url = url;
                                        _this.isConnected = true;
                                        resolve(res);
                                    })
                                    .catch(function(err) {
                                        _ApiInstances2.default
                                            .close()
                                            .then(function() {
                                                reject(err);
                                            });
                                    });
                            });
                        };

                        Manager.prototype.connectWithFallback = function connectWithFallback() {
                            var connect =
                                arguments.length > 0 &&
                                arguments[0] !== undefined
                                    ? arguments[0]
                                    : true;
                            var url =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : this.url;
                            var index =
                                arguments.length > 2 &&
                                arguments[2] !== undefined
                                    ? arguments[2]
                                    : 0;

                            var _this2 = this;

                            var resolve =
                                arguments.length > 3 &&
                                arguments[3] !== undefined
                                    ? arguments[3]
                                    : null;
                            var reject =
                                arguments.length > 4 &&
                                arguments[4] !== undefined
                                    ? arguments[4]
                                    : null;

                            if (reject && index > this.urls.length)
                                return reject(
                                    new Error(
                                        "Tried " +
                                            index +
                                            " connections, none of which worked: " +
                                            JSON.stringify(
                                                this.urls.concat(this.url)
                                            )
                                    )
                                );
                            var fallback = function fallback(
                                err,
                                resolve,
                                reject
                            ) {
                                // this.logFailure("connectWithFallback", url, err);
                                return _this2.connectWithFallback(
                                    connect,
                                    _this2.urls[index],
                                    index + 1,
                                    resolve,
                                    reject
                                );
                            };
                            if (resolve && reject) {
                                return this.connect(connect, url)
                                    .then(resolve)
                                    .catch(function(err) {
                                        fallback(err, resolve, reject);
                                    });
                            } else {
                                return new Promise(function(resolve, reject) {
                                    _this2
                                        .connect(connect, undefined)
                                        .then(resolve)
                                        .catch(function(err) {
                                            fallback(err, resolve, reject);
                                        });
                                });
                            }
                        };

                        Manager.prototype.checkConnections = function checkConnections() {
                            var rpc_user =
                                arguments.length > 0 &&
                                arguments[0] !== undefined
                                    ? arguments[0]
                                    : "";
                            var rpc_password =
                                arguments.length > 1 &&
                                arguments[1] !== undefined
                                    ? arguments[1]
                                    : "";

                            var _this3 = this;

                            var resolve = arguments[2];
                            var reject = arguments[3];

                            var connectionStartTimes = {};
                            var checkFunction = function checkFunction(
                                resolve,
                                reject
                            ) {
                                var fullList = _this3.urls.concat(_this3.url);
                                var connectionPromises = [];

                                fullList.forEach(function(url) {
                                    /* Use default timeout and no reconnecting-websocket */
                                    var conn = new _ChainWebSocket2.default(
                                        url,
                                        function() {},
                                        undefined,
                                        false
                                    );
                                    connectionStartTimes[
                                        url
                                    ] = new Date().getTime();
                                    connectionPromises.push(function() {
                                        return conn
                                            .login(rpc_user, rpc_password)
                                            .then(function(data) {
                                                var _result;

                                                var result = ((_result = {}),
                                                (_result[url] =
                                                    new Date().getTime() -
                                                    connectionStartTimes[url]),
                                                _result);
                                                return conn
                                                    .close()
                                                    .then(function() {
                                                        return result;
                                                    });
                                            })
                                            .catch(function(err) {
                                                _this3.logFailure(
                                                    "checkConnections",
                                                    url,
                                                    err
                                                );
                                                if (url === _this3.url) {
                                                    _this3.url = _this3.urls[0];
                                                } else {
                                                    _this3.urls = _this3.urls.filter(
                                                        function(a) {
                                                            return a !== url;
                                                        }
                                                    );
                                                }
                                                return conn
                                                    .close()
                                                    .then(function() {
                                                        return null;
                                                    });
                                            });
                                    });
                                });

                                Promise.all(
                                    connectionPromises.map(function(a) {
                                        return a();
                                    })
                                )
                                    .then(function(res) {
                                        var final = res
                                            .filter(function(a) {
                                                return !!a;
                                            })
                                            .sort(function(a, b) {
                                                return (
                                                    Object.values(a)[0] -
                                                    Object.values(b)[0]
                                                );
                                            })
                                            .reduce(function(f, a) {
                                                var key = Object.keys(a)[0];
                                                f[key] = a[key];
                                                return f;
                                            }, {});

                                        console.log(
                                            "Checked " +
                                                res.length +
                                                " connections, " +
                                                (res.length -
                                                    Object.keys(final).length) +
                                                " failed"
                                        );
                                        return resolve(final);
                                    })
                                    .catch(function() {
                                        return _this3.checkConnections(
                                            rpc_user,
                                            rpc_password,
                                            resolve,
                                            reject
                                        );
                                    });
                            };

                            if (resolve && reject) {
                                checkFunction(resolve, reject);
                            } else {
                                return new Promise(checkFunction);
                            }
                        };

                        return Manager;
                    })();

                    exports.default = Manager;
                    module.exports = exports["default"];
                },
                {
                    "./ApiInstances":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ApiInstances.js",
                    "./ChainWebSocket":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/ChainWebSocket.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bitsharesjs-ws/cjs/src/GrapheneApi.js": [
                function(require, module, exports) {
                    "use strict";

                    exports.__esModule = true;

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    var GrapheneApi = (function() {
                        function GrapheneApi(ws_rpc, api_name) {
                            _classCallCheck(this, GrapheneApi);

                            this.ws_rpc = ws_rpc;
                            this.api_name = api_name;
                        }

                        GrapheneApi.prototype.init = function init() {
                            var self = this;
                            return this.ws_rpc
                                .call([1, this.api_name, []])
                                .then(function(response) {
                                    //console.log("[GrapheneApi.js:11] ----- GrapheneApi.init ----->", this.api_name, response);
                                    self.api_id = response;
                                    return self;
                                });
                        };

                        GrapheneApi.prototype.exec = function exec(
                            method,
                            params
                        ) {
                            return this.ws_rpc
                                .call([this.api_id, method, params])
                                .catch(function(error) {
                                    // console.log("!!! GrapheneApi error: ", method, params, error, JSON.stringify(error));
                                    throw error;
                                });
                        };

                        return GrapheneApi;
                    })();

                    exports.default = GrapheneApi;
                    module.exports = exports["default"];
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browser-resolve/empty.js": [
                function(require, module, exports) {},
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browserify/node_modules/string_decoder/index.js": [
                function(require, module, exports) {
                    // Copyright Joyent, Inc. and other Node contributors.
                    //
                    // Permission is hereby granted, free of charge, to any person obtaining a
                    // copy of this software and associated documentation files (the
                    // "Software"), to deal in the Software without restriction, including
                    // without limitation the rights to use, copy, modify, merge, publish,
                    // distribute, sublicense, and/or sell copies of the Software, and to permit
                    // persons to whom the Software is furnished to do so, subject to the
                    // following conditions:
                    //
                    // The above copyright notice and this permission notice shall be included
                    // in all copies or substantial portions of the Software.
                    //
                    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                    // USE OR OTHER DEALINGS IN THE SOFTWARE.

                    var Buffer = require("buffer").Buffer;

                    var isBufferEncoding =
                        Buffer.isEncoding ||
                        function(encoding) {
                            switch (encoding && encoding.toLowerCase()) {
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                case "raw":
                                    return true;
                                default:
                                    return false;
                            }
                        };

                    function assertEncoding(encoding) {
                        if (encoding && !isBufferEncoding(encoding)) {
                            throw new Error("Unknown encoding: " + encoding);
                        }
                    }

                    // StringDecoder provides an interface for efficiently splitting a series of
                    // buffers into a series of JS strings without breaking apart multi-byte
                    // characters. CESU-8 is handled as part of the UTF-8 encoding.
                    //
                    // @TODO Handling all encodings inside a single object makes it very difficult
                    // to reason about this code, so it should be split up in the future.
                    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
                    // points as used by CESU-8.
                    var StringDecoder = (exports.StringDecoder = function(
                        encoding
                    ) {
                        this.encoding = (encoding || "utf8")
                            .toLowerCase()
                            .replace(/[-_]/, "");
                        assertEncoding(encoding);
                        switch (this.encoding) {
                            case "utf8":
                                // CESU-8 represents each of Surrogate Pair by 3-bytes
                                this.surrogateSize = 3;
                                break;
                            case "ucs2":
                            case "utf16le":
                                // UTF-16 represents each of Surrogate Pair by 2-bytes
                                this.surrogateSize = 2;
                                this.detectIncompleteChar = utf16DetectIncompleteChar;
                                break;
                            case "base64":
                                // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                                this.surrogateSize = 3;
                                this.detectIncompleteChar = base64DetectIncompleteChar;
                                break;
                            default:
                                this.write = passThroughWrite;
                                return;
                        }

                        // Enough space to store all bytes of a single character. UTF-8 needs 4
                        // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
                        this.charBuffer = new Buffer(6);
                        // Number of bytes received for the current incomplete multi-byte character.
                        this.charReceived = 0;
                        // Number of bytes expected for the current incomplete multi-byte character.
                        this.charLength = 0;
                    });

                    // write decodes the given buffer and returns it as JS string that is
                    // guaranteed to not contain any partial multi-byte characters. Any partial
                    // character found at the end of the buffer is buffered up, and will be
                    // returned when calling write again with the remaining bytes.
                    //
                    // Note: Converting a Buffer containing an orphan surrogate to a String
                    // currently works, but converting a String to a Buffer (via `new Buffer`, or
                    // Buffer#write) will replace incomplete surrogates with the unicode
                    // replacement character. See https://codereview.chromium.org/121173009/ .
                    StringDecoder.prototype.write = function(buffer) {
                        var charStr = "";
                        // if our last write ended with an incomplete multibyte character
                        while (this.charLength) {
                            // determine how many remaining bytes this buffer has to offer for this char
                            var available =
                                buffer.length >=
                                this.charLength - this.charReceived
                                    ? this.charLength - this.charReceived
                                    : buffer.length;

                            // add the new bytes to the char buffer
                            buffer.copy(
                                this.charBuffer,
                                this.charReceived,
                                0,
                                available
                            );
                            this.charReceived += available;

                            if (this.charReceived < this.charLength) {
                                // still not enough chars in this buffer? wait for more ...
                                return "";
                            }

                            // remove bytes belonging to the current character from the buffer
                            buffer = buffer.slice(available, buffer.length);

                            // get the character that was split
                            charStr = this.charBuffer
                                .slice(0, this.charLength)
                                .toString(this.encoding);

                            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                            var charCode = charStr.charCodeAt(
                                charStr.length - 1
                            );
                            if (charCode >= 0xd800 && charCode <= 0xdbff) {
                                this.charLength += this.surrogateSize;
                                charStr = "";
                                continue;
                            }
                            this.charReceived = this.charLength = 0;

                            // if there are no more bytes in this buffer, just emit our char
                            if (buffer.length === 0) {
                                return charStr;
                            }
                            break;
                        }

                        // determine and set charLength / charReceived
                        this.detectIncompleteChar(buffer);

                        var end = buffer.length;
                        if (this.charLength) {
                            // buffer the incomplete character bytes we got
                            buffer.copy(
                                this.charBuffer,
                                0,
                                buffer.length - this.charReceived,
                                end
                            );
                            end -= this.charReceived;
                        }

                        charStr += buffer.toString(this.encoding, 0, end);

                        var end = charStr.length - 1;
                        var charCode = charStr.charCodeAt(end);
                        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                        if (charCode >= 0xd800 && charCode <= 0xdbff) {
                            var size = this.surrogateSize;
                            this.charLength += size;
                            this.charReceived += size;
                            this.charBuffer.copy(
                                this.charBuffer,
                                size,
                                0,
                                size
                            );
                            buffer.copy(this.charBuffer, 0, 0, size);
                            return charStr.substring(0, end);
                        }

                        // or just emit the charStr
                        return charStr;
                    };

                    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
                    // the end of the given buffer. If so, it sets this.charLength to the byte
                    // length that character, and sets this.charReceived to the number of bytes
                    // that are available for this character.
                    StringDecoder.prototype.detectIncompleteChar = function(
                        buffer
                    ) {
                        // determine how many bytes we have to check at the end of this buffer
                        var i = buffer.length >= 3 ? 3 : buffer.length;

                        // Figure out if one of the last i bytes of our buffer announces an
                        // incomplete char.
                        for (; i > 0; i--) {
                            var c = buffer[buffer.length - i];

                            // See http://en.wikipedia.org/wiki/UTF-8#Description

                            // 110XXXXX
                            if (i == 1 && c >> 5 == 0x06) {
                                this.charLength = 2;
                                break;
                            }

                            // 1110XXXX
                            if (i <= 2 && c >> 4 == 0x0e) {
                                this.charLength = 3;
                                break;
                            }

                            // 11110XXX
                            if (i <= 3 && c >> 3 == 0x1e) {
                                this.charLength = 4;
                                break;
                            }
                        }
                        this.charReceived = i;
                    };

                    StringDecoder.prototype.end = function(buffer) {
                        var res = "";
                        if (buffer && buffer.length) res = this.write(buffer);

                        if (this.charReceived) {
                            var cr = this.charReceived;
                            var buf = this.charBuffer;
                            var enc = this.encoding;
                            res += buf.slice(0, cr).toString(enc);
                        }

                        return res;
                    };

                    function passThroughWrite(buffer) {
                        return buffer.toString(this.encoding);
                    }

                    function utf16DetectIncompleteChar(buffer) {
                        this.charReceived = buffer.length % 2;
                        this.charLength = this.charReceived ? 2 : 0;
                    }

                    function base64DetectIncompleteChar(buffer) {
                        this.charReceived = buffer.length % 3;
                        this.charLength = this.charReceived ? 3 : 0;
                    }
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bs58/index.js": [
                function(require, module, exports) {
                    var basex = require("base-x");
                    var ALPHABET =
                        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

                    module.exports = basex(ALPHABET);
                },
                {
                    "base-x":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/base-x/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer-shims/index.js": [
                function(require, module, exports) {
                    (function(global) {
                        "use strict";

                        var buffer = require("buffer");
                        var Buffer = buffer.Buffer;
                        var SlowBuffer = buffer.SlowBuffer;
                        var MAX_LEN = buffer.kMaxLength || 2147483647;
                        exports.alloc = function alloc(size, fill, encoding) {
                            if (typeof Buffer.alloc === "function") {
                                return Buffer.alloc(size, fill, encoding);
                            }
                            if (typeof encoding === "number") {
                                throw new TypeError(
                                    "encoding must not be number"
                                );
                            }
                            if (typeof size !== "number") {
                                throw new TypeError("size must be a number");
                            }
                            if (size > MAX_LEN) {
                                throw new RangeError("size is too large");
                            }
                            var enc = encoding;
                            var _fill = fill;
                            if (_fill === undefined) {
                                enc = undefined;
                                _fill = 0;
                            }
                            var buf = new Buffer(size);
                            if (typeof _fill === "string") {
                                var fillBuf = new Buffer(_fill, enc);
                                var flen = fillBuf.length;
                                var i = -1;
                                while (++i < size) {
                                    buf[i] = fillBuf[i % flen];
                                }
                            } else {
                                buf.fill(_fill);
                            }
                            return buf;
                        };
                        exports.allocUnsafe = function allocUnsafe(size) {
                            if (typeof Buffer.allocUnsafe === "function") {
                                return Buffer.allocUnsafe(size);
                            }
                            if (typeof size !== "number") {
                                throw new TypeError("size must be a number");
                            }
                            if (size > MAX_LEN) {
                                throw new RangeError("size is too large");
                            }
                            return new Buffer(size);
                        };
                        exports.from = function from(
                            value,
                            encodingOrOffset,
                            length
                        ) {
                            if (
                                typeof Buffer.from === "function" &&
                                (!global.Uint8Array ||
                                    Uint8Array.from !== Buffer.from)
                            ) {
                                return Buffer.from(
                                    value,
                                    encodingOrOffset,
                                    length
                                );
                            }
                            if (typeof value === "number") {
                                throw new TypeError(
                                    '"value" argument must not be a number'
                                );
                            }
                            if (typeof value === "string") {
                                return new Buffer(value, encodingOrOffset);
                            }
                            if (
                                typeof ArrayBuffer !== "undefined" &&
                                value instanceof ArrayBuffer
                            ) {
                                var offset = encodingOrOffset;
                                if (arguments.length === 1) {
                                    return new Buffer(value);
                                }
                                if (typeof offset === "undefined") {
                                    offset = 0;
                                }
                                var len = length;
                                if (typeof len === "undefined") {
                                    len = value.byteLength - offset;
                                }
                                if (offset >= value.byteLength) {
                                    throw new RangeError(
                                        "'offset' is out of bounds"
                                    );
                                }
                                if (len > value.byteLength - offset) {
                                    throw new RangeError(
                                        "'length' is out of bounds"
                                    );
                                }
                                return new Buffer(
                                    value.slice(offset, offset + len)
                                );
                            }
                            if (Buffer.isBuffer(value)) {
                                var out = new Buffer(value.length);
                                value.copy(out, 0, 0, value.length);
                                return out;
                            }
                            if (value) {
                                if (
                                    Array.isArray(value) ||
                                    (typeof ArrayBuffer !== "undefined" &&
                                        value.buffer instanceof ArrayBuffer) ||
                                    "length" in value
                                ) {
                                    return new Buffer(value);
                                }
                                if (
                                    value.type === "Buffer" &&
                                    Array.isArray(value.data)
                                ) {
                                    return new Buffer(value.data);
                                }
                            }

                            throw new TypeError(
                                "First argument must be a string, Buffer, " +
                                    "ArrayBuffer, Array, or array-like object."
                            );
                        };
                        exports.allocUnsafeSlow = function allocUnsafeSlow(
                            size
                        ) {
                            if (typeof Buffer.allocUnsafeSlow === "function") {
                                return Buffer.allocUnsafeSlow(size);
                            }
                            if (typeof size !== "number") {
                                throw new TypeError("size must be a number");
                            }
                            if (size >= MAX_LEN) {
                                throw new RangeError("size is too large");
                            }
                            return new SlowBuffer(size);
                        };
                    }.call(
                        this,
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js": [
                function(require, module, exports) {
                    (function(global) {
                        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                        /* eslint-disable no-proto */

                        "use strict";

                        var base64 = require("base64-js");
                        var ieee754 = require("ieee754");
                        var isArray = require("isarray");

                        exports.Buffer = Buffer;
                        exports.SlowBuffer = SlowBuffer;
                        exports.INSPECT_MAX_BYTES = 50;

                        /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
                        Buffer.TYPED_ARRAY_SUPPORT =
                            global.TYPED_ARRAY_SUPPORT !== undefined
                                ? global.TYPED_ARRAY_SUPPORT
                                : typedArraySupport();

                        /*
 * Export kMaxLength after typed array support is determined.
 */
                        exports.kMaxLength = kMaxLength();

                        function typedArraySupport() {
                            try {
                                var arr = new Uint8Array(1);
                                arr.__proto__ = {
                                    __proto__: Uint8Array.prototype,
                                    foo: function() {
                                        return 42;
                                    }
                                };
                                return (
                                    arr.foo() === 42 && // typed array instances can be augmented
                                    typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                                    arr.subarray(1, 1).byteLength === 0
                                ); // ie10 has broken `subarray`
                            } catch (e) {
                                return false;
                            }
                        }

                        function kMaxLength() {
                            return Buffer.TYPED_ARRAY_SUPPORT
                                ? 0x7fffffff
                                : 0x3fffffff;
                        }

                        function createBuffer(that, length) {
                            if (kMaxLength() < length) {
                                throw new RangeError(
                                    "Invalid typed array length"
                                );
                            }
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                // Return an augmented `Uint8Array` instance, for best performance
                                that = new Uint8Array(length);
                                that.__proto__ = Buffer.prototype;
                            } else {
                                // Fallback: Return an object instance of the Buffer class
                                if (that === null) {
                                    that = new Buffer(length);
                                }
                                that.length = length;
                            }

                            return that;
                        }

                        /**
                         * The Buffer constructor returns instances of `Uint8Array` that have their
                         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                         * returns a single octet.
                         *
                         * The `Uint8Array` prototype remains unmodified.
                         */

                        function Buffer(arg, encodingOrOffset, length) {
                            if (
                                !Buffer.TYPED_ARRAY_SUPPORT &&
                                !(this instanceof Buffer)
                            ) {
                                return new Buffer(
                                    arg,
                                    encodingOrOffset,
                                    length
                                );
                            }

                            // Common case.
                            if (typeof arg === "number") {
                                if (typeof encodingOrOffset === "string") {
                                    throw new Error(
                                        "If encoding is specified then the first argument must be a string"
                                    );
                                }
                                return allocUnsafe(this, arg);
                            }
                            return from(this, arg, encodingOrOffset, length);
                        }

                        Buffer.poolSize = 8192; // not used by this implementation

                        // TODO: Legacy, not needed anymore. Remove in next major version.
                        Buffer._augment = function(arr) {
                            arr.__proto__ = Buffer.prototype;
                            return arr;
                        };

                        function from(that, value, encodingOrOffset, length) {
                            if (typeof value === "number") {
                                throw new TypeError(
                                    '"value" argument must not be a number'
                                );
                            }

                            if (
                                typeof ArrayBuffer !== "undefined" &&
                                value instanceof ArrayBuffer
                            ) {
                                return fromArrayBuffer(
                                    that,
                                    value,
                                    encodingOrOffset,
                                    length
                                );
                            }

                            if (typeof value === "string") {
                                return fromString(
                                    that,
                                    value,
                                    encodingOrOffset
                                );
                            }

                            return fromObject(that, value);
                        }

                        /**
                         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                         * if value is a number.
                         * Buffer.from(str[, encoding])
                         * Buffer.from(array)
                         * Buffer.from(buffer)
                         * Buffer.from(arrayBuffer[, byteOffset[, length]])
                         **/
                        Buffer.from = function(
                            value,
                            encodingOrOffset,
                            length
                        ) {
                            return from(null, value, encodingOrOffset, length);
                        };

                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            Buffer.prototype.__proto__ = Uint8Array.prototype;
                            Buffer.__proto__ = Uint8Array;
                            if (
                                typeof Symbol !== "undefined" &&
                                Symbol.species &&
                                Buffer[Symbol.species] === Buffer
                            ) {
                                // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                                Object.defineProperty(Buffer, Symbol.species, {
                                    value: null,
                                    configurable: true
                                });
                            }
                        }

                        function assertSize(size) {
                            if (typeof size !== "number") {
                                throw new TypeError(
                                    '"size" argument must be a number'
                                );
                            } else if (size < 0) {
                                throw new RangeError(
                                    '"size" argument must not be negative'
                                );
                            }
                        }

                        function alloc(that, size, fill, encoding) {
                            assertSize(size);
                            if (size <= 0) {
                                return createBuffer(that, size);
                            }
                            if (fill !== undefined) {
                                // Only pay attention to encoding if it's a string. This
                                // prevents accidentally sending in a number that would
                                // be interpretted as a start offset.
                                return typeof encoding === "string"
                                    ? createBuffer(that, size).fill(
                                          fill,
                                          encoding
                                      )
                                    : createBuffer(that, size).fill(fill);
                            }
                            return createBuffer(that, size);
                        }

                        /**
                         * Creates a new filled Buffer instance.
                         * alloc(size[, fill[, encoding]])
                         **/
                        Buffer.alloc = function(size, fill, encoding) {
                            return alloc(null, size, fill, encoding);
                        };

                        function allocUnsafe(that, size) {
                            assertSize(size);
                            that = createBuffer(
                                that,
                                size < 0 ? 0 : checked(size) | 0
                            );
                            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                                for (var i = 0; i < size; ++i) {
                                    that[i] = 0;
                                }
                            }
                            return that;
                        }

                        /**
                         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                         * */
                        Buffer.allocUnsafe = function(size) {
                            return allocUnsafe(null, size);
                        };
                        /**
                         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                         */
                        Buffer.allocUnsafeSlow = function(size) {
                            return allocUnsafe(null, size);
                        };

                        function fromString(that, string, encoding) {
                            if (
                                typeof encoding !== "string" ||
                                encoding === ""
                            ) {
                                encoding = "utf8";
                            }

                            if (!Buffer.isEncoding(encoding)) {
                                throw new TypeError(
                                    '"encoding" must be a valid string encoding'
                                );
                            }

                            var length = byteLength(string, encoding) | 0;
                            that = createBuffer(that, length);

                            var actual = that.write(string, encoding);

                            if (actual !== length) {
                                // Writing a hex string, for example, that contains invalid characters will
                                // cause everything after the first invalid character to be ignored. (e.g.
                                // 'abxxcd' will be treated as 'ab')
                                that = that.slice(0, actual);
                            }

                            return that;
                        }

                        function fromArrayLike(that, array) {
                            var length =
                                array.length < 0
                                    ? 0
                                    : checked(array.length) | 0;
                            that = createBuffer(that, length);
                            for (var i = 0; i < length; i += 1) {
                                that[i] = array[i] & 255;
                            }
                            return that;
                        }

                        function fromArrayBuffer(
                            that,
                            array,
                            byteOffset,
                            length
                        ) {
                            array.byteLength; // this throws if `array` is not a valid ArrayBuffer

                            if (
                                byteOffset < 0 ||
                                array.byteLength < byteOffset
                            ) {
                                throw new RangeError(
                                    "'offset' is out of bounds"
                                );
                            }

                            if (array.byteLength < byteOffset + (length || 0)) {
                                throw new RangeError(
                                    "'length' is out of bounds"
                                );
                            }

                            if (
                                byteOffset === undefined &&
                                length === undefined
                            ) {
                                array = new Uint8Array(array);
                            } else if (length === undefined) {
                                array = new Uint8Array(array, byteOffset);
                            } else {
                                array = new Uint8Array(
                                    array,
                                    byteOffset,
                                    length
                                );
                            }

                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                // Return an augmented `Uint8Array` instance, for best performance
                                that = array;
                                that.__proto__ = Buffer.prototype;
                            } else {
                                // Fallback: Return an object instance of the Buffer class
                                that = fromArrayLike(that, array);
                            }
                            return that;
                        }

                        function fromObject(that, obj) {
                            if (Buffer.isBuffer(obj)) {
                                var len = checked(obj.length) | 0;
                                that = createBuffer(that, len);

                                if (that.length === 0) {
                                    return that;
                                }

                                obj.copy(that, 0, 0, len);
                                return that;
                            }

                            if (obj) {
                                if (
                                    (typeof ArrayBuffer !== "undefined" &&
                                        obj.buffer instanceof ArrayBuffer) ||
                                    "length" in obj
                                ) {
                                    if (
                                        typeof obj.length !== "number" ||
                                        isnan(obj.length)
                                    ) {
                                        return createBuffer(that, 0);
                                    }
                                    return fromArrayLike(that, obj);
                                }

                                if (
                                    obj.type === "Buffer" &&
                                    isArray(obj.data)
                                ) {
                                    return fromArrayLike(that, obj.data);
                                }
                            }

                            throw new TypeError(
                                "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
                            );
                        }

                        function checked(length) {
                            // Note: cannot use `length < kMaxLength()` here because that fails when
                            // length is NaN (which is otherwise coerced to zero.)
                            if (length >= kMaxLength()) {
                                throw new RangeError(
                                    "Attempt to allocate Buffer larger than maximum " +
                                        "size: 0x" +
                                        kMaxLength().toString(16) +
                                        " bytes"
                                );
                            }
                            return length | 0;
                        }

                        function SlowBuffer(length) {
                            if (+length != length) {
                                // eslint-disable-line eqeqeq
                                length = 0;
                            }
                            return Buffer.alloc(+length);
                        }

                        Buffer.isBuffer = function isBuffer(b) {
                            return !!(b != null && b._isBuffer);
                        };

                        Buffer.compare = function compare(a, b) {
                            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                                throw new TypeError(
                                    "Arguments must be Buffers"
                                );
                            }

                            if (a === b) return 0;

                            var x = a.length;
                            var y = b.length;

                            for (
                                var i = 0, len = Math.min(x, y);
                                i < len;
                                ++i
                            ) {
                                if (a[i] !== b[i]) {
                                    x = a[i];
                                    y = b[i];
                                    break;
                                }
                            }

                            if (x < y) return -1;
                            if (y < x) return 1;
                            return 0;
                        };

                        Buffer.isEncoding = function isEncoding(encoding) {
                            switch (String(encoding).toLowerCase()) {
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "latin1":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return true;
                                default:
                                    return false;
                            }
                        };

                        Buffer.concat = function concat(list, length) {
                            if (!isArray(list)) {
                                throw new TypeError(
                                    '"list" argument must be an Array of Buffers'
                                );
                            }

                            if (list.length === 0) {
                                return Buffer.alloc(0);
                            }

                            var i;
                            if (length === undefined) {
                                length = 0;
                                for (i = 0; i < list.length; ++i) {
                                    length += list[i].length;
                                }
                            }

                            var buffer = Buffer.allocUnsafe(length);
                            var pos = 0;
                            for (i = 0; i < list.length; ++i) {
                                var buf = list[i];
                                if (!Buffer.isBuffer(buf)) {
                                    throw new TypeError(
                                        '"list" argument must be an Array of Buffers'
                                    );
                                }
                                buf.copy(buffer, pos);
                                pos += buf.length;
                            }
                            return buffer;
                        };

                        function byteLength(string, encoding) {
                            if (Buffer.isBuffer(string)) {
                                return string.length;
                            }
                            if (
                                typeof ArrayBuffer !== "undefined" &&
                                typeof ArrayBuffer.isView === "function" &&
                                (ArrayBuffer.isView(string) ||
                                    string instanceof ArrayBuffer)
                            ) {
                                return string.byteLength;
                            }
                            if (typeof string !== "string") {
                                string = "" + string;
                            }

                            var len = string.length;
                            if (len === 0) return 0;

                            // Use a for loop to avoid recursion
                            var loweredCase = false;
                            for (;;) {
                                switch (encoding) {
                                    case "ascii":
                                    case "latin1":
                                    case "binary":
                                        return len;
                                    case "utf8":
                                    case "utf-8":
                                    case undefined:
                                        return utf8ToBytes(string).length;
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return len * 2;
                                    case "hex":
                                        return len >>> 1;
                                    case "base64":
                                        return base64ToBytes(string).length;
                                    default:
                                        if (loweredCase)
                                            return utf8ToBytes(string).length; // assume utf8
                                        encoding = (
                                            "" + encoding
                                        ).toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        }
                        Buffer.byteLength = byteLength;

                        function slowToString(encoding, start, end) {
                            var loweredCase = false;

                            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                            // property of a typed array.

                            // This behaves neither like String nor Uint8Array in that we set start/end
                            // to their upper/lower bounds if the value passed is out of range.
                            // undefined is handled specially as per ECMA-262 6th Edition,
                            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                            if (start === undefined || start < 0) {
                                start = 0;
                            }
                            // Return early if start > this.length. Done here to prevent potential uint32
                            // coercion fail below.
                            if (start > this.length) {
                                return "";
                            }

                            if (end === undefined || end > this.length) {
                                end = this.length;
                            }

                            if (end <= 0) {
                                return "";
                            }

                            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                            end >>>= 0;
                            start >>>= 0;

                            if (end <= start) {
                                return "";
                            }

                            if (!encoding) encoding = "utf8";

                            while (true) {
                                switch (encoding) {
                                    case "hex":
                                        return hexSlice(this, start, end);

                                    case "utf8":
                                    case "utf-8":
                                        return utf8Slice(this, start, end);

                                    case "ascii":
                                        return asciiSlice(this, start, end);

                                    case "latin1":
                                    case "binary":
                                        return latin1Slice(this, start, end);

                                    case "base64":
                                        return base64Slice(this, start, end);

                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return utf16leSlice(this, start, end);

                                    default:
                                        if (loweredCase)
                                            throw new TypeError(
                                                "Unknown encoding: " + encoding
                                            );
                                        encoding = (
                                            encoding + ""
                                        ).toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        }

                        // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
                        // Buffer instances.
                        Buffer.prototype._isBuffer = true;

                        function swap(b, n, m) {
                            var i = b[n];
                            b[n] = b[m];
                            b[m] = i;
                        }

                        Buffer.prototype.swap16 = function swap16() {
                            var len = this.length;
                            if (len % 2 !== 0) {
                                throw new RangeError(
                                    "Buffer size must be a multiple of 16-bits"
                                );
                            }
                            for (var i = 0; i < len; i += 2) {
                                swap(this, i, i + 1);
                            }
                            return this;
                        };

                        Buffer.prototype.swap32 = function swap32() {
                            var len = this.length;
                            if (len % 4 !== 0) {
                                throw new RangeError(
                                    "Buffer size must be a multiple of 32-bits"
                                );
                            }
                            for (var i = 0; i < len; i += 4) {
                                swap(this, i, i + 3);
                                swap(this, i + 1, i + 2);
                            }
                            return this;
                        };

                        Buffer.prototype.swap64 = function swap64() {
                            var len = this.length;
                            if (len % 8 !== 0) {
                                throw new RangeError(
                                    "Buffer size must be a multiple of 64-bits"
                                );
                            }
                            for (var i = 0; i < len; i += 8) {
                                swap(this, i, i + 7);
                                swap(this, i + 1, i + 6);
                                swap(this, i + 2, i + 5);
                                swap(this, i + 3, i + 4);
                            }
                            return this;
                        };

                        Buffer.prototype.toString = function toString() {
                            var length = this.length | 0;
                            if (length === 0) return "";
                            if (arguments.length === 0)
                                return utf8Slice(this, 0, length);
                            return slowToString.apply(this, arguments);
                        };

                        Buffer.prototype.equals = function equals(b) {
                            if (!Buffer.isBuffer(b))
                                throw new TypeError(
                                    "Argument must be a Buffer"
                                );
                            if (this === b) return true;
                            return Buffer.compare(this, b) === 0;
                        };

                        Buffer.prototype.inspect = function inspect() {
                            var str = "";
                            var max = exports.INSPECT_MAX_BYTES;
                            if (this.length > 0) {
                                str = this.toString("hex", 0, max)
                                    .match(/.{2}/g)
                                    .join(" ");
                                if (this.length > max) str += " ... ";
                            }
                            return "<Buffer " + str + ">";
                        };

                        Buffer.prototype.compare = function compare(
                            target,
                            start,
                            end,
                            thisStart,
                            thisEnd
                        ) {
                            if (!Buffer.isBuffer(target)) {
                                throw new TypeError(
                                    "Argument must be a Buffer"
                                );
                            }

                            if (start === undefined) {
                                start = 0;
                            }
                            if (end === undefined) {
                                end = target ? target.length : 0;
                            }
                            if (thisStart === undefined) {
                                thisStart = 0;
                            }
                            if (thisEnd === undefined) {
                                thisEnd = this.length;
                            }

                            if (
                                start < 0 ||
                                end > target.length ||
                                thisStart < 0 ||
                                thisEnd > this.length
                            ) {
                                throw new RangeError("out of range index");
                            }

                            if (thisStart >= thisEnd && start >= end) {
                                return 0;
                            }
                            if (thisStart >= thisEnd) {
                                return -1;
                            }
                            if (start >= end) {
                                return 1;
                            }

                            start >>>= 0;
                            end >>>= 0;
                            thisStart >>>= 0;
                            thisEnd >>>= 0;

                            if (this === target) return 0;

                            var x = thisEnd - thisStart;
                            var y = end - start;
                            var len = Math.min(x, y);

                            var thisCopy = this.slice(thisStart, thisEnd);
                            var targetCopy = target.slice(start, end);

                            for (var i = 0; i < len; ++i) {
                                if (thisCopy[i] !== targetCopy[i]) {
                                    x = thisCopy[i];
                                    y = targetCopy[i];
                                    break;
                                }
                            }

                            if (x < y) return -1;
                            if (y < x) return 1;
                            return 0;
                        };

                        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                        //
                        // Arguments:
                        // - buffer - a Buffer to search
                        // - val - a string, Buffer, or number
                        // - byteOffset - an index into `buffer`; will be clamped to an int32
                        // - encoding - an optional encoding, relevant is val is a string
                        // - dir - true for indexOf, false for lastIndexOf
                        function bidirectionalIndexOf(
                            buffer,
                            val,
                            byteOffset,
                            encoding,
                            dir
                        ) {
                            // Empty buffer means no match
                            if (buffer.length === 0) return -1;

                            // Normalize byteOffset
                            if (typeof byteOffset === "string") {
                                encoding = byteOffset;
                                byteOffset = 0;
                            } else if (byteOffset > 0x7fffffff) {
                                byteOffset = 0x7fffffff;
                            } else if (byteOffset < -0x80000000) {
                                byteOffset = -0x80000000;
                            }
                            byteOffset = +byteOffset; // Coerce to Number.
                            if (isNaN(byteOffset)) {
                                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                                byteOffset = dir ? 0 : buffer.length - 1;
                            }

                            // Normalize byteOffset: negative offsets start from the end of the buffer
                            if (byteOffset < 0)
                                byteOffset = buffer.length + byteOffset;
                            if (byteOffset >= buffer.length) {
                                if (dir) return -1;
                                else byteOffset = buffer.length - 1;
                            } else if (byteOffset < 0) {
                                if (dir) byteOffset = 0;
                                else return -1;
                            }

                            // Normalize val
                            if (typeof val === "string") {
                                val = Buffer.from(val, encoding);
                            }

                            // Finally, search either indexOf (if dir is true) or lastIndexOf
                            if (Buffer.isBuffer(val)) {
                                // Special case: looking for empty string/buffer always fails
                                if (val.length === 0) {
                                    return -1;
                                }
                                return arrayIndexOf(
                                    buffer,
                                    val,
                                    byteOffset,
                                    encoding,
                                    dir
                                );
                            } else if (typeof val === "number") {
                                val = val & 0xff; // Search for a byte value [0-255]
                                if (
                                    Buffer.TYPED_ARRAY_SUPPORT &&
                                    typeof Uint8Array.prototype.indexOf ===
                                        "function"
                                ) {
                                    if (dir) {
                                        return Uint8Array.prototype.indexOf.call(
                                            buffer,
                                            val,
                                            byteOffset
                                        );
                                    } else {
                                        return Uint8Array.prototype.lastIndexOf.call(
                                            buffer,
                                            val,
                                            byteOffset
                                        );
                                    }
                                }
                                return arrayIndexOf(
                                    buffer,
                                    [val],
                                    byteOffset,
                                    encoding,
                                    dir
                                );
                            }

                            throw new TypeError(
                                "val must be string, number or Buffer"
                            );
                        }

                        function arrayIndexOf(
                            arr,
                            val,
                            byteOffset,
                            encoding,
                            dir
                        ) {
                            var indexSize = 1;
                            var arrLength = arr.length;
                            var valLength = val.length;

                            if (encoding !== undefined) {
                                encoding = String(encoding).toLowerCase();
                                if (
                                    encoding === "ucs2" ||
                                    encoding === "ucs-2" ||
                                    encoding === "utf16le" ||
                                    encoding === "utf-16le"
                                ) {
                                    if (arr.length < 2 || val.length < 2) {
                                        return -1;
                                    }
                                    indexSize = 2;
                                    arrLength /= 2;
                                    valLength /= 2;
                                    byteOffset /= 2;
                                }
                            }

                            function read(buf, i) {
                                if (indexSize === 1) {
                                    return buf[i];
                                } else {
                                    return buf.readUInt16BE(i * indexSize);
                                }
                            }

                            var i;
                            if (dir) {
                                var foundIndex = -1;
                                for (i = byteOffset; i < arrLength; i++) {
                                    if (
                                        read(arr, i) ===
                                        read(
                                            val,
                                            foundIndex === -1
                                                ? 0
                                                : i - foundIndex
                                        )
                                    ) {
                                        if (foundIndex === -1) foundIndex = i;
                                        if (i - foundIndex + 1 === valLength)
                                            return foundIndex * indexSize;
                                    } else {
                                        if (foundIndex !== -1)
                                            i -= i - foundIndex;
                                        foundIndex = -1;
                                    }
                                }
                            } else {
                                if (byteOffset + valLength > arrLength)
                                    byteOffset = arrLength - valLength;
                                for (i = byteOffset; i >= 0; i--) {
                                    var found = true;
                                    for (var j = 0; j < valLength; j++) {
                                        if (read(arr, i + j) !== read(val, j)) {
                                            found = false;
                                            break;
                                        }
                                    }
                                    if (found) return i;
                                }
                            }

                            return -1;
                        }

                        Buffer.prototype.includes = function includes(
                            val,
                            byteOffset,
                            encoding
                        ) {
                            return (
                                this.indexOf(val, byteOffset, encoding) !== -1
                            );
                        };

                        Buffer.prototype.indexOf = function indexOf(
                            val,
                            byteOffset,
                            encoding
                        ) {
                            return bidirectionalIndexOf(
                                this,
                                val,
                                byteOffset,
                                encoding,
                                true
                            );
                        };

                        Buffer.prototype.lastIndexOf = function lastIndexOf(
                            val,
                            byteOffset,
                            encoding
                        ) {
                            return bidirectionalIndexOf(
                                this,
                                val,
                                byteOffset,
                                encoding,
                                false
                            );
                        };

                        function hexWrite(buf, string, offset, length) {
                            offset = Number(offset) || 0;
                            var remaining = buf.length - offset;
                            if (!length) {
                                length = remaining;
                            } else {
                                length = Number(length);
                                if (length > remaining) {
                                    length = remaining;
                                }
                            }

                            // must be an even number of digits
                            var strLen = string.length;
                            if (strLen % 2 !== 0)
                                throw new TypeError("Invalid hex string");

                            if (length > strLen / 2) {
                                length = strLen / 2;
                            }
                            for (var i = 0; i < length; ++i) {
                                var parsed = parseInt(
                                    string.substr(i * 2, 2),
                                    16
                                );
                                if (isNaN(parsed)) return i;
                                buf[offset + i] = parsed;
                            }
                            return i;
                        }

                        function utf8Write(buf, string, offset, length) {
                            return blitBuffer(
                                utf8ToBytes(string, buf.length - offset),
                                buf,
                                offset,
                                length
                            );
                        }

                        function asciiWrite(buf, string, offset, length) {
                            return blitBuffer(
                                asciiToBytes(string),
                                buf,
                                offset,
                                length
                            );
                        }

                        function latin1Write(buf, string, offset, length) {
                            return asciiWrite(buf, string, offset, length);
                        }

                        function base64Write(buf, string, offset, length) {
                            return blitBuffer(
                                base64ToBytes(string),
                                buf,
                                offset,
                                length
                            );
                        }

                        function ucs2Write(buf, string, offset, length) {
                            return blitBuffer(
                                utf16leToBytes(string, buf.length - offset),
                                buf,
                                offset,
                                length
                            );
                        }

                        Buffer.prototype.write = function write(
                            string,
                            offset,
                            length,
                            encoding
                        ) {
                            // Buffer#write(string)
                            if (offset === undefined) {
                                encoding = "utf8";
                                length = this.length;
                                offset = 0;
                                // Buffer#write(string, encoding)
                            } else if (
                                length === undefined &&
                                typeof offset === "string"
                            ) {
                                encoding = offset;
                                length = this.length;
                                offset = 0;
                                // Buffer#write(string, offset[, length][, encoding])
                            } else if (isFinite(offset)) {
                                offset = offset | 0;
                                if (isFinite(length)) {
                                    length = length | 0;
                                    if (encoding === undefined)
                                        encoding = "utf8";
                                } else {
                                    encoding = length;
                                    length = undefined;
                                }
                                // legacy write(string, encoding, offset, length) - remove in v0.13
                            } else {
                                throw new Error(
                                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                                );
                            }

                            var remaining = this.length - offset;
                            if (length === undefined || length > remaining)
                                length = remaining;

                            if (
                                (string.length > 0 &&
                                    (length < 0 || offset < 0)) ||
                                offset > this.length
                            ) {
                                throw new RangeError(
                                    "Attempt to write outside buffer bounds"
                                );
                            }

                            if (!encoding) encoding = "utf8";

                            var loweredCase = false;
                            for (;;) {
                                switch (encoding) {
                                    case "hex":
                                        return hexWrite(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    case "utf8":
                                    case "utf-8":
                                        return utf8Write(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    case "ascii":
                                        return asciiWrite(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    case "latin1":
                                    case "binary":
                                        return latin1Write(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    case "base64":
                                        // Warning: maxLength not taken into account in base64Write
                                        return base64Write(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return ucs2Write(
                                            this,
                                            string,
                                            offset,
                                            length
                                        );

                                    default:
                                        if (loweredCase)
                                            throw new TypeError(
                                                "Unknown encoding: " + encoding
                                            );
                                        encoding = (
                                            "" + encoding
                                        ).toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        };

                        Buffer.prototype.toJSON = function toJSON() {
                            return {
                                type: "Buffer",
                                data: Array.prototype.slice.call(
                                    this._arr || this,
                                    0
                                )
                            };
                        };

                        function base64Slice(buf, start, end) {
                            if (start === 0 && end === buf.length) {
                                return base64.fromByteArray(buf);
                            } else {
                                return base64.fromByteArray(
                                    buf.slice(start, end)
                                );
                            }
                        }

                        function utf8Slice(buf, start, end) {
                            end = Math.min(buf.length, end);
                            var res = [];

                            var i = start;
                            while (i < end) {
                                var firstByte = buf[i];
                                var codePoint = null;
                                var bytesPerSequence =
                                    firstByte > 0xef
                                        ? 4
                                        : firstByte > 0xdf
                                            ? 3
                                            : firstByte > 0xbf
                                                ? 2
                                                : 1;

                                if (i + bytesPerSequence <= end) {
                                    var secondByte,
                                        thirdByte,
                                        fourthByte,
                                        tempCodePoint;

                                    switch (bytesPerSequence) {
                                        case 1:
                                            if (firstByte < 0x80) {
                                                codePoint = firstByte;
                                            }
                                            break;
                                        case 2:
                                            secondByte = buf[i + 1];
                                            if ((secondByte & 0xc0) === 0x80) {
                                                tempCodePoint =
                                                    ((firstByte & 0x1f) <<
                                                        0x6) |
                                                    (secondByte & 0x3f);
                                                if (tempCodePoint > 0x7f) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                            break;
                                        case 3:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            if (
                                                (secondByte & 0xc0) === 0x80 &&
                                                (thirdByte & 0xc0) === 0x80
                                            ) {
                                                tempCodePoint =
                                                    ((firstByte & 0xf) << 0xc) |
                                                    ((secondByte & 0x3f) <<
                                                        0x6) |
                                                    (thirdByte & 0x3f);
                                                if (
                                                    tempCodePoint > 0x7ff &&
                                                    (tempCodePoint < 0xd800 ||
                                                        tempCodePoint > 0xdfff)
                                                ) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                            break;
                                        case 4:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            fourthByte = buf[i + 3];
                                            if (
                                                (secondByte & 0xc0) === 0x80 &&
                                                (thirdByte & 0xc0) === 0x80 &&
                                                (fourthByte & 0xc0) === 0x80
                                            ) {
                                                tempCodePoint =
                                                    ((firstByte & 0xf) <<
                                                        0x12) |
                                                    ((secondByte & 0x3f) <<
                                                        0xc) |
                                                    ((thirdByte & 0x3f) <<
                                                        0x6) |
                                                    (fourthByte & 0x3f);
                                                if (
                                                    tempCodePoint > 0xffff &&
                                                    tempCodePoint < 0x110000
                                                ) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                    }
                                }

                                if (codePoint === null) {
                                    // we did not generate a valid codePoint so insert a
                                    // replacement char (U+FFFD) and advance only 1 byte
                                    codePoint = 0xfffd;
                                    bytesPerSequence = 1;
                                } else if (codePoint > 0xffff) {
                                    // encode to utf16 (surrogate pair dance)
                                    codePoint -= 0x10000;
                                    res.push(
                                        ((codePoint >>> 10) & 0x3ff) | 0xd800
                                    );
                                    codePoint = 0xdc00 | (codePoint & 0x3ff);
                                }

                                res.push(codePoint);
                                i += bytesPerSequence;
                            }

                            return decodeCodePointsArray(res);
                        }

                        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                        // the lowest limit is Chrome, with 0x10000 args.
                        // We go 1 magnitude less, for safety
                        var MAX_ARGUMENTS_LENGTH = 0x1000;

                        function decodeCodePointsArray(codePoints) {
                            var len = codePoints.length;
                            if (len <= MAX_ARGUMENTS_LENGTH) {
                                return String.fromCharCode.apply(
                                    String,
                                    codePoints
                                ); // avoid extra slice()
                            }

                            // Decode in chunks to avoid "call stack size exceeded".
                            var res = "";
                            var i = 0;
                            while (i < len) {
                                res += String.fromCharCode.apply(
                                    String,
                                    codePoints.slice(
                                        i,
                                        (i += MAX_ARGUMENTS_LENGTH)
                                    )
                                );
                            }
                            return res;
                        }

                        function asciiSlice(buf, start, end) {
                            var ret = "";
                            end = Math.min(buf.length, end);

                            for (var i = start; i < end; ++i) {
                                ret += String.fromCharCode(buf[i] & 0x7f);
                            }
                            return ret;
                        }

                        function latin1Slice(buf, start, end) {
                            var ret = "";
                            end = Math.min(buf.length, end);

                            for (var i = start; i < end; ++i) {
                                ret += String.fromCharCode(buf[i]);
                            }
                            return ret;
                        }

                        function hexSlice(buf, start, end) {
                            var len = buf.length;

                            if (!start || start < 0) start = 0;
                            if (!end || end < 0 || end > len) end = len;

                            var out = "";
                            for (var i = start; i < end; ++i) {
                                out += toHex(buf[i]);
                            }
                            return out;
                        }

                        function utf16leSlice(buf, start, end) {
                            var bytes = buf.slice(start, end);
                            var res = "";
                            for (var i = 0; i < bytes.length; i += 2) {
                                res += String.fromCharCode(
                                    bytes[i] + bytes[i + 1] * 256
                                );
                            }
                            return res;
                        }

                        Buffer.prototype.slice = function slice(start, end) {
                            var len = this.length;
                            start = ~~start;
                            end = end === undefined ? len : ~~end;

                            if (start < 0) {
                                start += len;
                                if (start < 0) start = 0;
                            } else if (start > len) {
                                start = len;
                            }

                            if (end < 0) {
                                end += len;
                                if (end < 0) end = 0;
                            } else if (end > len) {
                                end = len;
                            }

                            if (end < start) end = start;

                            var newBuf;
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                newBuf = this.subarray(start, end);
                                newBuf.__proto__ = Buffer.prototype;
                            } else {
                                var sliceLen = end - start;
                                newBuf = new Buffer(sliceLen, undefined);
                                for (var i = 0; i < sliceLen; ++i) {
                                    newBuf[i] = this[i + start];
                                }
                            }

                            return newBuf;
                        };

                        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
                        function checkOffset(offset, ext, length) {
                            if (offset % 1 !== 0 || offset < 0)
                                throw new RangeError("offset is not uint");
                            if (offset + ext > length)
                                throw new RangeError(
                                    "Trying to access beyond buffer length"
                                );
                        }

                        Buffer.prototype.readUIntLE = function readUIntLE(
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert)
                                checkOffset(offset, byteLength, this.length);

                            var val = this[offset];
                            var mul = 1;
                            var i = 0;
                            while (++i < byteLength && (mul *= 0x100)) {
                                val += this[offset + i] * mul;
                            }

                            return val;
                        };

                        Buffer.prototype.readUIntBE = function readUIntBE(
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                checkOffset(offset, byteLength, this.length);
                            }

                            var val = this[offset + --byteLength];
                            var mul = 1;
                            while (byteLength > 0 && (mul *= 0x100)) {
                                val += this[offset + --byteLength] * mul;
                            }

                            return val;
                        };

                        Buffer.prototype.readUInt8 = function readUInt8(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            return this[offset];
                        };

                        Buffer.prototype.readUInt16LE = function readUInt16LE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return this[offset] | (this[offset + 1] << 8);
                        };

                        Buffer.prototype.readUInt16BE = function readUInt16BE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return (this[offset] << 8) | this[offset + 1];
                        };

                        Buffer.prototype.readUInt32LE = function readUInt32LE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (
                                (this[offset] |
                                    (this[offset + 1] << 8) |
                                    (this[offset + 2] << 16)) +
                                this[offset + 3] * 0x1000000
                            );
                        };

                        Buffer.prototype.readUInt32BE = function readUInt32BE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (
                                this[offset] * 0x1000000 +
                                ((this[offset + 1] << 16) |
                                    (this[offset + 2] << 8) |
                                    this[offset + 3])
                            );
                        };

                        Buffer.prototype.readIntLE = function readIntLE(
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert)
                                checkOffset(offset, byteLength, this.length);

                            var val = this[offset];
                            var mul = 1;
                            var i = 0;
                            while (++i < byteLength && (mul *= 0x100)) {
                                val += this[offset + i] * mul;
                            }
                            mul *= 0x80;

                            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                            return val;
                        };

                        Buffer.prototype.readIntBE = function readIntBE(
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert)
                                checkOffset(offset, byteLength, this.length);

                            var i = byteLength;
                            var mul = 1;
                            var val = this[offset + --i];
                            while (i > 0 && (mul *= 0x100)) {
                                val += this[offset + --i] * mul;
                            }
                            mul *= 0x80;

                            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                            return val;
                        };

                        Buffer.prototype.readInt8 = function readInt8(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            if (!(this[offset] & 0x80)) return this[offset];
                            return (0xff - this[offset] + 1) * -1;
                        };

                        Buffer.prototype.readInt16LE = function readInt16LE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset] | (this[offset + 1] << 8);
                            return val & 0x8000 ? val | 0xffff0000 : val;
                        };

                        Buffer.prototype.readInt16BE = function readInt16BE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset + 1] | (this[offset] << 8);
                            return val & 0x8000 ? val | 0xffff0000 : val;
                        };

                        Buffer.prototype.readInt32LE = function readInt32LE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (
                                this[offset] |
                                (this[offset + 1] << 8) |
                                (this[offset + 2] << 16) |
                                (this[offset + 3] << 24)
                            );
                        };

                        Buffer.prototype.readInt32BE = function readInt32BE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (
                                (this[offset] << 24) |
                                (this[offset + 1] << 16) |
                                (this[offset + 2] << 8) |
                                this[offset + 3]
                            );
                        };

                        Buffer.prototype.readFloatLE = function readFloatLE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, true, 23, 4);
                        };

                        Buffer.prototype.readFloatBE = function readFloatBE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, false, 23, 4);
                        };

                        Buffer.prototype.readDoubleLE = function readDoubleLE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, true, 52, 8);
                        };

                        Buffer.prototype.readDoubleBE = function readDoubleBE(
                            offset,
                            noAssert
                        ) {
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, false, 52, 8);
                        };

                        function checkInt(buf, value, offset, ext, max, min) {
                            if (!Buffer.isBuffer(buf))
                                throw new TypeError(
                                    '"buffer" argument must be a Buffer instance'
                                );
                            if (value > max || value < min)
                                throw new RangeError(
                                    '"value" argument is out of bounds'
                                );
                            if (offset + ext > buf.length)
                                throw new RangeError("Index out of range");
                        }

                        Buffer.prototype.writeUIntLE = function writeUIntLE(
                            value,
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    byteLength,
                                    maxBytes,
                                    0
                                );
                            }

                            var mul = 1;
                            var i = 0;
                            this[offset] = value & 0xff;
                            while (++i < byteLength && (mul *= 0x100)) {
                                this[offset + i] = (value / mul) & 0xff;
                            }

                            return offset + byteLength;
                        };

                        Buffer.prototype.writeUIntBE = function writeUIntBE(
                            value,
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    byteLength,
                                    maxBytes,
                                    0
                                );
                            }

                            var i = byteLength - 1;
                            var mul = 1;
                            this[offset + i] = value & 0xff;
                            while (--i >= 0 && (mul *= 0x100)) {
                                this[offset + i] = (value / mul) & 0xff;
                            }

                            return offset + byteLength;
                        };

                        Buffer.prototype.writeUInt8 = function writeUInt8(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 1, 0xff, 0);
                            if (!Buffer.TYPED_ARRAY_SUPPORT)
                                value = Math.floor(value);
                            this[offset] = value & 0xff;
                            return offset + 1;
                        };

                        function objectWriteUInt16(
                            buf,
                            value,
                            offset,
                            littleEndian
                        ) {
                            if (value < 0) value = 0xffff + value + 1;
                            for (
                                var i = 0, j = Math.min(buf.length - offset, 2);
                                i < j;
                                ++i
                            ) {
                                buf[offset + i] =
                                    (value &
                                        (0xff <<
                                            (8 *
                                                (littleEndian
                                                    ? i
                                                    : 1 - i)))) >>>
                                    ((littleEndian ? i : 1 - i) * 8);
                            }
                        }

                        Buffer.prototype.writeUInt16LE = function writeUInt16LE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 2, 0xffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value & 0xff;
                                this[offset + 1] = value >>> 8;
                            } else {
                                objectWriteUInt16(this, value, offset, true);
                            }
                            return offset + 2;
                        };

                        Buffer.prototype.writeUInt16BE = function writeUInt16BE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 2, 0xffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value >>> 8;
                                this[offset + 1] = value & 0xff;
                            } else {
                                objectWriteUInt16(this, value, offset, false);
                            }
                            return offset + 2;
                        };

                        function objectWriteUInt32(
                            buf,
                            value,
                            offset,
                            littleEndian
                        ) {
                            if (value < 0) value = 0xffffffff + value + 1;
                            for (
                                var i = 0, j = Math.min(buf.length - offset, 4);
                                i < j;
                                ++i
                            ) {
                                buf[offset + i] =
                                    (value >>>
                                        ((littleEndian ? i : 3 - i) * 8)) &
                                    0xff;
                            }
                        }

                        Buffer.prototype.writeUInt32LE = function writeUInt32LE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 4, 0xffffffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset + 3] = value >>> 24;
                                this[offset + 2] = value >>> 16;
                                this[offset + 1] = value >>> 8;
                                this[offset] = value & 0xff;
                            } else {
                                objectWriteUInt32(this, value, offset, true);
                            }
                            return offset + 4;
                        };

                        Buffer.prototype.writeUInt32BE = function writeUInt32BE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 4, 0xffffffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value >>> 24;
                                this[offset + 1] = value >>> 16;
                                this[offset + 2] = value >>> 8;
                                this[offset + 3] = value & 0xff;
                            } else {
                                objectWriteUInt32(this, value, offset, false);
                            }
                            return offset + 4;
                        };

                        Buffer.prototype.writeIntLE = function writeIntLE(
                            value,
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) {
                                var limit = Math.pow(2, 8 * byteLength - 1);

                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    byteLength,
                                    limit - 1,
                                    -limit
                                );
                            }

                            var i = 0;
                            var mul = 1;
                            var sub = 0;
                            this[offset] = value & 0xff;
                            while (++i < byteLength && (mul *= 0x100)) {
                                if (
                                    value < 0 &&
                                    sub === 0 &&
                                    this[offset + i - 1] !== 0
                                ) {
                                    sub = 1;
                                }
                                this[offset + i] =
                                    (((value / mul) >> 0) - sub) & 0xff;
                            }

                            return offset + byteLength;
                        };

                        Buffer.prototype.writeIntBE = function writeIntBE(
                            value,
                            offset,
                            byteLength,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) {
                                var limit = Math.pow(2, 8 * byteLength - 1);

                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    byteLength,
                                    limit - 1,
                                    -limit
                                );
                            }

                            var i = byteLength - 1;
                            var mul = 1;
                            var sub = 0;
                            this[offset + i] = value & 0xff;
                            while (--i >= 0 && (mul *= 0x100)) {
                                if (
                                    value < 0 &&
                                    sub === 0 &&
                                    this[offset + i + 1] !== 0
                                ) {
                                    sub = 1;
                                }
                                this[offset + i] =
                                    (((value / mul) >> 0) - sub) & 0xff;
                            }

                            return offset + byteLength;
                        };

                        Buffer.prototype.writeInt8 = function writeInt8(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(this, value, offset, 1, 0x7f, -0x80);
                            if (!Buffer.TYPED_ARRAY_SUPPORT)
                                value = Math.floor(value);
                            if (value < 0) value = 0xff + value + 1;
                            this[offset] = value & 0xff;
                            return offset + 1;
                        };

                        Buffer.prototype.writeInt16LE = function writeInt16LE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    2,
                                    0x7fff,
                                    -0x8000
                                );
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value & 0xff;
                                this[offset + 1] = value >>> 8;
                            } else {
                                objectWriteUInt16(this, value, offset, true);
                            }
                            return offset + 2;
                        };

                        Buffer.prototype.writeInt16BE = function writeInt16BE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    2,
                                    0x7fff,
                                    -0x8000
                                );
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value >>> 8;
                                this[offset + 1] = value & 0xff;
                            } else {
                                objectWriteUInt16(this, value, offset, false);
                            }
                            return offset + 2;
                        };

                        Buffer.prototype.writeInt32LE = function writeInt32LE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    4,
                                    0x7fffffff,
                                    -0x80000000
                                );
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value & 0xff;
                                this[offset + 1] = value >>> 8;
                                this[offset + 2] = value >>> 16;
                                this[offset + 3] = value >>> 24;
                            } else {
                                objectWriteUInt32(this, value, offset, true);
                            }
                            return offset + 4;
                        };

                        Buffer.prototype.writeInt32BE = function writeInt32BE(
                            value,
                            offset,
                            noAssert
                        ) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert)
                                checkInt(
                                    this,
                                    value,
                                    offset,
                                    4,
                                    0x7fffffff,
                                    -0x80000000
                                );
                            if (value < 0) value = 0xffffffff + value + 1;
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = value >>> 24;
                                this[offset + 1] = value >>> 16;
                                this[offset + 2] = value >>> 8;
                                this[offset + 3] = value & 0xff;
                            } else {
                                objectWriteUInt32(this, value, offset, false);
                            }
                            return offset + 4;
                        };

                        function checkIEEE754(
                            buf,
                            value,
                            offset,
                            ext,
                            max,
                            min
                        ) {
                            if (offset + ext > buf.length)
                                throw new RangeError("Index out of range");
                            if (offset < 0)
                                throw new RangeError("Index out of range");
                        }

                        function writeFloat(
                            buf,
                            value,
                            offset,
                            littleEndian,
                            noAssert
                        ) {
                            if (!noAssert) {
                                checkIEEE754(
                                    buf,
                                    value,
                                    offset,
                                    4,
                                    3.4028234663852886e38,
                                    -3.4028234663852886e38
                                );
                            }
                            ieee754.write(
                                buf,
                                value,
                                offset,
                                littleEndian,
                                23,
                                4
                            );
                            return offset + 4;
                        }

                        Buffer.prototype.writeFloatLE = function writeFloatLE(
                            value,
                            offset,
                            noAssert
                        ) {
                            return writeFloat(
                                this,
                                value,
                                offset,
                                true,
                                noAssert
                            );
                        };

                        Buffer.prototype.writeFloatBE = function writeFloatBE(
                            value,
                            offset,
                            noAssert
                        ) {
                            return writeFloat(
                                this,
                                value,
                                offset,
                                false,
                                noAssert
                            );
                        };

                        function writeDouble(
                            buf,
                            value,
                            offset,
                            littleEndian,
                            noAssert
                        ) {
                            if (!noAssert) {
                                checkIEEE754(
                                    buf,
                                    value,
                                    offset,
                                    8,
                                    1.7976931348623157e308,
                                    -1.7976931348623157e308
                                );
                            }
                            ieee754.write(
                                buf,
                                value,
                                offset,
                                littleEndian,
                                52,
                                8
                            );
                            return offset + 8;
                        }

                        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
                            value,
                            offset,
                            noAssert
                        ) {
                            return writeDouble(
                                this,
                                value,
                                offset,
                                true,
                                noAssert
                            );
                        };

                        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
                            value,
                            offset,
                            noAssert
                        ) {
                            return writeDouble(
                                this,
                                value,
                                offset,
                                false,
                                noAssert
                            );
                        };

                        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                        Buffer.prototype.copy = function copy(
                            target,
                            targetStart,
                            start,
                            end
                        ) {
                            if (!start) start = 0;
                            if (!end && end !== 0) end = this.length;
                            if (targetStart >= target.length)
                                targetStart = target.length;
                            if (!targetStart) targetStart = 0;
                            if (end > 0 && end < start) end = start;

                            // Copy 0 bytes; we're done
                            if (end === start) return 0;
                            if (target.length === 0 || this.length === 0)
                                return 0;

                            // Fatal error conditions
                            if (targetStart < 0) {
                                throw new RangeError(
                                    "targetStart out of bounds"
                                );
                            }
                            if (start < 0 || start >= this.length)
                                throw new RangeError(
                                    "sourceStart out of bounds"
                                );
                            if (end < 0)
                                throw new RangeError("sourceEnd out of bounds");

                            // Are we oob?
                            if (end > this.length) end = this.length;
                            if (target.length - targetStart < end - start) {
                                end = target.length - targetStart + start;
                            }

                            var len = end - start;
                            var i;

                            if (
                                this === target &&
                                start < targetStart &&
                                targetStart < end
                            ) {
                                // descending copy from end
                                for (i = len - 1; i >= 0; --i) {
                                    target[i + targetStart] = this[i + start];
                                }
                            } else if (
                                len < 1000 ||
                                !Buffer.TYPED_ARRAY_SUPPORT
                            ) {
                                // ascending copy from start
                                for (i = 0; i < len; ++i) {
                                    target[i + targetStart] = this[i + start];
                                }
                            } else {
                                Uint8Array.prototype.set.call(
                                    target,
                                    this.subarray(start, start + len),
                                    targetStart
                                );
                            }

                            return len;
                        };

                        // Usage:
                        //    buffer.fill(number[, offset[, end]])
                        //    buffer.fill(buffer[, offset[, end]])
                        //    buffer.fill(string[, offset[, end]][, encoding])
                        Buffer.prototype.fill = function fill(
                            val,
                            start,
                            end,
                            encoding
                        ) {
                            // Handle string cases:
                            if (typeof val === "string") {
                                if (typeof start === "string") {
                                    encoding = start;
                                    start = 0;
                                    end = this.length;
                                } else if (typeof end === "string") {
                                    encoding = end;
                                    end = this.length;
                                }
                                if (val.length === 1) {
                                    var code = val.charCodeAt(0);
                                    if (code < 256) {
                                        val = code;
                                    }
                                }
                                if (
                                    encoding !== undefined &&
                                    typeof encoding !== "string"
                                ) {
                                    throw new TypeError(
                                        "encoding must be a string"
                                    );
                                }
                                if (
                                    typeof encoding === "string" &&
                                    !Buffer.isEncoding(encoding)
                                ) {
                                    throw new TypeError(
                                        "Unknown encoding: " + encoding
                                    );
                                }
                            } else if (typeof val === "number") {
                                val = val & 255;
                            }

                            // Invalid ranges are not set to a default, so can range check early.
                            if (
                                start < 0 ||
                                this.length < start ||
                                this.length < end
                            ) {
                                throw new RangeError("Out of range index");
                            }

                            if (end <= start) {
                                return this;
                            }

                            start = start >>> 0;
                            end = end === undefined ? this.length : end >>> 0;

                            if (!val) val = 0;

                            var i;
                            if (typeof val === "number") {
                                for (i = start; i < end; ++i) {
                                    this[i] = val;
                                }
                            } else {
                                var bytes = Buffer.isBuffer(val)
                                    ? val
                                    : utf8ToBytes(
                                          new Buffer(val, encoding).toString()
                                      );
                                var len = bytes.length;
                                for (i = 0; i < end - start; ++i) {
                                    this[i + start] = bytes[i % len];
                                }
                            }

                            return this;
                        };

                        // HELPER FUNCTIONS
                        // ================

                        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

                        function base64clean(str) {
                            // Node strips out invalid characters like \n and \t from the string, base64-js does not
                            str = stringtrim(str).replace(
                                INVALID_BASE64_RE,
                                ""
                            );
                            // Node converts strings with length < 2 to ''
                            if (str.length < 2) return "";
                            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                            while (str.length % 4 !== 0) {
                                str = str + "=";
                            }
                            return str;
                        }

                        function stringtrim(str) {
                            if (str.trim) return str.trim();
                            return str.replace(/^\s+|\s+$/g, "");
                        }

                        function toHex(n) {
                            if (n < 16) return "0" + n.toString(16);
                            return n.toString(16);
                        }

                        function utf8ToBytes(string, units) {
                            units = units || Infinity;
                            var codePoint;
                            var length = string.length;
                            var leadSurrogate = null;
                            var bytes = [];

                            for (var i = 0; i < length; ++i) {
                                codePoint = string.charCodeAt(i);

                                // is surrogate component
                                if (codePoint > 0xd7ff && codePoint < 0xe000) {
                                    // last char was a lead
                                    if (!leadSurrogate) {
                                        // no lead yet
                                        if (codePoint > 0xdbff) {
                                            // unexpected trail
                                            if ((units -= 3) > -1)
                                                bytes.push(0xef, 0xbf, 0xbd);
                                            continue;
                                        } else if (i + 1 === length) {
                                            // unpaired lead
                                            if ((units -= 3) > -1)
                                                bytes.push(0xef, 0xbf, 0xbd);
                                            continue;
                                        }

                                        // valid lead
                                        leadSurrogate = codePoint;

                                        continue;
                                    }

                                    // 2 leads in a row
                                    if (codePoint < 0xdc00) {
                                        if ((units -= 3) > -1)
                                            bytes.push(0xef, 0xbf, 0xbd);
                                        leadSurrogate = codePoint;
                                        continue;
                                    }

                                    // valid surrogate pair
                                    codePoint =
                                        (((leadSurrogate - 0xd800) << 10) |
                                            (codePoint - 0xdc00)) +
                                        0x10000;
                                } else if (leadSurrogate) {
                                    // valid bmp char, but last char was a lead
                                    if ((units -= 3) > -1)
                                        bytes.push(0xef, 0xbf, 0xbd);
                                }

                                leadSurrogate = null;

                                // encode utf8
                                if (codePoint < 0x80) {
                                    if ((units -= 1) < 0) break;
                                    bytes.push(codePoint);
                                } else if (codePoint < 0x800) {
                                    if ((units -= 2) < 0) break;
                                    bytes.push(
                                        (codePoint >> 0x6) | 0xc0,
                                        (codePoint & 0x3f) | 0x80
                                    );
                                } else if (codePoint < 0x10000) {
                                    if ((units -= 3) < 0) break;
                                    bytes.push(
                                        (codePoint >> 0xc) | 0xe0,
                                        ((codePoint >> 0x6) & 0x3f) | 0x80,
                                        (codePoint & 0x3f) | 0x80
                                    );
                                } else if (codePoint < 0x110000) {
                                    if ((units -= 4) < 0) break;
                                    bytes.push(
                                        (codePoint >> 0x12) | 0xf0,
                                        ((codePoint >> 0xc) & 0x3f) | 0x80,
                                        ((codePoint >> 0x6) & 0x3f) | 0x80,
                                        (codePoint & 0x3f) | 0x80
                                    );
                                } else {
                                    throw new Error("Invalid code point");
                                }
                            }

                            return bytes;
                        }

                        function asciiToBytes(str) {
                            var byteArray = [];
                            for (var i = 0; i < str.length; ++i) {
                                // Node's code seems to be doing this and not & 0x7F..
                                byteArray.push(str.charCodeAt(i) & 0xff);
                            }
                            return byteArray;
                        }

                        function utf16leToBytes(str, units) {
                            var c, hi, lo;
                            var byteArray = [];
                            for (var i = 0; i < str.length; ++i) {
                                if ((units -= 2) < 0) break;

                                c = str.charCodeAt(i);
                                hi = c >> 8;
                                lo = c % 256;
                                byteArray.push(lo);
                                byteArray.push(hi);
                            }

                            return byteArray;
                        }

                        function base64ToBytes(str) {
                            return base64.toByteArray(base64clean(str));
                        }

                        function blitBuffer(src, dst, offset, length) {
                            for (var i = 0; i < length; ++i) {
                                if (i + offset >= dst.length || i >= src.length)
                                    break;
                                dst[i + offset] = src[i];
                            }
                            return i;
                        }

                        function isnan(val) {
                            return val !== val; // eslint-disable-line no-self-compare
                        }
                    }.call(
                        this,
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {
                    "base64-js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/base64-js/index.js",
                    ieee754:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ieee754/index.js",
                    isarray:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/isarray/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bytebuffer/dist/bytebuffer.js": [
                function(require, module, exports) {
                    /*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

                    /**
                     * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
                     * Backing buffer: ArrayBuffer, Accessor: Uint8Array
                     * Released under the Apache License, Version 2.0
                     * see: https://github.com/dcodeIO/bytebuffer.js for details
                     */
                    (function(global, factory) {
                        /* AMD */ if (
                            typeof define === "function" &&
                            define["amd"]
                        )
                            define(["long"], factory);
                        /* CommonJS */ else if (
                            typeof require === "function" &&
                            typeof module === "object" &&
                            module &&
                            module["exports"]
                        )
                            module["exports"] = (function() {
                                var Long;
                                try {
                                    Long = require("long");
                                } catch (e) {}
                                return factory(Long);
                            })();
                        /* Global */ else
                            (global["dcodeIO"] = global["dcodeIO"] || {})[
                                "ByteBuffer"
                            ] = factory(global["dcodeIO"]["Long"]);
                    })(this, function(Long) {
                        "use strict";

                        /**
                         * Constructs a new ByteBuffer.
                         * @class The swiss army knife for binary data in JavaScript.
                         * @exports ByteBuffer
                         * @constructor
                         * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @expose
                         */
                        var ByteBuffer = function(
                            capacity,
                            littleEndian,
                            noAssert
                        ) {
                            if (typeof capacity === "undefined")
                                capacity = ByteBuffer.DEFAULT_CAPACITY;
                            if (typeof littleEndian === "undefined")
                                littleEndian = ByteBuffer.DEFAULT_ENDIAN;
                            if (typeof noAssert === "undefined")
                                noAssert = ByteBuffer.DEFAULT_NOASSERT;
                            if (!noAssert) {
                                capacity = capacity | 0;
                                if (capacity < 0)
                                    throw RangeError("Illegal capacity");
                                littleEndian = !!littleEndian;
                                noAssert = !!noAssert;
                            }

                            /**
                             * Backing ArrayBuffer.
                             * @type {!ArrayBuffer}
                             * @expose
                             */
                            this.buffer =
                                capacity === 0
                                    ? EMPTY_BUFFER
                                    : new ArrayBuffer(capacity);

                            /**
                             * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
                             * @type {?Uint8Array}
                             * @expose
                             */
                            this.view =
                                capacity === 0
                                    ? null
                                    : new Uint8Array(this.buffer);

                            /**
                             * Absolute read/write offset.
                             * @type {number}
                             * @expose
                             * @see ByteBuffer#flip
                             * @see ByteBuffer#clear
                             */
                            this.offset = 0;

                            /**
                             * Marked offset.
                             * @type {number}
                             * @expose
                             * @see ByteBuffer#mark
                             * @see ByteBuffer#reset
                             */
                            this.markedOffset = -1;

                            /**
                             * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
                             * @type {number}
                             * @expose
                             * @see ByteBuffer#flip
                             * @see ByteBuffer#clear
                             */
                            this.limit = capacity;

                            /**
                             * Whether to use little endian byte order, defaults to `false` for big endian.
                             * @type {boolean}
                             * @expose
                             */
                            this.littleEndian = littleEndian;

                            /**
                             * Whether to skip assertions of offsets and values, defaults to `false`.
                             * @type {boolean}
                             * @expose
                             */
                            this.noAssert = noAssert;
                        };

                        /**
                         * ByteBuffer version.
                         * @type {string}
                         * @const
                         * @expose
                         */
                        ByteBuffer.VERSION = "5.0.1";

                        /**
                         * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
                         * @type {boolean}
                         * @const
                         * @expose
                         */
                        ByteBuffer.LITTLE_ENDIAN = true;

                        /**
                         * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
                         * @type {boolean}
                         * @const
                         * @expose
                         */
                        ByteBuffer.BIG_ENDIAN = false;

                        /**
                         * Default initial capacity of `16`.
                         * @type {number}
                         * @expose
                         */
                        ByteBuffer.DEFAULT_CAPACITY = 16;

                        /**
                         * Default endianess of `false` for big endian.
                         * @type {boolean}
                         * @expose
                         */
                        ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

                        /**
                         * Default no assertions flag of `false`.
                         * @type {boolean}
                         * @expose
                         */
                        ByteBuffer.DEFAULT_NOASSERT = false;

                        /**
                         * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
                         *  and int64 support is not available.
                         * @type {?Long}
                         * @const
                         * @see https://github.com/dcodeIO/long.js
                         * @expose
                         */
                        ByteBuffer.Long = Long || null;

                        /**
                         * @alias ByteBuffer.prototype
                         * @inner
                         */
                        var ByteBufferPrototype = ByteBuffer.prototype;

                        /**
                         * An indicator used to reliably determine if an object is a ByteBuffer or not.
                         * @type {boolean}
                         * @const
                         * @expose
                         * @private
                         */
                        ByteBufferPrototype.__isByteBuffer__;

                        Object.defineProperty(
                            ByteBufferPrototype,
                            "__isByteBuffer__",
                            {
                                value: true,
                                enumerable: false,
                                configurable: false
                            }
                        );

                        // helpers

                        /**
                         * @type {!ArrayBuffer}
                         * @inner
                         */
                        var EMPTY_BUFFER = new ArrayBuffer(0);

                        /**
                         * String.fromCharCode reference for compile-time renaming.
                         * @type {function(...number):string}
                         * @inner
                         */
                        var stringFromCharCode = String.fromCharCode;

                        /**
                         * Creates a source function for a string.
                         * @param {string} s String to read from
                         * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
                         *  no more characters left.
                         * @throws {TypeError} If the argument is invalid
                         * @inner
                         */
                        function stringSource(s) {
                            var i = 0;
                            return function() {
                                return i < s.length ? s.charCodeAt(i++) : null;
                            };
                        }

                        /**
                         * Creates a destination function for a string.
                         * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
                         *  Returns the final string when called without arguments.
                         * @inner
                         */
                        function stringDestination() {
                            var cs = [],
                                ps = [];
                            return function() {
                                if (arguments.length === 0)
                                    return (
                                        ps.join("") +
                                        stringFromCharCode.apply(String, cs)
                                    );
                                if (cs.length + arguments.length > 1024)
                                    ps.push(
                                        stringFromCharCode.apply(String, cs)
                                    ),
                                        (cs.length = 0);
                                Array.prototype.push.apply(cs, arguments);
                            };
                        }

                        /**
                         * Gets the accessor type.
                         * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
                         * @expose
                         */
                        ByteBuffer.accessor = function() {
                            return Uint8Array;
                        };
                        /**
                         * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
                         * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer}
                         * @expose
                         */
                        ByteBuffer.allocate = function(
                            capacity,
                            littleEndian,
                            noAssert
                        ) {
                            return new ByteBuffer(
                                capacity,
                                littleEndian,
                                noAssert
                            );
                        };

                        /**
                         * Concatenates multiple ByteBuffers into one.
                         * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
                         * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
                         *  defaults to "utf8")
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
                         *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer} Concatenated ByteBuffer
                         * @expose
                         */
                        ByteBuffer.concat = function(
                            buffers,
                            encoding,
                            littleEndian,
                            noAssert
                        ) {
                            if (
                                typeof encoding === "boolean" ||
                                typeof encoding !== "string"
                            ) {
                                noAssert = littleEndian;
                                littleEndian = encoding;
                                encoding = undefined;
                            }
                            var capacity = 0;
                            for (
                                var i = 0, k = buffers.length, length;
                                i < k;
                                ++i
                            ) {
                                if (!ByteBuffer.isByteBuffer(buffers[i]))
                                    buffers[i] = ByteBuffer.wrap(
                                        buffers[i],
                                        encoding
                                    );
                                length = buffers[i].limit - buffers[i].offset;
                                if (length > 0) capacity += length;
                            }
                            if (capacity === 0)
                                return new ByteBuffer(
                                    0,
                                    littleEndian,
                                    noAssert
                                );
                            var bb = new ByteBuffer(
                                    capacity,
                                    littleEndian,
                                    noAssert
                                ),
                                bi;
                            i = 0;
                            while (i < k) {
                                bi = buffers[i++];
                                length = bi.limit - bi.offset;
                                if (length <= 0) continue;
                                bb.view.set(
                                    bi.view.subarray(bi.offset, bi.limit),
                                    bb.offset
                                );
                                bb.offset += length;
                            }
                            bb.limit = bb.offset;
                            bb.offset = 0;
                            return bb;
                        };

                        /**
                         * Tests if the specified type is a ByteBuffer.
                         * @param {*} bb ByteBuffer to test
                         * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
                         * @expose
                         */
                        ByteBuffer.isByteBuffer = function(bb) {
                            return (bb && bb["__isByteBuffer__"]) === true;
                        };
                        /**
                         * Gets the backing buffer type.
                         * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
                         * @expose
                         */
                        ByteBuffer.type = function() {
                            return ArrayBuffer;
                        };
                        /**
                         * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
                         *  {@link ByteBuffer#limit} to the length of the wrapped data.
                         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
                         * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
                         *  "utf8")
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
                         * @expose
                         */
                        ByteBuffer.wrap = function(
                            buffer,
                            encoding,
                            littleEndian,
                            noAssert
                        ) {
                            if (typeof encoding !== "string") {
                                noAssert = littleEndian;
                                littleEndian = encoding;
                                encoding = undefined;
                            }
                            if (typeof buffer === "string") {
                                if (typeof encoding === "undefined")
                                    encoding = "utf8";
                                switch (encoding) {
                                    case "base64":
                                        return ByteBuffer.fromBase64(
                                            buffer,
                                            littleEndian
                                        );
                                    case "hex":
                                        return ByteBuffer.fromHex(
                                            buffer,
                                            littleEndian
                                        );
                                    case "binary":
                                        return ByteBuffer.fromBinary(
                                            buffer,
                                            littleEndian
                                        );
                                    case "utf8":
                                        return ByteBuffer.fromUTF8(
                                            buffer,
                                            littleEndian
                                        );
                                    case "debug":
                                        return ByteBuffer.fromDebug(
                                            buffer,
                                            littleEndian
                                        );
                                    default:
                                        throw Error(
                                            "Unsupported encoding: " + encoding
                                        );
                                }
                            }
                            if (buffer === null || typeof buffer !== "object")
                                throw TypeError("Illegal buffer");
                            var bb;
                            if (ByteBuffer.isByteBuffer(buffer)) {
                                bb = ByteBufferPrototype.clone.call(buffer);
                                bb.markedOffset = -1;
                                return bb;
                            }
                            if (buffer instanceof Uint8Array) {
                                // Extract ArrayBuffer from Uint8Array
                                bb = new ByteBuffer(0, littleEndian, noAssert);
                                if (buffer.length > 0) {
                                    // Avoid references to more than one EMPTY_BUFFER
                                    bb.buffer = buffer.buffer;
                                    bb.offset = buffer.byteOffset;
                                    bb.limit =
                                        buffer.byteOffset + buffer.byteLength;
                                    bb.view = new Uint8Array(buffer.buffer);
                                }
                            } else if (buffer instanceof ArrayBuffer) {
                                // Reuse ArrayBuffer
                                bb = new ByteBuffer(0, littleEndian, noAssert);
                                if (buffer.byteLength > 0) {
                                    bb.buffer = buffer;
                                    bb.offset = 0;
                                    bb.limit = buffer.byteLength;
                                    bb.view =
                                        buffer.byteLength > 0
                                            ? new Uint8Array(buffer)
                                            : null;
                                }
                            } else if (
                                Object.prototype.toString.call(buffer) ===
                                "[object Array]"
                            ) {
                                // Create from octets
                                bb = new ByteBuffer(
                                    buffer.length,
                                    littleEndian,
                                    noAssert
                                );
                                bb.limit = buffer.length;
                                for (var i = 0; i < buffer.length; ++i)
                                    bb.view[i] = buffer[i];
                            } else throw TypeError("Illegal buffer"); // Otherwise fail
                            return bb;
                        };

                        /**
                         * Writes the array as a bitset.
                         * @param {Array<boolean>} value Array of booleans to write
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
                         * @returns {!ByteBuffer}
                         * @expose
                         */
                        ByteBufferPrototype.writeBitSet = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (!(value instanceof Array))
                                    throw TypeError(
                                        "Illegal BitSet: Not an array"
                                    );
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }

                            var start = offset,
                                bits = value.length,
                                bytes = bits >> 3,
                                bit = 0,
                                k;

                            offset += this.writeVarint32(bits, offset);

                            while (bytes--) {
                                k =
                                    (!!value[bit++] & 1) |
                                    ((!!value[bit++] & 1) << 1) |
                                    ((!!value[bit++] & 1) << 2) |
                                    ((!!value[bit++] & 1) << 3) |
                                    ((!!value[bit++] & 1) << 4) |
                                    ((!!value[bit++] & 1) << 5) |
                                    ((!!value[bit++] & 1) << 6) |
                                    ((!!value[bit++] & 1) << 7);
                                this.writeByte(k, offset++);
                            }

                            if (bit < bits) {
                                var m = 0;
                                k = 0;
                                while (bit < bits)
                                    k = k | ((!!value[bit++] & 1) << m++);
                                this.writeByte(k, offset++);
                            }

                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return offset - start;
                        };

                        /**
                         * Reads a BitSet as an array of booleans.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
                         * @returns {Array<boolean>
                         * @expose
                         */
                        ByteBufferPrototype.readBitSet = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;

                            var ret = this.readVarint32(offset),
                                bits = ret.value,
                                bytes = bits >> 3,
                                bit = 0,
                                value = [],
                                k;

                            offset += ret.length;

                            while (bytes--) {
                                k = this.readByte(offset++);
                                value[bit++] = !!(k & 0x01);
                                value[bit++] = !!(k & 0x02);
                                value[bit++] = !!(k & 0x04);
                                value[bit++] = !!(k & 0x08);
                                value[bit++] = !!(k & 0x10);
                                value[bit++] = !!(k & 0x20);
                                value[bit++] = !!(k & 0x40);
                                value[bit++] = !!(k & 0x80);
                            }

                            if (bit < bits) {
                                var m = 0;
                                k = this.readByte(offset++);
                                while (bit < bits)
                                    value[bit++] = !!((k >> m++) & 1);
                            }

                            if (relative) {
                                this.offset = offset;
                            }
                            return value;
                        };
                        /**
                         * Reads the specified number of bytes.
                         * @param {number} length Number of bytes to read
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
                         * @returns {!ByteBuffer}
                         * @expose
                         */
                        ByteBufferPrototype.readBytes = function(
                            length,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + length > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            length +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var slice = this.slice(offset, offset + length);
                            if (relative) this.offset += length;
                            return slice;
                        };

                        /**
                         * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
                         * @function
                         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
                         *  will be modified according to the performed read operation.
                         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeBytes =
                            ByteBufferPrototype.append;

                        // types/ints/int8

                        /**
                         * Writes an 8bit signed integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeInt8 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value |= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 1;
                            var capacity0 = this.buffer.byteLength;
                            if (offset > capacity0)
                                this.resize(
                                    (capacity0 *= 2) > offset
                                        ? capacity0
                                        : offset
                                );
                            offset -= 1;
                            this.view[offset] = value;
                            if (relative) this.offset += 1;
                            return this;
                        };

                        /**
                         * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeByte =
                            ByteBufferPrototype.writeInt8;

                        /**
                         * Reads an 8bit signed integer.
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readInt8 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 1 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            1 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = this.view[offset];
                            if ((value & 0x80) === 0x80)
                                value = -(0xff - value + 1); // Cast to signed
                            if (relative) this.offset += 1;
                            return value;
                        };

                        /**
                         * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readByte =
                            ByteBufferPrototype.readInt8;

                        /**
                         * Writes an 8bit unsigned integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeUint8 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value >>>= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 1;
                            var capacity1 = this.buffer.byteLength;
                            if (offset > capacity1)
                                this.resize(
                                    (capacity1 *= 2) > offset
                                        ? capacity1
                                        : offset
                                );
                            offset -= 1;
                            this.view[offset] = value;
                            if (relative) this.offset += 1;
                            return this;
                        };

                        /**
                         * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeUInt8 =
                            ByteBufferPrototype.writeUint8;

                        /**
                         * Reads an 8bit unsigned integer.
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readUint8 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 1 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            1 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = this.view[offset];
                            if (relative) this.offset += 1;
                            return value;
                        };

                        /**
                         * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readUInt8 =
                            ByteBufferPrototype.readUint8;

                        // types/ints/int16

                        /**
                         * Writes a 16bit signed integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @throws {TypeError} If `offset` or `value` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.writeInt16 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value |= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 2;
                            var capacity2 = this.buffer.byteLength;
                            if (offset > capacity2)
                                this.resize(
                                    (capacity2 *= 2) > offset
                                        ? capacity2
                                        : offset
                                );
                            offset -= 2;
                            if (this.littleEndian) {
                                this.view[offset + 1] = (value & 0xff00) >>> 8;
                                this.view[offset] = value & 0x00ff;
                            } else {
                                this.view[offset] = (value & 0xff00) >>> 8;
                                this.view[offset + 1] = value & 0x00ff;
                            }
                            if (relative) this.offset += 2;
                            return this;
                        };

                        /**
                         * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @throws {TypeError} If `offset` or `value` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.writeShort =
                            ByteBufferPrototype.writeInt16;

                        /**
                         * Reads a 16bit signed integer.
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @returns {number} Value read
                         * @throws {TypeError} If `offset` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.readInt16 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 2 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            2 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = 0;
                            if (this.littleEndian) {
                                value = this.view[offset];
                                value |= this.view[offset + 1] << 8;
                            } else {
                                value = this.view[offset] << 8;
                                value |= this.view[offset + 1];
                            }
                            if ((value & 0x8000) === 0x8000)
                                value = -(0xffff - value + 1); // Cast to signed
                            if (relative) this.offset += 2;
                            return value;
                        };

                        /**
                         * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @returns {number} Value read
                         * @throws {TypeError} If `offset` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.readShort =
                            ByteBufferPrototype.readInt16;

                        /**
                         * Writes a 16bit unsigned integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @throws {TypeError} If `offset` or `value` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.writeUint16 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value >>>= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 2;
                            var capacity3 = this.buffer.byteLength;
                            if (offset > capacity3)
                                this.resize(
                                    (capacity3 *= 2) > offset
                                        ? capacity3
                                        : offset
                                );
                            offset -= 2;
                            if (this.littleEndian) {
                                this.view[offset + 1] = (value & 0xff00) >>> 8;
                                this.view[offset] = value & 0x00ff;
                            } else {
                                this.view[offset] = (value & 0xff00) >>> 8;
                                this.view[offset + 1] = value & 0x00ff;
                            }
                            if (relative) this.offset += 2;
                            return this;
                        };

                        /**
                         * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @throws {TypeError} If `offset` or `value` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.writeUInt16 =
                            ByteBufferPrototype.writeUint16;

                        /**
                         * Reads a 16bit unsigned integer.
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @returns {number} Value read
                         * @throws {TypeError} If `offset` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.readUint16 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 2 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            2 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = 0;
                            if (this.littleEndian) {
                                value = this.view[offset];
                                value |= this.view[offset + 1] << 8;
                            } else {
                                value = this.view[offset] << 8;
                                value |= this.view[offset + 1];
                            }
                            if (relative) this.offset += 2;
                            return value;
                        };

                        /**
                         * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
                         * @returns {number} Value read
                         * @throws {TypeError} If `offset` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.readUInt16 =
                            ByteBufferPrototype.readUint16;

                        // types/ints/int32

                        /**
                         * Writes a 32bit signed integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @expose
                         */
                        ByteBufferPrototype.writeInt32 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value |= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 4;
                            var capacity4 = this.buffer.byteLength;
                            if (offset > capacity4)
                                this.resize(
                                    (capacity4 *= 2) > offset
                                        ? capacity4
                                        : offset
                                );
                            offset -= 4;
                            if (this.littleEndian) {
                                this.view[offset + 3] = (value >>> 24) & 0xff;
                                this.view[offset + 2] = (value >>> 16) & 0xff;
                                this.view[offset + 1] = (value >>> 8) & 0xff;
                                this.view[offset] = value & 0xff;
                            } else {
                                this.view[offset] = (value >>> 24) & 0xff;
                                this.view[offset + 1] = (value >>> 16) & 0xff;
                                this.view[offset + 2] = (value >>> 8) & 0xff;
                                this.view[offset + 3] = value & 0xff;
                            }
                            if (relative) this.offset += 4;
                            return this;
                        };

                        /**
                         * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @expose
                         */
                        ByteBufferPrototype.writeInt =
                            ByteBufferPrototype.writeInt32;

                        /**
                         * Reads a 32bit signed integer.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readInt32 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 4 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            4 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = 0;
                            if (this.littleEndian) {
                                value = this.view[offset + 2] << 16;
                                value |= this.view[offset + 1] << 8;
                                value |= this.view[offset];
                                value += (this.view[offset + 3] << 24) >>> 0;
                            } else {
                                value = this.view[offset + 1] << 16;
                                value |= this.view[offset + 2] << 8;
                                value |= this.view[offset + 3];
                                value += (this.view[offset] << 24) >>> 0;
                            }
                            value |= 0; // Cast to signed
                            if (relative) this.offset += 4;
                            return value;
                        };

                        /**
                         * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
                         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readInt =
                            ByteBufferPrototype.readInt32;

                        /**
                         * Writes a 32bit unsigned integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @expose
                         */
                        ByteBufferPrototype.writeUint32 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value >>>= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 4;
                            var capacity5 = this.buffer.byteLength;
                            if (offset > capacity5)
                                this.resize(
                                    (capacity5 *= 2) > offset
                                        ? capacity5
                                        : offset
                                );
                            offset -= 4;
                            if (this.littleEndian) {
                                this.view[offset + 3] = (value >>> 24) & 0xff;
                                this.view[offset + 2] = (value >>> 16) & 0xff;
                                this.view[offset + 1] = (value >>> 8) & 0xff;
                                this.view[offset] = value & 0xff;
                            } else {
                                this.view[offset] = (value >>> 24) & 0xff;
                                this.view[offset + 1] = (value >>> 16) & 0xff;
                                this.view[offset + 2] = (value >>> 8) & 0xff;
                                this.view[offset + 3] = value & 0xff;
                            }
                            if (relative) this.offset += 4;
                            return this;
                        };

                        /**
                         * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @expose
                         */
                        ByteBufferPrototype.writeUInt32 =
                            ByteBufferPrototype.writeUint32;

                        /**
                         * Reads a 32bit unsigned integer.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readUint32 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 4 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            4 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = 0;
                            if (this.littleEndian) {
                                value = this.view[offset + 2] << 16;
                                value |= this.view[offset + 1] << 8;
                                value |= this.view[offset];
                                value += (this.view[offset + 3] << 24) >>> 0;
                            } else {
                                value = this.view[offset + 1] << 16;
                                value |= this.view[offset + 2] << 8;
                                value |= this.view[offset + 3];
                                value += (this.view[offset] << 24) >>> 0;
                            }
                            if (relative) this.offset += 4;
                            return value;
                        };

                        /**
                         * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number} Value read
                         * @expose
                         */
                        ByteBufferPrototype.readUInt32 =
                            ByteBufferPrototype.readUint32;

                        // types/ints/int64

                        if (Long) {
                            /**
                             * Writes a 64bit signed integer.
                             * @param {number|!Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!ByteBuffer} this
                             * @expose
                             */
                            ByteBufferPrototype.writeInt64 = function(
                                value,
                                offset
                            ) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (typeof value === "number")
                                        value = Long.fromNumber(value);
                                    else if (typeof value === "string")
                                        value = Long.fromString(value);
                                    else if (!(value && value instanceof Long))
                                        throw TypeError(
                                            "Illegal value: " +
                                                value +
                                                " (not an integer or Long)"
                                        );
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 0 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                0 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                if (typeof value === "number")
                                    value = Long.fromNumber(value);
                                else if (typeof value === "string")
                                    value = Long.fromString(value);
                                offset += 8;
                                var capacity6 = this.buffer.byteLength;
                                if (offset > capacity6)
                                    this.resize(
                                        (capacity6 *= 2) > offset
                                            ? capacity6
                                            : offset
                                    );
                                offset -= 8;
                                var lo = value.low,
                                    hi = value.high;
                                if (this.littleEndian) {
                                    this.view[offset + 3] = (lo >>> 24) & 0xff;
                                    this.view[offset + 2] = (lo >>> 16) & 0xff;
                                    this.view[offset + 1] = (lo >>> 8) & 0xff;
                                    this.view[offset] = lo & 0xff;
                                    offset += 4;
                                    this.view[offset + 3] = (hi >>> 24) & 0xff;
                                    this.view[offset + 2] = (hi >>> 16) & 0xff;
                                    this.view[offset + 1] = (hi >>> 8) & 0xff;
                                    this.view[offset] = hi & 0xff;
                                } else {
                                    this.view[offset] = (hi >>> 24) & 0xff;
                                    this.view[offset + 1] = (hi >>> 16) & 0xff;
                                    this.view[offset + 2] = (hi >>> 8) & 0xff;
                                    this.view[offset + 3] = hi & 0xff;
                                    offset += 4;
                                    this.view[offset] = (lo >>> 24) & 0xff;
                                    this.view[offset + 1] = (lo >>> 16) & 0xff;
                                    this.view[offset + 2] = (lo >>> 8) & 0xff;
                                    this.view[offset + 3] = lo & 0xff;
                                }
                                if (relative) this.offset += 8;
                                return this;
                            };

                            /**
                             * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
                             * @param {number|!Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!ByteBuffer} this
                             * @expose
                             */
                            ByteBufferPrototype.writeLong =
                                ByteBufferPrototype.writeInt64;

                            /**
                             * Reads a 64bit signed integer.
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!Long}
                             * @expose
                             */
                            ByteBufferPrototype.readInt64 = function(offset) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 8 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                8 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                var lo = 0,
                                    hi = 0;
                                if (this.littleEndian) {
                                    lo = this.view[offset + 2] << 16;
                                    lo |= this.view[offset + 1] << 8;
                                    lo |= this.view[offset];
                                    lo += (this.view[offset + 3] << 24) >>> 0;
                                    offset += 4;
                                    hi = this.view[offset + 2] << 16;
                                    hi |= this.view[offset + 1] << 8;
                                    hi |= this.view[offset];
                                    hi += (this.view[offset + 3] << 24) >>> 0;
                                } else {
                                    hi = this.view[offset + 1] << 16;
                                    hi |= this.view[offset + 2] << 8;
                                    hi |= this.view[offset + 3];
                                    hi += (this.view[offset] << 24) >>> 0;
                                    offset += 4;
                                    lo = this.view[offset + 1] << 16;
                                    lo |= this.view[offset + 2] << 8;
                                    lo |= this.view[offset + 3];
                                    lo += (this.view[offset] << 24) >>> 0;
                                }
                                var value = new Long(lo, hi, false);
                                if (relative) this.offset += 8;
                                return value;
                            };

                            /**
                             * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!Long}
                             * @expose
                             */
                            ByteBufferPrototype.readLong =
                                ByteBufferPrototype.readInt64;

                            /**
                             * Writes a 64bit unsigned integer.
                             * @param {number|!Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!ByteBuffer} this
                             * @expose
                             */
                            ByteBufferPrototype.writeUint64 = function(
                                value,
                                offset
                            ) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (typeof value === "number")
                                        value = Long.fromNumber(value);
                                    else if (typeof value === "string")
                                        value = Long.fromString(value);
                                    else if (!(value && value instanceof Long))
                                        throw TypeError(
                                            "Illegal value: " +
                                                value +
                                                " (not an integer or Long)"
                                        );
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 0 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                0 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                if (typeof value === "number")
                                    value = Long.fromNumber(value);
                                else if (typeof value === "string")
                                    value = Long.fromString(value);
                                offset += 8;
                                var capacity7 = this.buffer.byteLength;
                                if (offset > capacity7)
                                    this.resize(
                                        (capacity7 *= 2) > offset
                                            ? capacity7
                                            : offset
                                    );
                                offset -= 8;
                                var lo = value.low,
                                    hi = value.high;
                                if (this.littleEndian) {
                                    this.view[offset + 3] = (lo >>> 24) & 0xff;
                                    this.view[offset + 2] = (lo >>> 16) & 0xff;
                                    this.view[offset + 1] = (lo >>> 8) & 0xff;
                                    this.view[offset] = lo & 0xff;
                                    offset += 4;
                                    this.view[offset + 3] = (hi >>> 24) & 0xff;
                                    this.view[offset + 2] = (hi >>> 16) & 0xff;
                                    this.view[offset + 1] = (hi >>> 8) & 0xff;
                                    this.view[offset] = hi & 0xff;
                                } else {
                                    this.view[offset] = (hi >>> 24) & 0xff;
                                    this.view[offset + 1] = (hi >>> 16) & 0xff;
                                    this.view[offset + 2] = (hi >>> 8) & 0xff;
                                    this.view[offset + 3] = hi & 0xff;
                                    offset += 4;
                                    this.view[offset] = (lo >>> 24) & 0xff;
                                    this.view[offset + 1] = (lo >>> 16) & 0xff;
                                    this.view[offset + 2] = (lo >>> 8) & 0xff;
                                    this.view[offset + 3] = lo & 0xff;
                                }
                                if (relative) this.offset += 8;
                                return this;
                            };

                            /**
                             * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
                             * @function
                             * @param {number|!Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!ByteBuffer} this
                             * @expose
                             */
                            ByteBufferPrototype.writeUInt64 =
                                ByteBufferPrototype.writeUint64;

                            /**
                             * Reads a 64bit unsigned integer.
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!Long}
                             * @expose
                             */
                            ByteBufferPrototype.readUint64 = function(offset) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 8 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                8 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                var lo = 0,
                                    hi = 0;
                                if (this.littleEndian) {
                                    lo = this.view[offset + 2] << 16;
                                    lo |= this.view[offset + 1] << 8;
                                    lo |= this.view[offset];
                                    lo += (this.view[offset + 3] << 24) >>> 0;
                                    offset += 4;
                                    hi = this.view[offset + 2] << 16;
                                    hi |= this.view[offset + 1] << 8;
                                    hi |= this.view[offset];
                                    hi += (this.view[offset + 3] << 24) >>> 0;
                                } else {
                                    hi = this.view[offset + 1] << 16;
                                    hi |= this.view[offset + 2] << 8;
                                    hi |= this.view[offset + 3];
                                    hi += (this.view[offset] << 24) >>> 0;
                                    offset += 4;
                                    lo = this.view[offset + 1] << 16;
                                    lo |= this.view[offset + 2] << 8;
                                    lo |= this.view[offset + 3];
                                    lo += (this.view[offset] << 24) >>> 0;
                                }
                                var value = new Long(lo, hi, true);
                                if (relative) this.offset += 8;
                                return value;
                            };

                            /**
                             * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
                             * @function
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                             * @returns {!Long}
                             * @expose
                             */
                            ByteBufferPrototype.readUInt64 =
                                ByteBufferPrototype.readUint64;
                        } // Long

                        // types/floats/float32

                        /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

                        /**
                         * Reads an IEEE754 float from a byte array.
                         * @param {!Array} buffer
                         * @param {number} offset
                         * @param {boolean} isLE
                         * @param {number} mLen
                         * @param {number} nBytes
                         * @returns {number}
                         * @inner
                         */
                        function ieee754_read(
                            buffer,
                            offset,
                            isLE,
                            mLen,
                            nBytes
                        ) {
                            var e,
                                m,
                                eLen = nBytes * 8 - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                nBits = -7,
                                i = isLE ? nBytes - 1 : 0,
                                d = isLE ? -1 : 1,
                                s = buffer[offset + i];

                            i += d;

                            e = s & ((1 << -nBits) - 1);
                            s >>= -nBits;
                            nBits += eLen;
                            for (
                                ;
                                nBits > 0;
                                e = e * 256 + buffer[offset + i],
                                    i += d,
                                    nBits -= 8
                            ) {}

                            m = e & ((1 << -nBits) - 1);
                            e >>= -nBits;
                            nBits += mLen;
                            for (
                                ;
                                nBits > 0;
                                m = m * 256 + buffer[offset + i],
                                    i += d,
                                    nBits -= 8
                            ) {}

                            if (e === 0) {
                                e = 1 - eBias;
                            } else if (e === eMax) {
                                return m ? NaN : (s ? -1 : 1) * Infinity;
                            } else {
                                m = m + Math.pow(2, mLen);
                                e = e - eBias;
                            }
                            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                        }

                        /**
                         * Writes an IEEE754 float to a byte array.
                         * @param {!Array} buffer
                         * @param {number} value
                         * @param {number} offset
                         * @param {boolean} isLE
                         * @param {number} mLen
                         * @param {number} nBytes
                         * @inner
                         */
                        function ieee754_write(
                            buffer,
                            value,
                            offset,
                            isLE,
                            mLen,
                            nBytes
                        ) {
                            var e,
                                m,
                                c,
                                eLen = nBytes * 8 - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                rt =
                                    mLen === 23
                                        ? Math.pow(2, -24) - Math.pow(2, -77)
                                        : 0,
                                i = isLE ? 0 : nBytes - 1,
                                d = isLE ? 1 : -1,
                                s =
                                    value < 0 || (value === 0 && 1 / value < 0)
                                        ? 1
                                        : 0;

                            value = Math.abs(value);

                            if (isNaN(value) || value === Infinity) {
                                m = isNaN(value) ? 1 : 0;
                                e = eMax;
                            } else {
                                e = Math.floor(Math.log(value) / Math.LN2);
                                if (value * (c = Math.pow(2, -e)) < 1) {
                                    e--;
                                    c *= 2;
                                }
                                if (e + eBias >= 1) {
                                    value += rt / c;
                                } else {
                                    value += rt * Math.pow(2, 1 - eBias);
                                }
                                if (value * c >= 2) {
                                    e++;
                                    c /= 2;
                                }

                                if (e + eBias >= eMax) {
                                    m = 0;
                                    e = eMax;
                                } else if (e + eBias >= 1) {
                                    m = (value * c - 1) * Math.pow(2, mLen);
                                    e = e + eBias;
                                } else {
                                    m =
                                        value *
                                        Math.pow(2, eBias - 1) *
                                        Math.pow(2, mLen);
                                    e = 0;
                                }
                            }

                            for (
                                ;
                                mLen >= 8;
                                buffer[offset + i] = m & 0xff,
                                    i += d,
                                    m /= 256,
                                    mLen -= 8
                            ) {}

                            e = (e << mLen) | m;
                            eLen += mLen;
                            for (
                                ;
                                eLen > 0;
                                buffer[offset + i] = e & 0xff,
                                    i += d,
                                    e /= 256,
                                    eLen -= 8
                            ) {}

                            buffer[offset + i - d] |= s * 128;
                        }

                        /**
                         * Writes a 32bit float.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeFloat32 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (typeof value !== "number")
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not a number)"
                                    );
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 4;
                            var capacity8 = this.buffer.byteLength;
                            if (offset > capacity8)
                                this.resize(
                                    (capacity8 *= 2) > offset
                                        ? capacity8
                                        : offset
                                );
                            offset -= 4;
                            ieee754_write(
                                this.view,
                                value,
                                offset,
                                this.littleEndian,
                                23,
                                4
                            );
                            if (relative) this.offset += 4;
                            return this;
                        };

                        /**
                         * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeFloat =
                            ByteBufferPrototype.writeFloat32;

                        /**
                         * Reads a 32bit float.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number}
                         * @expose
                         */
                        ByteBufferPrototype.readFloat32 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 4 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            4 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = ieee754_read(
                                this.view,
                                offset,
                                this.littleEndian,
                                23,
                                4
                            );
                            if (relative) this.offset += 4;
                            return value;
                        };

                        /**
                         * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
                         * @returns {number}
                         * @expose
                         */
                        ByteBufferPrototype.readFloat =
                            ByteBufferPrototype.readFloat32;

                        // types/floats/float64

                        /**
                         * Writes a 64bit float.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeFloat64 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (typeof value !== "number")
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not a number)"
                                    );
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            offset += 8;
                            var capacity9 = this.buffer.byteLength;
                            if (offset > capacity9)
                                this.resize(
                                    (capacity9 *= 2) > offset
                                        ? capacity9
                                        : offset
                                );
                            offset -= 8;
                            ieee754_write(
                                this.view,
                                value,
                                offset,
                                this.littleEndian,
                                52,
                                8
                            );
                            if (relative) this.offset += 8;
                            return this;
                        };

                        /**
                         * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
                         * @function
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.writeDouble =
                            ByteBufferPrototype.writeFloat64;

                        /**
                         * Reads a 64bit float.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                         * @returns {number}
                         * @expose
                         */
                        ByteBufferPrototype.readFloat64 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 8 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            8 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var value = ieee754_read(
                                this.view,
                                offset,
                                this.littleEndian,
                                52,
                                8
                            );
                            if (relative) this.offset += 8;
                            return value;
                        };

                        /**
                         * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
                         * @function
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
                         * @returns {number}
                         * @expose
                         */
                        ByteBufferPrototype.readDouble =
                            ByteBufferPrototype.readFloat64;

                        // types/varints/varint32

                        /**
                         * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
                         * @type {number}
                         * @const
                         * @expose
                         */
                        ByteBuffer.MAX_VARINT32_BYTES = 5;

                        /**
                         * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
                         * @param {number} value Value to encode
                         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
                         * @expose
                         */
                        ByteBuffer.calculateVarint32 = function(value) {
                            // ref: src/google/protobuf/io/coded_stream.cc
                            value = value >>> 0;
                            if (value < 1 << 7) return 1;
                            else if (value < 1 << 14) return 2;
                            else if (value < 1 << 21) return 3;
                            else if (value < 1 << 28) return 4;
                            else return 5;
                        };

                        /**
                         * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
                         * @param {number} n Signed 32bit integer
                         * @returns {number} Unsigned zigzag encoded 32bit integer
                         * @expose
                         */
                        ByteBuffer.zigZagEncode32 = function(n) {
                            return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
                        };

                        /**
                         * Decodes a zigzag encoded signed 32bit integer.
                         * @param {number} n Unsigned zigzag encoded 32bit integer
                         * @returns {number} Signed 32bit integer
                         * @expose
                         */
                        ByteBuffer.zigZagDecode32 = function(n) {
                            return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
                        };

                        /**
                         * Writes a 32bit base 128 variable-length integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
                         * @expose
                         */
                        ByteBufferPrototype.writeVarint32 = function(
                            value,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value |= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var size = ByteBuffer.calculateVarint32(value),
                                b;
                            offset += size;
                            var capacity10 = this.buffer.byteLength;
                            if (offset > capacity10)
                                this.resize(
                                    (capacity10 *= 2) > offset
                                        ? capacity10
                                        : offset
                                );
                            offset -= size;
                            value >>>= 0;
                            while (value >= 0x80) {
                                b = (value & 0x7f) | 0x80;
                                this.view[offset++] = b;
                                value >>>= 7;
                            }
                            this.view[offset++] = value;
                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return size;
                        };

                        /**
                         * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
                         * @param {number} value Value to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
                         * @expose
                         */
                        ByteBufferPrototype.writeVarint32ZigZag = function(
                            value,
                            offset
                        ) {
                            return this.writeVarint32(
                                ByteBuffer.zigZagEncode32(value),
                                offset
                            );
                        };

                        /**
                         * Reads a 32bit base 128 variable-length integer.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
                         *  and the actual number of bytes read.
                         * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
                         *  to fully decode the varint.
                         * @expose
                         */
                        ByteBufferPrototype.readVarint32 = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 1 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            1 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var c = 0,
                                value = 0 >>> 0,
                                b;
                            do {
                                if (!this.noAssert && offset > this.limit) {
                                    var err = Error("Truncated");
                                    err["truncated"] = true;
                                    throw err;
                                }
                                b = this.view[offset++];
                                if (c < 5) value |= (b & 0x7f) << (7 * c);
                                ++c;
                            } while ((b & 0x80) !== 0);
                            value |= 0;
                            if (relative) {
                                this.offset = offset;
                                return value;
                            }
                            return {
                                value: value,
                                length: c
                            };
                        };

                        /**
                         * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
                         *  and the actual number of bytes read.
                         * @throws {Error} If it's not a valid varint
                         * @expose
                         */
                        ByteBufferPrototype.readVarint32ZigZag = function(
                            offset
                        ) {
                            var val = this.readVarint32(offset);
                            if (typeof val === "object")
                                val["value"] = ByteBuffer.zigZagDecode32(
                                    val["value"]
                                );
                            else val = ByteBuffer.zigZagDecode32(val);
                            return val;
                        };

                        // types/varints/varint64

                        if (Long) {
                            /**
                             * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
                             * @type {number}
                             * @const
                             * @expose
                             */
                            ByteBuffer.MAX_VARINT64_BYTES = 10;

                            /**
                             * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
                             * @param {number|!Long} value Value to encode
                             * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
                             * @expose
                             */
                            ByteBuffer.calculateVarint64 = function(value) {
                                if (typeof value === "number")
                                    value = Long.fromNumber(value);
                                else if (typeof value === "string")
                                    value = Long.fromString(value);
                                // ref: src/google/protobuf/io/coded_stream.cc
                                var part0 = value.toInt() >>> 0,
                                    part1 =
                                        value.shiftRightUnsigned(28).toInt() >>>
                                        0,
                                    part2 =
                                        value.shiftRightUnsigned(56).toInt() >>>
                                        0;
                                if (part2 == 0) {
                                    if (part1 == 0) {
                                        if (part0 < 1 << 14)
                                            return part0 < 1 << 7 ? 1 : 2;
                                        else return part0 < 1 << 21 ? 3 : 4;
                                    } else {
                                        if (part1 < 1 << 14)
                                            return part1 < 1 << 7 ? 5 : 6;
                                        else return part1 < 1 << 21 ? 7 : 8;
                                    }
                                } else return part2 < 1 << 7 ? 9 : 10;
                            };

                            /**
                             * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
                             * @param {number|!Long} value Signed long
                             * @returns {!Long} Unsigned zigzag encoded long
                             * @expose
                             */
                            ByteBuffer.zigZagEncode64 = function(value) {
                                if (typeof value === "number")
                                    value = Long.fromNumber(value, false);
                                else if (typeof value === "string")
                                    value = Long.fromString(value, false);
                                else if (value.unsigned !== false)
                                    value = value.toSigned();
                                // ref: src/google/protobuf/wire_format_lite.h
                                return value
                                    .shiftLeft(1)
                                    .xor(value.shiftRight(63))
                                    .toUnsigned();
                            };

                            /**
                             * Decodes a zigzag encoded signed 64bit integer.
                             * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
                             * @returns {!Long} Signed long
                             * @expose
                             */
                            ByteBuffer.zigZagDecode64 = function(value) {
                                if (typeof value === "number")
                                    value = Long.fromNumber(value, false);
                                else if (typeof value === "string")
                                    value = Long.fromString(value, false);
                                else if (value.unsigned !== false)
                                    value = value.toSigned();
                                // ref: src/google/protobuf/wire_format_lite.h
                                return value
                                    .shiftRightUnsigned(1)
                                    .xor(
                                        value
                                            .and(Long.ONE)
                                            .toSigned()
                                            .negate()
                                    )
                                    .toSigned();
                            };

                            /**
                             * Writes a 64bit base 128 variable-length integer.
                             * @param {number|Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                             *  written if omitted.
                             * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
                             * @expose
                             */
                            ByteBufferPrototype.writeVarint64 = function(
                                value,
                                offset
                            ) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (typeof value === "number")
                                        value = Long.fromNumber(value);
                                    else if (typeof value === "string")
                                        value = Long.fromString(value);
                                    else if (!(value && value instanceof Long))
                                        throw TypeError(
                                            "Illegal value: " +
                                                value +
                                                " (not an integer or Long)"
                                        );
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 0 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                0 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                if (typeof value === "number")
                                    value = Long.fromNumber(value, false);
                                else if (typeof value === "string")
                                    value = Long.fromString(value, false);
                                else if (value.unsigned !== false)
                                    value = value.toSigned();
                                var size = ByteBuffer.calculateVarint64(value),
                                    part0 = value.toInt() >>> 0,
                                    part1 =
                                        value.shiftRightUnsigned(28).toInt() >>>
                                        0,
                                    part2 =
                                        value.shiftRightUnsigned(56).toInt() >>>
                                        0;
                                offset += size;
                                var capacity11 = this.buffer.byteLength;
                                if (offset > capacity11)
                                    this.resize(
                                        (capacity11 *= 2) > offset
                                            ? capacity11
                                            : offset
                                    );
                                offset -= size;
                                switch (size) {
                                    case 10:
                                        this.view[offset + 9] =
                                            (part2 >>> 7) & 0x01;
                                    case 9:
                                        this.view[offset + 8] =
                                            size !== 9
                                                ? part2 | 0x80
                                                : part2 & 0x7f;
                                    case 8:
                                        this.view[offset + 7] =
                                            size !== 8
                                                ? (part1 >>> 21) | 0x80
                                                : (part1 >>> 21) & 0x7f;
                                    case 7:
                                        this.view[offset + 6] =
                                            size !== 7
                                                ? (part1 >>> 14) | 0x80
                                                : (part1 >>> 14) & 0x7f;
                                    case 6:
                                        this.view[offset + 5] =
                                            size !== 6
                                                ? (part1 >>> 7) | 0x80
                                                : (part1 >>> 7) & 0x7f;
                                    case 5:
                                        this.view[offset + 4] =
                                            size !== 5
                                                ? part1 | 0x80
                                                : part1 & 0x7f;
                                    case 4:
                                        this.view[offset + 3] =
                                            size !== 4
                                                ? (part0 >>> 21) | 0x80
                                                : (part0 >>> 21) & 0x7f;
                                    case 3:
                                        this.view[offset + 2] =
                                            size !== 3
                                                ? (part0 >>> 14) | 0x80
                                                : (part0 >>> 14) & 0x7f;
                                    case 2:
                                        this.view[offset + 1] =
                                            size !== 2
                                                ? (part0 >>> 7) | 0x80
                                                : (part0 >>> 7) & 0x7f;
                                    case 1:
                                        this.view[offset] =
                                            size !== 1
                                                ? part0 | 0x80
                                                : part0 & 0x7f;
                                }
                                if (relative) {
                                    this.offset += size;
                                    return this;
                                } else {
                                    return size;
                                }
                            };

                            /**
                             * Writes a zig-zag encoded 64bit base 128 variable-length integer.
                             * @param {number|Long} value Value to write
                             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                             *  written if omitted.
                             * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
                             * @expose
                             */
                            ByteBufferPrototype.writeVarint64ZigZag = function(
                                value,
                                offset
                            ) {
                                return this.writeVarint64(
                                    ByteBuffer.zigZagEncode64(value),
                                    offset
                                );
                            };

                            /**
                             * Reads a 64bit base 128 variable-length integer. Requires Long.js.
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                             *  read if omitted.
                             * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
                             *  the actual number of bytes read.
                             * @throws {Error} If it's not a valid varint
                             * @expose
                             */
                            ByteBufferPrototype.readVarint64 = function(
                                offset
                            ) {
                                var relative = typeof offset === "undefined";
                                if (relative) offset = this.offset;
                                if (!this.noAssert) {
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + 1 > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                1 +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                // ref: src/google/protobuf/io/coded_stream.cc
                                var start = offset,
                                    part0 = 0,
                                    part1 = 0,
                                    part2 = 0,
                                    b = 0;
                                b = this.view[offset++];
                                part0 = b & 0x7f;
                                if (b & 0x80) {
                                    b = this.view[offset++];
                                    part0 |= (b & 0x7f) << 7;
                                    if (
                                        b & 0x80 ||
                                        (this.noAssert &&
                                            typeof b === "undefined")
                                    ) {
                                        b = this.view[offset++];
                                        part0 |= (b & 0x7f) << 14;
                                        if (
                                            b & 0x80 ||
                                            (this.noAssert &&
                                                typeof b === "undefined")
                                        ) {
                                            b = this.view[offset++];
                                            part0 |= (b & 0x7f) << 21;
                                            if (
                                                b & 0x80 ||
                                                (this.noAssert &&
                                                    typeof b === "undefined")
                                            ) {
                                                b = this.view[offset++];
                                                part1 = b & 0x7f;
                                                if (
                                                    b & 0x80 ||
                                                    (this.noAssert &&
                                                        typeof b ===
                                                            "undefined")
                                                ) {
                                                    b = this.view[offset++];
                                                    part1 |= (b & 0x7f) << 7;
                                                    if (
                                                        b & 0x80 ||
                                                        (this.noAssert &&
                                                            typeof b ===
                                                                "undefined")
                                                    ) {
                                                        b = this.view[offset++];
                                                        part1 |=
                                                            (b & 0x7f) << 14;
                                                        if (
                                                            b & 0x80 ||
                                                            (this.noAssert &&
                                                                typeof b ===
                                                                    "undefined")
                                                        ) {
                                                            b = this.view[
                                                                offset++
                                                            ];
                                                            part1 |=
                                                                (b & 0x7f) <<
                                                                21;
                                                            if (
                                                                b & 0x80 ||
                                                                (this
                                                                    .noAssert &&
                                                                    typeof b ===
                                                                        "undefined")
                                                            ) {
                                                                b = this.view[
                                                                    offset++
                                                                ];
                                                                part2 =
                                                                    b & 0x7f;
                                                                if (
                                                                    b & 0x80 ||
                                                                    (this
                                                                        .noAssert &&
                                                                        typeof b ===
                                                                            "undefined")
                                                                ) {
                                                                    b = this
                                                                        .view[
                                                                        offset++
                                                                    ];
                                                                    part2 |=
                                                                        (b &
                                                                            0x7f) <<
                                                                        7;
                                                                    if (
                                                                        b &
                                                                            0x80 ||
                                                                        (this
                                                                            .noAssert &&
                                                                            typeof b ===
                                                                                "undefined")
                                                                    ) {
                                                                        throw Error(
                                                                            "Buffer overrun"
                                                                        );
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                var value = Long.fromBits(
                                    part0 | (part1 << 28),
                                    (part1 >>> 4) | (part2 << 24),
                                    false
                                );
                                if (relative) {
                                    this.offset = offset;
                                    return value;
                                } else {
                                    return {
                                        value: value,
                                        length: offset - start
                                    };
                                }
                            };

                            /**
                             * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
                             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                             *  read if omitted.
                             * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
                             *  the actual number of bytes read.
                             * @throws {Error} If it's not a valid varint
                             * @expose
                             */
                            ByteBufferPrototype.readVarint64ZigZag = function(
                                offset
                            ) {
                                var val = this.readVarint64(offset);
                                if (val && val["value"] instanceof Long)
                                    val["value"] = ByteBuffer.zigZagDecode64(
                                        val["value"]
                                    );
                                else val = ByteBuffer.zigZagDecode64(val);
                                return val;
                            };
                        } // Long

                        // types/strings/cstring

                        /**
                         * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
                         *  characters itself.
                         * @param {string} str String to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  contained in `str` + 1 if omitted.
                         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
                         * @expose
                         */
                        ByteBufferPrototype.writeCString = function(
                            str,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            var i,
                                k = str.length;
                            if (!this.noAssert) {
                                if (typeof str !== "string")
                                    throw TypeError(
                                        "Illegal str: Not a string"
                                    );
                                for (i = 0; i < k; ++i) {
                                    if (str.charCodeAt(i) === 0)
                                        throw RangeError(
                                            "Illegal str: Contains NULL-characters"
                                        );
                                }
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            // UTF8 strings do not contain zero bytes in between except for the zero character, so:
                            k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
                            offset += k + 1;
                            var capacity12 = this.buffer.byteLength;
                            if (offset > capacity12)
                                this.resize(
                                    (capacity12 *= 2) > offset
                                        ? capacity12
                                        : offset
                                );
                            offset -= k + 1;
                            utfx.encodeUTF16toUTF8(
                                stringSource(str),
                                function(b) {
                                    this.view[offset++] = b;
                                }.bind(this)
                            );
                            this.view[offset++] = 0;
                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return k;
                        };

                        /**
                         * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
                         *  itself.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  read if omitted.
                         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
                         *  read and the actual number of bytes read.
                         * @expose
                         */
                        ByteBufferPrototype.readCString = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 1 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            1 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var start = offset,
                                temp;
                            // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
                            var sd,
                                b = -1;
                            utfx.decodeUTF8toUTF16(
                                function() {
                                    if (b === 0) return null;
                                    if (offset >= this.limit)
                                        throw RangeError(
                                            "Illegal range: Truncated data, " +
                                                offset +
                                                " < " +
                                                this.limit
                                        );
                                    b = this.view[offset++];
                                    return b === 0 ? null : b;
                                }.bind(this),
                                (sd = stringDestination()),
                                true
                            );
                            if (relative) {
                                this.offset = offset;
                                return sd();
                            } else {
                                return {
                                    string: sd(),
                                    length: offset - start
                                };
                            }
                        };

                        // types/strings/istring

                        /**
                         * Writes a length as uint32 prefixed UTF8 encoded string.
                         * @param {string} str String to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
                         * @expose
                         * @see ByteBuffer#writeVarint32
                         */
                        ByteBufferPrototype.writeIString = function(
                            str,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (typeof str !== "string")
                                    throw TypeError(
                                        "Illegal str: Not a string"
                                    );
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var start = offset,
                                k;
                            k = utfx.calculateUTF16asUTF8(
                                stringSource(str),
                                this.noAssert
                            )[1];
                            offset += 4 + k;
                            var capacity13 = this.buffer.byteLength;
                            if (offset > capacity13)
                                this.resize(
                                    (capacity13 *= 2) > offset
                                        ? capacity13
                                        : offset
                                );
                            offset -= 4 + k;
                            if (this.littleEndian) {
                                this.view[offset + 3] = (k >>> 24) & 0xff;
                                this.view[offset + 2] = (k >>> 16) & 0xff;
                                this.view[offset + 1] = (k >>> 8) & 0xff;
                                this.view[offset] = k & 0xff;
                            } else {
                                this.view[offset] = (k >>> 24) & 0xff;
                                this.view[offset + 1] = (k >>> 16) & 0xff;
                                this.view[offset + 2] = (k >>> 8) & 0xff;
                                this.view[offset + 3] = k & 0xff;
                            }
                            offset += 4;
                            utfx.encodeUTF16toUTF8(
                                stringSource(str),
                                function(b) {
                                    this.view[offset++] = b;
                                }.bind(this)
                            );
                            if (offset !== start + 4 + k)
                                throw RangeError(
                                    "Illegal range: Truncated data, " +
                                        offset +
                                        " == " +
                                        (offset + 4 + k)
                                );
                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return offset - start;
                        };

                        /**
                         * Reads a length as uint32 prefixed UTF8 encoded string.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  read if omitted.
                         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
                         *  read and the actual number of bytes read.
                         * @expose
                         * @see ByteBuffer#readVarint32
                         */
                        ByteBufferPrototype.readIString = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 4 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            4 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var start = offset;
                            var len = this.readUint32(offset);
                            var str = this.readUTF8String(
                                len,
                                ByteBuffer.METRICS_BYTES,
                                (offset += 4)
                            );
                            offset += str["length"];
                            if (relative) {
                                this.offset = offset;
                                return str["string"];
                            } else {
                                return {
                                    string: str["string"],
                                    length: offset - start
                                };
                            }
                        };

                        // types/strings/utf8string

                        /**
                         * Metrics representing number of UTF8 characters. Evaluates to `c`.
                         * @type {string}
                         * @const
                         * @expose
                         */
                        ByteBuffer.METRICS_CHARS = "c";

                        /**
                         * Metrics representing number of bytes. Evaluates to `b`.
                         * @type {string}
                         * @const
                         * @expose
                         */
                        ByteBuffer.METRICS_BYTES = "b";

                        /**
                         * Writes an UTF8 encoded string.
                         * @param {string} str String to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
                         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
                         * @expose
                         */
                        ByteBufferPrototype.writeUTF8String = function(
                            str,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var k;
                            var start = offset;
                            k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
                            offset += k;
                            var capacity14 = this.buffer.byteLength;
                            if (offset > capacity14)
                                this.resize(
                                    (capacity14 *= 2) > offset
                                        ? capacity14
                                        : offset
                                );
                            offset -= k;
                            utfx.encodeUTF16toUTF8(
                                stringSource(str),
                                function(b) {
                                    this.view[offset++] = b;
                                }.bind(this)
                            );
                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return offset - start;
                        };

                        /**
                         * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
                         * @function
                         * @param {string} str String to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
                         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
                         * @expose
                         */
                        ByteBufferPrototype.writeString =
                            ByteBufferPrototype.writeUTF8String;

                        /**
                         * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
                         *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
                         * @param {string} str String to calculate
                         * @returns {number} Number of UTF8 characters
                         * @expose
                         */
                        ByteBuffer.calculateUTF8Chars = function(str) {
                            return utfx.calculateUTF16asUTF8(
                                stringSource(str)
                            )[0];
                        };

                        /**
                         * Calculates the number of UTF8 bytes of a string.
                         * @param {string} str String to calculate
                         * @returns {number} Number of UTF8 bytes
                         * @expose
                         */
                        ByteBuffer.calculateUTF8Bytes = function(str) {
                            return utfx.calculateUTF16asUTF8(
                                stringSource(str)
                            )[1];
                        };

                        /**
                         * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
                         * @function
                         * @param {string} str String to calculate
                         * @returns {number} Number of UTF8 bytes
                         * @expose
                         */
                        ByteBuffer.calculateString =
                            ByteBuffer.calculateUTF8Bytes;

                        /**
                         * Reads an UTF8 encoded string.
                         * @param {number} length Number of characters or bytes to read.
                         * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
                         *  {@link ByteBuffer.METRICS_CHARS}.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  read if omitted.
                         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
                         *  read and the actual number of bytes read.
                         * @expose
                         */
                        ByteBufferPrototype.readUTF8String = function(
                            length,
                            metrics,
                            offset
                        ) {
                            if (typeof metrics === "number") {
                                offset = metrics;
                                metrics = undefined;
                            }
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (typeof metrics === "undefined")
                                metrics = ByteBuffer.METRICS_CHARS;
                            if (!this.noAssert) {
                                if (
                                    typeof length !== "number" ||
                                    length % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal length: " +
                                            length +
                                            " (not an integer)"
                                    );
                                length |= 0;
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var i = 0,
                                start = offset,
                                sd;
                            if (metrics === ByteBuffer.METRICS_CHARS) {
                                // The same for node and the browser
                                sd = stringDestination();
                                utfx.decodeUTF8(
                                    function() {
                                        return i < length && offset < this.limit
                                            ? this.view[offset++]
                                            : null;
                                    }.bind(this),
                                    function(cp) {
                                        ++i;
                                        utfx.UTF8toUTF16(cp, sd);
                                    }
                                );
                                if (i !== length)
                                    throw RangeError(
                                        "Illegal range: Truncated data, " +
                                            i +
                                            " == " +
                                            length
                                    );
                                if (relative) {
                                    this.offset = offset;
                                    return sd();
                                } else {
                                    return {
                                        string: sd(),
                                        length: offset - start
                                    };
                                }
                            } else if (metrics === ByteBuffer.METRICS_BYTES) {
                                if (!this.noAssert) {
                                    if (
                                        typeof offset !== "number" ||
                                        offset % 1 !== 0
                                    )
                                        throw TypeError(
                                            "Illegal offset: " +
                                                offset +
                                                " (not an integer)"
                                        );
                                    offset >>>= 0;
                                    if (
                                        offset < 0 ||
                                        offset + length > this.buffer.byteLength
                                    )
                                        throw RangeError(
                                            "Illegal offset: 0 <= " +
                                                offset +
                                                " (+" +
                                                length +
                                                ") <= " +
                                                this.buffer.byteLength
                                        );
                                }
                                var k = offset + length;
                                utfx.decodeUTF8toUTF16(
                                    function() {
                                        return offset < k
                                            ? this.view[offset++]
                                            : null;
                                    }.bind(this),
                                    (sd = stringDestination()),
                                    this.noAssert
                                );
                                if (offset !== k)
                                    throw RangeError(
                                        "Illegal range: Truncated data, " +
                                            offset +
                                            " == " +
                                            k
                                    );
                                if (relative) {
                                    this.offset = offset;
                                    return sd();
                                } else {
                                    return {
                                        string: sd(),
                                        length: offset - start
                                    };
                                }
                            } else
                                throw TypeError(
                                    "Unsupported metrics: " + metrics
                                );
                        };

                        /**
                         * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
                         * @function
                         * @param {number} length Number of characters or bytes to read
                         * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
                         *  {@link ByteBuffer.METRICS_CHARS}.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  read if omitted.
                         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
                         *  read and the actual number of bytes read.
                         * @expose
                         */
                        ByteBufferPrototype.readString =
                            ByteBufferPrototype.readUTF8String;

                        // types/strings/vstring

                        /**
                         * Writes a length as varint32 prefixed UTF8 encoded string.
                         * @param {string} str String to write
                         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
                         * @expose
                         * @see ByteBuffer#writeVarint32
                         */
                        ByteBufferPrototype.writeVString = function(
                            str,
                            offset
                        ) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (typeof str !== "string")
                                    throw TypeError(
                                        "Illegal str: Not a string"
                                    );
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var start = offset,
                                k,
                                l;
                            k = utfx.calculateUTF16asUTF8(
                                stringSource(str),
                                this.noAssert
                            )[1];
                            l = ByteBuffer.calculateVarint32(k);
                            offset += l + k;
                            var capacity15 = this.buffer.byteLength;
                            if (offset > capacity15)
                                this.resize(
                                    (capacity15 *= 2) > offset
                                        ? capacity15
                                        : offset
                                );
                            offset -= l + k;
                            offset += this.writeVarint32(k, offset);
                            utfx.encodeUTF16toUTF8(
                                stringSource(str),
                                function(b) {
                                    this.view[offset++] = b;
                                }.bind(this)
                            );
                            if (offset !== start + k + l)
                                throw RangeError(
                                    "Illegal range: Truncated data, " +
                                        offset +
                                        " == " +
                                        (offset + k + l)
                                );
                            if (relative) {
                                this.offset = offset;
                                return this;
                            }
                            return offset - start;
                        };

                        /**
                         * Reads a length as varint32 prefixed UTF8 encoded string.
                         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  read if omitted.
                         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
                         *  read and the actual number of bytes read.
                         * @expose
                         * @see ByteBuffer#readVarint32
                         */
                        ByteBufferPrototype.readVString = function(offset) {
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 1 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            1 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var start = offset;
                            var len = this.readVarint32(offset);
                            var str = this.readUTF8String(
                                len["value"],
                                ByteBuffer.METRICS_BYTES,
                                (offset += len["length"])
                            );
                            offset += str["length"];
                            if (relative) {
                                this.offset = offset;
                                return str["string"];
                            } else {
                                return {
                                    string: str["string"],
                                    length: offset - start
                                };
                            }
                        };

                        /**
                         * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
                         *  data's length.
                         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
                         *  will be modified according to the performed read operation.
                         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
                         * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
                         * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
                         */
                        ByteBufferPrototype.append = function(
                            source,
                            encoding,
                            offset
                        ) {
                            if (
                                typeof encoding === "number" ||
                                typeof encoding !== "string"
                            ) {
                                offset = encoding;
                                encoding = undefined;
                            }
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (!(source instanceof ByteBuffer))
                                source = ByteBuffer.wrap(source, encoding);
                            var length = source.limit - source.offset;
                            if (length <= 0) return this; // Nothing to append
                            offset += length;
                            var capacity16 = this.buffer.byteLength;
                            if (offset > capacity16)
                                this.resize(
                                    (capacity16 *= 2) > offset
                                        ? capacity16
                                        : offset
                                );
                            offset -= length;
                            this.view.set(
                                source.view.subarray(
                                    source.offset,
                                    source.limit
                                ),
                                offset
                            );
                            source.offset += length;
                            if (relative) this.offset += length;
                            return this;
                        };

                        /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
                        ByteBufferPrototype.appendTo = function(
                            target,
                            offset
                        ) {
                            target.append(this, offset);
                            return this;
                        };

                        /**
                         * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
                         *  disable them if your code already makes sure that everything is valid.
                         * @param {boolean} assert `true` to enable assertions, otherwise `false`
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.assert = function(assert) {
                            this.noAssert = !assert;
                            return this;
                        };

                        /**
                         * Gets the capacity of this ByteBuffer's backing buffer.
                         * @returns {number} Capacity of the backing buffer
                         * @expose
                         */
                        ByteBufferPrototype.capacity = function() {
                            return this.buffer.byteLength;
                        };
                        /**
                         * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
                         *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.clear = function() {
                            this.offset = 0;
                            this.limit = this.buffer.byteLength;
                            this.markedOffset = -1;
                            return this;
                        };

                        /**
                         * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
                         *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
                         * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
                         * @returns {!ByteBuffer} Cloned instance
                         * @expose
                         */
                        ByteBufferPrototype.clone = function(copy) {
                            var bb = new ByteBuffer(
                                0,
                                this.littleEndian,
                                this.noAssert
                            );
                            if (copy) {
                                bb.buffer = new ArrayBuffer(
                                    this.buffer.byteLength
                                );
                                bb.view = new Uint8Array(bb.buffer);
                            } else {
                                bb.buffer = this.buffer;
                                bb.view = this.view;
                            }
                            bb.offset = this.offset;
                            bb.markedOffset = this.markedOffset;
                            bb.limit = this.limit;
                            return bb;
                        };

                        /**
                         * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
                         *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
                         *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
                         * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
                         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.compact = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (begin === 0 && end === this.buffer.byteLength)
                                return this; // Already compacted
                            var len = end - begin;
                            if (len === 0) {
                                this.buffer = EMPTY_BUFFER;
                                this.view = null;
                                if (this.markedOffset >= 0)
                                    this.markedOffset -= begin;
                                this.offset = 0;
                                this.limit = 0;
                                return this;
                            }
                            var buffer = new ArrayBuffer(len);
                            var view = new Uint8Array(buffer);
                            view.set(this.view.subarray(begin, end));
                            this.buffer = buffer;
                            this.view = view;
                            if (this.markedOffset >= 0)
                                this.markedOffset -= begin;
                            this.offset = 0;
                            this.limit = len;
                            return this;
                        };

                        /**
                         * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
                         *  {@link ByteBuffer#limit}.
                         * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
                         * @returns {!ByteBuffer} Copy
                         * @expose
                         */
                        ByteBufferPrototype.copy = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (begin === end)
                                return new ByteBuffer(
                                    0,
                                    this.littleEndian,
                                    this.noAssert
                                );
                            var capacity = end - begin,
                                bb = new ByteBuffer(
                                    capacity,
                                    this.littleEndian,
                                    this.noAssert
                                );
                            bb.offset = 0;
                            bb.limit = capacity;
                            if (bb.markedOffset >= 0) bb.markedOffset -= begin;
                            this.copyTo(bb, 0, begin, end);
                            return bb;
                        };

                        /**
                         * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
                         *  {@link ByteBuffer#limit}.
                         * @param {!ByteBuffer} target Target ByteBuffer
                         * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
                         *  by the number of bytes copied if omitted.
                         * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
                         *  number of bytes copied if omitted.
                         * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.copyTo = function(
                            target,
                            targetOffset,
                            sourceOffset,
                            sourceLimit
                        ) {
                            var relative, targetRelative;
                            if (!this.noAssert) {
                                if (!ByteBuffer.isByteBuffer(target))
                                    throw TypeError(
                                        "Illegal target: Not a ByteBuffer"
                                    );
                            }
                            targetOffset = (targetRelative =
                                typeof targetOffset === "undefined")
                                ? target.offset
                                : targetOffset | 0;
                            sourceOffset = (relative =
                                typeof sourceOffset === "undefined")
                                ? this.offset
                                : sourceOffset | 0;
                            sourceLimit =
                                typeof sourceLimit === "undefined"
                                    ? this.limit
                                    : sourceLimit | 0;

                            if (
                                targetOffset < 0 ||
                                targetOffset > target.buffer.byteLength
                            )
                                throw RangeError(
                                    "Illegal target range: 0 <= " +
                                        targetOffset +
                                        " <= " +
                                        target.buffer.byteLength
                                );
                            if (
                                sourceOffset < 0 ||
                                sourceLimit > this.buffer.byteLength
                            )
                                throw RangeError(
                                    "Illegal source range: 0 <= " +
                                        sourceOffset +
                                        " <= " +
                                        this.buffer.byteLength
                                );

                            var len = sourceLimit - sourceOffset;
                            if (len === 0) return target; // Nothing to copy

                            target.ensureCapacity(targetOffset + len);

                            target.view.set(
                                this.view.subarray(sourceOffset, sourceLimit),
                                targetOffset
                            );

                            if (relative) this.offset += len;
                            if (targetRelative) target.offset += len;

                            return this;
                        };

                        /**
                         * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
                         *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
                         *  the required capacity will be used instead.
                         * @param {number} capacity Required capacity
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.ensureCapacity = function(
                            capacity
                        ) {
                            var current = this.buffer.byteLength;
                            if (current < capacity)
                                return this.resize(
                                    (current *= 2) > capacity
                                        ? current
                                        : capacity
                                );
                            return this;
                        };

                        /**
                         * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
                         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
                         * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
                         * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
                         *  written if omitted. defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
                         * @returns {!ByteBuffer} this
                         * @expose
                         * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
                         */
                        ByteBufferPrototype.fill = function(value, begin, end) {
                            var relative = typeof begin === "undefined";
                            if (relative) begin = this.offset;
                            if (typeof value === "string" && value.length > 0)
                                value = value.charCodeAt(0);
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof value !== "number" ||
                                    value % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal value: " +
                                            value +
                                            " (not an integer)"
                                    );
                                value |= 0;
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (begin >= end) return this; // Nothing to fill
                            while (begin < end) this.view[begin++] = value;
                            if (relative) this.offset = begin;
                            return this;
                        };

                        /**
                         * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
                         *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.flip = function() {
                            this.limit = this.offset;
                            this.offset = 0;
                            return this;
                        };
                        /**
                         * Marks an offset on this ByteBuffer to be used later.
                         * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
                         * @returns {!ByteBuffer} this
                         * @throws {TypeError} If `offset` is not a valid number
                         * @throws {RangeError} If `offset` is out of bounds
                         * @see ByteBuffer#reset
                         * @expose
                         */
                        ByteBufferPrototype.mark = function(offset) {
                            offset =
                                typeof offset === "undefined"
                                    ? this.offset
                                    : offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            this.markedOffset = offset;
                            return this;
                        };
                        /**
                         * Sets the byte order.
                         * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.order = function(littleEndian) {
                            if (!this.noAssert) {
                                if (typeof littleEndian !== "boolean")
                                    throw TypeError(
                                        "Illegal littleEndian: Not a boolean"
                                    );
                            }
                            this.littleEndian = !!littleEndian;
                            return this;
                        };

                        /**
                         * Switches (to) little endian byte order.
                         * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.LE = function(littleEndian) {
                            this.littleEndian =
                                typeof littleEndian !== "undefined"
                                    ? !!littleEndian
                                    : true;
                            return this;
                        };

                        /**
                         * Switches (to) big endian byte order.
                         * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.BE = function(bigEndian) {
                            this.littleEndian =
                                typeof bigEndian !== "undefined"
                                    ? !bigEndian
                                    : false;
                            return this;
                        };
                        /**
                         * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
                         *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
                         *  will be resized and its contents moved accordingly.
                         * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
                         *  modified according to the performed read operation.
                         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
                         * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
                         *  prepended if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
                         * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
                         */
                        ByteBufferPrototype.prepend = function(
                            source,
                            encoding,
                            offset
                        ) {
                            if (
                                typeof encoding === "number" ||
                                typeof encoding !== "string"
                            ) {
                                offset = encoding;
                                encoding = undefined;
                            }
                            var relative = typeof offset === "undefined";
                            if (relative) offset = this.offset;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: " +
                                            offset +
                                            " (not an integer)"
                                    );
                                offset >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset + 0 > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal offset: 0 <= " +
                                            offset +
                                            " (+" +
                                            0 +
                                            ") <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (!(source instanceof ByteBuffer))
                                source = ByteBuffer.wrap(source, encoding);
                            var len = source.limit - source.offset;
                            if (len <= 0) return this; // Nothing to prepend
                            var diff = len - offset;
                            if (diff > 0) {
                                // Not enough space before offset, so resize + move
                                var buffer = new ArrayBuffer(
                                    this.buffer.byteLength + diff
                                );
                                var view = new Uint8Array(buffer);
                                view.set(
                                    this.view.subarray(
                                        offset,
                                        this.buffer.byteLength
                                    ),
                                    len
                                );
                                this.buffer = buffer;
                                this.view = view;
                                this.offset += diff;
                                if (this.markedOffset >= 0)
                                    this.markedOffset += diff;
                                this.limit += diff;
                                offset += diff;
                            } else {
                                var arrayView = new Uint8Array(this.buffer);
                            }
                            this.view.set(
                                source.view.subarray(
                                    source.offset,
                                    source.limit
                                ),
                                offset - len
                            );

                            source.offset = source.limit;
                            if (relative) this.offset -= len;
                            return this;
                        };

                        /**
                         * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
                         *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
                         *  will be resized and its contents moved accordingly.
                         * @param {!ByteBuffer} target Target ByteBuffer
                         * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
                         *  prepended if omitted.
                         * @returns {!ByteBuffer} this
                         * @expose
                         * @see ByteBuffer#prepend
                         */
                        ByteBufferPrototype.prependTo = function(
                            target,
                            offset
                        ) {
                            target.prepend(this, offset);
                            return this;
                        };
                        /**
                         * Prints debug information about this ByteBuffer's contents.
                         * @param {function(string)=} out Output function to call, defaults to console.log
                         * @expose
                         */
                        ByteBufferPrototype.printDebug = function(out) {
                            if (typeof out !== "function")
                                out = console.log.bind(console);
                            out(
                                this.toString() +
                                    "\n" +
                                    "-------------------------------------------------------------------\n" +
                                    this.toDebug(/* columns */ true)
                            );
                        };

                        /**
                         * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
                         *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
                         * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
                         * @expose
                         */
                        ByteBufferPrototype.remaining = function() {
                            return this.limit - this.offset;
                        };
                        /**
                         * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
                         *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
                         *  marked, sets `offset = 0`.
                         * @returns {!ByteBuffer} this
                         * @see ByteBuffer#mark
                         * @expose
                         */
                        ByteBufferPrototype.reset = function() {
                            if (this.markedOffset >= 0) {
                                this.offset = this.markedOffset;
                                this.markedOffset = -1;
                            } else {
                                this.offset = 0;
                            }
                            return this;
                        };
                        /**
                         * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
                         *  large or larger.
                         * @param {number} capacity Capacity required
                         * @returns {!ByteBuffer} this
                         * @throws {TypeError} If `capacity` is not a number
                         * @throws {RangeError} If `capacity < 0`
                         * @expose
                         */
                        ByteBufferPrototype.resize = function(capacity) {
                            if (!this.noAssert) {
                                if (
                                    typeof capacity !== "number" ||
                                    capacity % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal capacity: " +
                                            capacity +
                                            " (not an integer)"
                                    );
                                capacity |= 0;
                                if (capacity < 0)
                                    throw RangeError(
                                        "Illegal capacity: 0 <= " + capacity
                                    );
                            }
                            if (this.buffer.byteLength < capacity) {
                                var buffer = new ArrayBuffer(capacity);
                                var view = new Uint8Array(buffer);
                                view.set(this.view);
                                this.buffer = buffer;
                                this.view = view;
                            }
                            return this;
                        };
                        /**
                         * Reverses this ByteBuffer's contents.
                         * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
                         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.reverse = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            if (begin === end) return this; // Nothing to reverse
                            Array.prototype.reverse.call(
                                this.view.subarray(begin, end)
                            );
                            return this;
                        };
                        /**
                         * Skips the next `length` bytes. This will just advance
                         * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
                         * @returns {!ByteBuffer} this
                         * @expose
                         */
                        ByteBufferPrototype.skip = function(length) {
                            if (!this.noAssert) {
                                if (
                                    typeof length !== "number" ||
                                    length % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal length: " +
                                            length +
                                            " (not an integer)"
                                    );
                                length |= 0;
                            }
                            var offset = this.offset + length;
                            if (!this.noAssert) {
                                if (
                                    offset < 0 ||
                                    offset > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal length: 0 <= " +
                                            this.offset +
                                            " + " +
                                            length +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            this.offset = offset;
                            return this;
                        };

                        /**
                         * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
                         * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
                         * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
                         * @expose
                         */
                        ByteBufferPrototype.slice = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var bb = this.clone();
                            bb.offset = begin;
                            bb.limit = end;
                            return bb;
                        };
                        /**
                         * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
                         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
                         * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
                         *  possible. Defaults to `false`
                         * @returns {!ArrayBuffer} Contents as an ArrayBuffer
                         * @expose
                         */
                        ByteBufferPrototype.toBuffer = function(forceCopy) {
                            var offset = this.offset,
                                limit = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof offset !== "number" ||
                                    offset % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal offset: Not an integer"
                                    );
                                offset >>>= 0;
                                if (
                                    typeof limit !== "number" ||
                                    limit % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal limit: Not an integer"
                                    );
                                limit >>>= 0;
                                if (
                                    offset < 0 ||
                                    offset > limit ||
                                    limit > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            offset +
                                            " <= " +
                                            limit +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
                            // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
                            if (
                                !forceCopy &&
                                offset === 0 &&
                                limit === this.buffer.byteLength
                            )
                                return this.buffer;
                            if (offset === limit) return EMPTY_BUFFER;
                            var buffer = new ArrayBuffer(limit - offset);
                            new Uint8Array(buffer).set(
                                new Uint8Array(this.buffer).subarray(
                                    offset,
                                    limit
                                ),
                                0
                            );
                            return buffer;
                        };

                        /**
                         * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
                         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
                         * @function
                         * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
                         *  Defaults to `false`
                         * @returns {!ArrayBuffer} Contents as an ArrayBuffer
                         * @expose
                         */
                        ByteBufferPrototype.toArrayBuffer =
                            ByteBufferPrototype.toBuffer;

                        /**
                         * Converts the ByteBuffer's contents to a string.
                         * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
                         *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
                         *  highlighted offsets.
                         * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
                         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
                         * @returns {string} String representation
                         * @throws {Error} If `encoding` is invalid
                         * @expose
                         */
                        ByteBufferPrototype.toString = function(
                            encoding,
                            begin,
                            end
                        ) {
                            if (typeof encoding === "undefined")
                                return (
                                    "ByteBufferAB(offset=" +
                                    this.offset +
                                    ",markedOffset=" +
                                    this.markedOffset +
                                    ",limit=" +
                                    this.limit +
                                    ",capacity=" +
                                    this.capacity() +
                                    ")"
                                );
                            if (typeof encoding === "number")
                                (encoding = "utf8"),
                                    (begin = encoding),
                                    (end = begin);
                            switch (encoding) {
                                case "utf8":
                                    return this.toUTF8(begin, end);
                                case "base64":
                                    return this.toBase64(begin, end);
                                case "hex":
                                    return this.toHex(begin, end);
                                case "binary":
                                    return this.toBinary(begin, end);
                                case "debug":
                                    return this.toDebug();
                                case "columns":
                                    return this.toColumns();
                                default:
                                    throw Error(
                                        "Unsupported encoding: " + encoding
                                    );
                            }
                        };

                        // lxiv-embeddable

                        /**
                         * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
                         * Released under the Apache License, Version 2.0
                         * see: https://github.com/dcodeIO/lxiv for details
                         */
                        var lxiv = (function() {
                            "use strict";

                            /**
                             * lxiv namespace.
                             * @type {!Object.<string,*>}
                             * @exports lxiv
                             */
                            var lxiv = {};

                            /**
                             * Character codes for output.
                             * @type {!Array.<number>}
                             * @inner
                             */
                            var aout = [
                                65,
                                66,
                                67,
                                68,
                                69,
                                70,
                                71,
                                72,
                                73,
                                74,
                                75,
                                76,
                                77,
                                78,
                                79,
                                80,
                                81,
                                82,
                                83,
                                84,
                                85,
                                86,
                                87,
                                88,
                                89,
                                90,
                                97,
                                98,
                                99,
                                100,
                                101,
                                102,
                                103,
                                104,
                                105,
                                106,
                                107,
                                108,
                                109,
                                110,
                                111,
                                112,
                                113,
                                114,
                                115,
                                116,
                                117,
                                118,
                                119,
                                120,
                                121,
                                122,
                                48,
                                49,
                                50,
                                51,
                                52,
                                53,
                                54,
                                55,
                                56,
                                57,
                                43,
                                47
                            ];

                            /**
                             * Character codes for input.
                             * @type {!Array.<number>}
                             * @inner
                             */
                            var ain = [];
                            for (var i = 0, k = aout.length; i < k; ++i)
                                ain[aout[i]] = i;

                            /**
                             * Encodes bytes to base64 char codes.
                             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
                             *  there are no more bytes left.
                             * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
                             *  code.
                             */
                            lxiv.encode = function(src, dst) {
                                var b, t;
                                while ((b = src()) !== null) {
                                    dst(aout[(b >> 2) & 0x3f]);
                                    t = (b & 0x3) << 4;
                                    if ((b = src()) !== null) {
                                        t |= (b >> 4) & 0xf;
                                        dst(
                                            aout[(t | ((b >> 4) & 0xf)) & 0x3f]
                                        );
                                        t = (b & 0xf) << 2;
                                        if ((b = src()) !== null)
                                            dst(
                                                aout[
                                                    (t | ((b >> 6) & 0x3)) &
                                                        0x3f
                                                ]
                                            ),
                                                dst(aout[b & 0x3f]);
                                        else dst(aout[t & 0x3f]), dst(61);
                                    } else
                                        dst(aout[t & 0x3f]), dst(61), dst(61);
                                }
                            };

                            /**
                             * Decodes base64 char codes to bytes.
                             * @param {!function():number|null} src Characters source as a function returning the next char code respectively
                             *  `null` if there are no more characters left.
                             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
                             * @throws {Error} If a character code is invalid
                             */
                            lxiv.decode = function(src, dst) {
                                var c, t1, t2;
                                function fail(c) {
                                    throw Error("Illegal character code: " + c);
                                }
                                while ((c = src()) !== null) {
                                    t1 = ain[c];
                                    if (typeof t1 === "undefined") fail(c);
                                    if ((c = src()) !== null) {
                                        t2 = ain[c];
                                        if (typeof t2 === "undefined") fail(c);
                                        dst(
                                            ((t1 << 2) >>> 0) |
                                                ((t2 & 0x30) >> 4)
                                        );
                                        if ((c = src()) !== null) {
                                            t1 = ain[c];
                                            if (typeof t1 === "undefined")
                                                if (c === 61) break;
                                                else fail(c);
                                            dst(
                                                (((t2 & 0xf) << 4) >>> 0) |
                                                    ((t1 & 0x3c) >> 2)
                                            );
                                            if ((c = src()) !== null) {
                                                t2 = ain[c];
                                                if (typeof t2 === "undefined")
                                                    if (c === 61) break;
                                                    else fail(c);
                                                dst(
                                                    (((t1 & 0x3) << 6) >>> 0) |
                                                        t2
                                                );
                                            }
                                        }
                                    }
                                }
                            };

                            /**
                             * Tests if a string is valid base64.
                             * @param {string} str String to test
                             * @returns {boolean} `true` if valid, otherwise `false`
                             */
                            lxiv.test = function(str) {
                                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
                                    str
                                );
                            };

                            return lxiv;
                        })();

                        // encodings/base64

                        /**
                         * Encodes this ByteBuffer's contents to a base64 encoded string.
                         * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
                         * @returns {string} Base64 encoded string
                         * @throws {RangeError} If `begin` or `end` is out of bounds
                         * @expose
                         */
                        ByteBufferPrototype.toBase64 = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            begin = begin | 0;
                            end = end | 0;
                            if (begin < 0 || end > this.capacity || begin > end)
                                throw RangeError("begin, end");
                            var sd;
                            lxiv.encode(
                                function() {
                                    return begin < end
                                        ? this.view[begin++]
                                        : null;
                                }.bind(this),
                                (sd = stringDestination())
                            );
                            return sd();
                        };

                        /**
                         * Decodes a base64 encoded string to a ByteBuffer.
                         * @param {string} str String to decode
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @returns {!ByteBuffer} ByteBuffer
                         * @expose
                         */
                        ByteBuffer.fromBase64 = function(str, littleEndian) {
                            if (typeof str !== "string") throw TypeError("str");
                            var bb = new ByteBuffer(
                                    str.length / 4 * 3,
                                    littleEndian
                                ),
                                i = 0;
                            lxiv.decode(stringSource(str), function(b) {
                                bb.view[i++] = b;
                            });
                            bb.limit = i;
                            return bb;
                        };

                        /**
                         * Encodes a binary string to base64 like `window.btoa` does.
                         * @param {string} str Binary string
                         * @returns {string} Base64 encoded string
                         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
                         * @expose
                         */
                        ByteBuffer.btoa = function(str) {
                            return ByteBuffer.fromBinary(str).toBase64();
                        };

                        /**
                         * Decodes a base64 encoded string to binary like `window.atob` does.
                         * @param {string} b64 Base64 encoded string
                         * @returns {string} Binary string
                         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
                         * @expose
                         */
                        ByteBuffer.atob = function(b64) {
                            return ByteBuffer.fromBase64(b64).toBinary();
                        };

                        // encodings/binary

                        /**
                         * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
                         * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
                         * @returns {string} Binary encoded string
                         * @throws {RangeError} If `offset > limit`
                         * @expose
                         */
                        ByteBufferPrototype.toBinary = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            begin |= 0;
                            end |= 0;
                            if (
                                begin < 0 ||
                                end > this.capacity() ||
                                begin > end
                            )
                                throw RangeError("begin, end");
                            if (begin === end) return "";
                            var chars = [],
                                parts = [];
                            while (begin < end) {
                                chars.push(this.view[begin++]);
                                if (chars.length >= 1024)
                                    parts.push(
                                        String.fromCharCode.apply(String, chars)
                                    ),
                                        (chars = []);
                            }
                            return (
                                parts.join("") +
                                String.fromCharCode.apply(String, chars)
                            );
                        };

                        /**
                         * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
                         * @param {string} str String to decode
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @returns {!ByteBuffer} ByteBuffer
                         * @expose
                         */
                        ByteBuffer.fromBinary = function(str, littleEndian) {
                            if (typeof str !== "string") throw TypeError("str");
                            var i = 0,
                                k = str.length,
                                charCode,
                                bb = new ByteBuffer(k, littleEndian);
                            while (i < k) {
                                charCode = str.charCodeAt(i);
                                if (charCode > 0xff)
                                    throw RangeError(
                                        "illegal char code: " + charCode
                                    );
                                bb.view[i++] = charCode;
                            }
                            bb.limit = k;
                            return bb;
                        };

                        // encodings/debug

                        /**
                         * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
                         * * `<` : offset,
                         * * `'` : markedOffset,
                         * * `>` : limit,
                         * * `|` : offset and limit,
                         * * `[` : offset and markedOffset,
                         * * `]` : markedOffset and limit,
                         * * `!` : offset, markedOffset and limit
                         * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
                         * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
                         * @expose
                         * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
                         * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
                         * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
                         * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
                         */
                        ByteBufferPrototype.toDebug = function(columns) {
                            var i = -1,
                                k = this.buffer.byteLength,
                                b,
                                hex = "",
                                asc = "",
                                out = "";
                            while (i < k) {
                                if (i !== -1) {
                                    b = this.view[i];
                                    if (b < 0x10)
                                        hex +=
                                            "0" + b.toString(16).toUpperCase();
                                    else hex += b.toString(16).toUpperCase();
                                    if (columns)
                                        asc +=
                                            b > 32 && b < 127
                                                ? String.fromCharCode(b)
                                                : ".";
                                }
                                ++i;
                                if (columns) {
                                    if (i > 0 && i % 16 === 0 && i !== k) {
                                        while (hex.length < 3 * 16 + 3)
                                            hex += " ";
                                        out += hex + asc + "\n";
                                        hex = asc = "";
                                    }
                                }
                                if (i === this.offset && i === this.limit)
                                    hex += i === this.markedOffset ? "!" : "|";
                                else if (i === this.offset)
                                    hex += i === this.markedOffset ? "[" : "<";
                                else if (i === this.limit)
                                    hex += i === this.markedOffset ? "]" : ">";
                                else
                                    hex +=
                                        i === this.markedOffset
                                            ? "'"
                                            : columns || (i !== 0 && i !== k)
                                                ? " "
                                                : "";
                            }
                            if (columns && hex !== " ") {
                                while (hex.length < 3 * 16 + 3) hex += " ";
                                out += hex + asc + "\n";
                            }
                            return columns ? out : hex;
                        };

                        /**
                         * Decodes a hex encoded string with marked offsets to a ByteBuffer.
                         * @param {string} str Debug string to decode (not be generated with `columns = true`)
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer} ByteBuffer
                         * @expose
                         * @see ByteBuffer#toDebug
                         */
                        ByteBuffer.fromDebug = function(
                            str,
                            littleEndian,
                            noAssert
                        ) {
                            var k = str.length,
                                bb = new ByteBuffer(
                                    ((k + 1) / 3) | 0,
                                    littleEndian,
                                    noAssert
                                );
                            var i = 0,
                                j = 0,
                                ch,
                                b,
                                rs = false, // Require symbol next
                                ho = false,
                                hm = false,
                                hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
                                fail = false;
                            while (i < k) {
                                switch ((ch = str.charAt(i++))) {
                                    case "!":
                                        if (!noAssert) {
                                            if (ho || hm || hl) {
                                                fail = true;
                                                break;
                                            }
                                            ho = hm = hl = true;
                                        }
                                        bb.offset = bb.markedOffset = bb.limit = j;
                                        rs = false;
                                        break;
                                    case "|":
                                        if (!noAssert) {
                                            if (ho || hl) {
                                                fail = true;
                                                break;
                                            }
                                            ho = hl = true;
                                        }
                                        bb.offset = bb.limit = j;
                                        rs = false;
                                        break;
                                    case "[":
                                        if (!noAssert) {
                                            if (ho || hm) {
                                                fail = true;
                                                break;
                                            }
                                            ho = hm = true;
                                        }
                                        bb.offset = bb.markedOffset = j;
                                        rs = false;
                                        break;
                                    case "<":
                                        if (!noAssert) {
                                            if (ho) {
                                                fail = true;
                                                break;
                                            }
                                            ho = true;
                                        }
                                        bb.offset = j;
                                        rs = false;
                                        break;
                                    case "]":
                                        if (!noAssert) {
                                            if (hl || hm) {
                                                fail = true;
                                                break;
                                            }
                                            hl = hm = true;
                                        }
                                        bb.limit = bb.markedOffset = j;
                                        rs = false;
                                        break;
                                    case ">":
                                        if (!noAssert) {
                                            if (hl) {
                                                fail = true;
                                                break;
                                            }
                                            hl = true;
                                        }
                                        bb.limit = j;
                                        rs = false;
                                        break;
                                    case "'":
                                        if (!noAssert) {
                                            if (hm) {
                                                fail = true;
                                                break;
                                            }
                                            hm = true;
                                        }
                                        bb.markedOffset = j;
                                        rs = false;
                                        break;
                                    case " ":
                                        rs = false;
                                        break;
                                    default:
                                        if (!noAssert) {
                                            if (rs) {
                                                fail = true;
                                                break;
                                            }
                                        }
                                        b = parseInt(ch + str.charAt(i++), 16);
                                        if (!noAssert) {
                                            if (isNaN(b) || b < 0 || b > 255)
                                                throw TypeError(
                                                    "Illegal str: Not a debug encoded string"
                                                );
                                        }
                                        bb.view[j++] = b;
                                        rs = true;
                                }
                                if (fail)
                                    throw TypeError(
                                        "Illegal str: Invalid symbol at " + i
                                    );
                            }
                            if (!noAssert) {
                                if (!ho || !hl)
                                    throw TypeError(
                                        "Illegal str: Missing offset or limit"
                                    );
                                if (j < bb.buffer.byteLength)
                                    throw TypeError(
                                        "Illegal str: Not a debug encoded string (is it hex?) " +
                                            j +
                                            " < " +
                                            k
                                    );
                            }
                            return bb;
                        };

                        // encodings/hex

                        /**
                         * Encodes this ByteBuffer's contents to a hex encoded string.
                         * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
                         * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
                         * @returns {string} Hex encoded string
                         * @expose
                         */
                        ByteBufferPrototype.toHex = function(begin, end) {
                            begin =
                                typeof begin === "undefined"
                                    ? this.offset
                                    : begin;
                            end = typeof end === "undefined" ? this.limit : end;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var out = new Array(end - begin),
                                b;
                            while (begin < end) {
                                b = this.view[begin++];
                                if (b < 0x10) out.push("0", b.toString(16));
                                else out.push(b.toString(16));
                            }
                            return out.join("");
                        };

                        /**
                         * Decodes a hex encoded string to a ByteBuffer.
                         * @param {string} str String to decode
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer} ByteBuffer
                         * @expose
                         */
                        ByteBuffer.fromHex = function(
                            str,
                            littleEndian,
                            noAssert
                        ) {
                            if (!noAssert) {
                                if (typeof str !== "string")
                                    throw TypeError(
                                        "Illegal str: Not a string"
                                    );
                                if (str.length % 2 !== 0)
                                    throw TypeError(
                                        "Illegal str: Length not a multiple of 2"
                                    );
                            }
                            var k = str.length,
                                bb = new ByteBuffer((k / 2) | 0, littleEndian),
                                b;
                            for (var i = 0, j = 0; i < k; i += 2) {
                                b = parseInt(str.substring(i, i + 2), 16);
                                if (!noAssert)
                                    if (!isFinite(b) || b < 0 || b > 255)
                                        throw TypeError(
                                            "Illegal str: Contains non-hex characters"
                                        );
                                bb.view[j++] = b;
                            }
                            bb.limit = j;
                            return bb;
                        };

                        // utfx-embeddable

                        /**
                         * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
                         * Released under the Apache License, Version 2.0
                         * see: https://github.com/dcodeIO/utfx for details
                         */
                        var utfx = (function() {
                            "use strict";

                            /**
                             * utfx namespace.
                             * @inner
                             * @type {!Object.<string,*>}
                             */
                            var utfx = {};

                            /**
                             * Maximum valid code point.
                             * @type {number}
                             * @const
                             */
                            utfx.MAX_CODEPOINT = 0x10ffff;

                            /**
                             * Encodes UTF8 code points to UTF8 bytes.
                             * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
                             *  respectively `null` if there are no more code points left or a single numeric code point.
                             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
                             */
                            utfx.encodeUTF8 = function(src, dst) {
                                var cp = null;
                                if (typeof src === "number")
                                    (cp = src),
                                        (src = function() {
                                            return null;
                                        });
                                while (cp !== null || (cp = src()) !== null) {
                                    if (cp < 0x80) dst(cp & 0x7f);
                                    else if (cp < 0x800)
                                        dst(((cp >> 6) & 0x1f) | 0xc0),
                                            dst((cp & 0x3f) | 0x80);
                                    else if (cp < 0x10000)
                                        dst(((cp >> 12) & 0x0f) | 0xe0),
                                            dst(((cp >> 6) & 0x3f) | 0x80),
                                            dst((cp & 0x3f) | 0x80);
                                    else
                                        dst(((cp >> 18) & 0x07) | 0xf0),
                                            dst(((cp >> 12) & 0x3f) | 0x80),
                                            dst(((cp >> 6) & 0x3f) | 0x80),
                                            dst((cp & 0x3f) | 0x80);
                                    cp = null;
                                }
                            };

                            /**
                             * Decodes UTF8 bytes to UTF8 code points.
                             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
                             *  are no more bytes left.
                             * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
                             * @throws {RangeError} If a starting byte is invalid in UTF8
                             * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
                             *  remaining bytes.
                             */
                            utfx.decodeUTF8 = function(src, dst) {
                                var a,
                                    b,
                                    c,
                                    d,
                                    fail = function(b) {
                                        b = b.slice(0, b.indexOf(null));
                                        var err = Error(b.toString());
                                        err.name = "TruncatedError";
                                        err["bytes"] = b;
                                        throw err;
                                    };
                                while ((a = src()) !== null) {
                                    if ((a & 0x80) === 0) dst(a);
                                    else if ((a & 0xe0) === 0xc0)
                                        (b = src()) === null && fail([a, b]),
                                            dst(((a & 0x1f) << 6) | (b & 0x3f));
                                    else if ((a & 0xf0) === 0xe0)
                                        ((b = src()) === null ||
                                            (c = src()) === null) &&
                                            fail([a, b, c]),
                                            dst(
                                                ((a & 0x0f) << 12) |
                                                    ((b & 0x3f) << 6) |
                                                    (c & 0x3f)
                                            );
                                    else if ((a & 0xf8) === 0xf0)
                                        ((b = src()) === null ||
                                            (c = src()) === null ||
                                            (d = src()) === null) &&
                                            fail([a, b, c, d]),
                                            dst(
                                                ((a & 0x07) << 18) |
                                                    ((b & 0x3f) << 12) |
                                                    ((c & 0x3f) << 6) |
                                                    (d & 0x3f)
                                            );
                                    else
                                        throw RangeError(
                                            "Illegal starting byte: " + a
                                        );
                                }
                            };

                            /**
                             * Converts UTF16 characters to UTF8 code points.
                             * @param {!function():number|null} src Characters source as a function returning the next char code respectively
                             *  `null` if there are no more characters left.
                             * @param {!function(number)} dst Code points destination as a function successively called with each converted code
                             *  point.
                             */
                            utfx.UTF16toUTF8 = function(src, dst) {
                                var c1,
                                    c2 = null;
                                while (true) {
                                    if (
                                        (c1 = c2 !== null ? c2 : src()) === null
                                    )
                                        break;
                                    if (c1 >= 0xd800 && c1 <= 0xdfff) {
                                        if ((c2 = src()) !== null) {
                                            if (c2 >= 0xdc00 && c2 <= 0xdfff) {
                                                dst(
                                                    (c1 - 0xd800) * 0x400 +
                                                        c2 -
                                                        0xdc00 +
                                                        0x10000
                                                );
                                                c2 = null;
                                                continue;
                                            }
                                        }
                                    }
                                    dst(c1);
                                }
                                if (c2 !== null) dst(c2);
                            };

                            /**
                             * Converts UTF8 code points to UTF16 characters.
                             * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
                             *  respectively `null` if there are no more code points left or a single numeric code point.
                             * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
                             * @throws {RangeError} If a code point is out of range
                             */
                            utfx.UTF8toUTF16 = function(src, dst) {
                                var cp = null;
                                if (typeof src === "number")
                                    (cp = src),
                                        (src = function() {
                                            return null;
                                        });
                                while (cp !== null || (cp = src()) !== null) {
                                    if (cp <= 0xffff) dst(cp);
                                    else
                                        (cp -= 0x10000),
                                            dst((cp >> 10) + 0xd800),
                                            dst(cp % 0x400 + 0xdc00);
                                    cp = null;
                                }
                            };

                            /**
                             * Converts and encodes UTF16 characters to UTF8 bytes.
                             * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
                             *  if there are no more characters left.
                             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
                             */
                            utfx.encodeUTF16toUTF8 = function(src, dst) {
                                utfx.UTF16toUTF8(src, function(cp) {
                                    utfx.encodeUTF8(cp, dst);
                                });
                            };

                            /**
                             * Decodes and converts UTF8 bytes to UTF16 characters.
                             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
                             *  are no more bytes left.
                             * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
                             * @throws {RangeError} If a starting byte is invalid in UTF8
                             * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
                             */
                            utfx.decodeUTF8toUTF16 = function(src, dst) {
                                utfx.decodeUTF8(src, function(cp) {
                                    utfx.UTF8toUTF16(cp, dst);
                                });
                            };

                            /**
                             * Calculates the byte length of an UTF8 code point.
                             * @param {number} cp UTF8 code point
                             * @returns {number} Byte length
                             */
                            utfx.calculateCodePoint = function(cp) {
                                return cp < 0x80
                                    ? 1
                                    : cp < 0x800
                                        ? 2
                                        : cp < 0x10000
                                            ? 3
                                            : 4;
                            };

                            /**
                             * Calculates the number of UTF8 bytes required to store UTF8 code points.
                             * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
                             *  `null` if there are no more code points left.
                             * @returns {number} The number of UTF8 bytes required
                             */
                            utfx.calculateUTF8 = function(src) {
                                var cp,
                                    l = 0;
                                while ((cp = src()) !== null)
                                    l +=
                                        cp < 0x80
                                            ? 1
                                            : cp < 0x800
                                                ? 2
                                                : cp < 0x10000
                                                    ? 3
                                                    : 4;
                                return l;
                            };

                            /**
                             * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
                             * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
                             *  `null` if there are no more characters left.
                             * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
                             */
                            utfx.calculateUTF16asUTF8 = function(src) {
                                var n = 0,
                                    l = 0;
                                utfx.UTF16toUTF8(src, function(cp) {
                                    ++n;
                                    l +=
                                        cp < 0x80
                                            ? 1
                                            : cp < 0x800
                                                ? 2
                                                : cp < 0x10000
                                                    ? 3
                                                    : 4;
                                });
                                return [n, l];
                            };

                            return utfx;
                        })();

                        // encodings/utf8

                        /**
                         * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
                         *  string.
                         * @returns {string} Hex encoded string
                         * @throws {RangeError} If `offset > limit`
                         * @expose
                         */
                        ByteBufferPrototype.toUTF8 = function(begin, end) {
                            if (typeof begin === "undefined")
                                begin = this.offset;
                            if (typeof end === "undefined") end = this.limit;
                            if (!this.noAssert) {
                                if (
                                    typeof begin !== "number" ||
                                    begin % 1 !== 0
                                )
                                    throw TypeError(
                                        "Illegal begin: Not an integer"
                                    );
                                begin >>>= 0;
                                if (typeof end !== "number" || end % 1 !== 0)
                                    throw TypeError(
                                        "Illegal end: Not an integer"
                                    );
                                end >>>= 0;
                                if (
                                    begin < 0 ||
                                    begin > end ||
                                    end > this.buffer.byteLength
                                )
                                    throw RangeError(
                                        "Illegal range: 0 <= " +
                                            begin +
                                            " <= " +
                                            end +
                                            " <= " +
                                            this.buffer.byteLength
                                    );
                            }
                            var sd;
                            try {
                                utfx.decodeUTF8toUTF16(
                                    function() {
                                        return begin < end
                                            ? this.view[begin++]
                                            : null;
                                    }.bind(this),
                                    (sd = stringDestination())
                                );
                            } catch (e) {
                                if (begin !== end)
                                    throw RangeError(
                                        "Illegal range: Truncated data, " +
                                            begin +
                                            " != " +
                                            end
                                    );
                            }
                            return sd();
                        };

                        /**
                         * Decodes an UTF8 encoded string to a ByteBuffer.
                         * @param {string} str String to decode
                         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
                         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
                         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
                         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
                         * @returns {!ByteBuffer} ByteBuffer
                         * @expose
                         */
                        ByteBuffer.fromUTF8 = function(
                            str,
                            littleEndian,
                            noAssert
                        ) {
                            if (!noAssert)
                                if (typeof str !== "string")
                                    throw TypeError(
                                        "Illegal str: Not a string"
                                    );
                            var bb = new ByteBuffer(
                                    utfx.calculateUTF16asUTF8(
                                        stringSource(str),
                                        true
                                    )[1],
                                    littleEndian,
                                    noAssert
                                ),
                                i = 0;
                            utfx.encodeUTF16toUTF8(stringSource(str), function(
                                b
                            ) {
                                bb.view[i++] = b;
                            });
                            bb.limit = i;
                            return bb;
                        };

                        return ByteBuffer;
                    });
                },
                {
                    long:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/long/dist/long.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/cipher-base/index.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        var Transform = require("stream").Transform;
                        var inherits = require("inherits");
                        var StringDecoder = require("string_decoder")
                            .StringDecoder;
                        module.exports = CipherBase;
                        inherits(CipherBase, Transform);
                        function CipherBase(hashMode) {
                            Transform.call(this);
                            this.hashMode = typeof hashMode === "string";
                            if (this.hashMode) {
                                this[hashMode] = this._finalOrDigest;
                            } else {
                                this.final = this._finalOrDigest;
                            }
                            this._decoder = null;
                            this._encoding = null;
                        }
                        CipherBase.prototype.update = function(
                            data,
                            inputEnc,
                            outputEnc
                        ) {
                            if (typeof data === "string") {
                                data = new Buffer(data, inputEnc);
                            }
                            var outData = this._update(data);
                            if (this.hashMode) {
                                return this;
                            }
                            if (outputEnc) {
                                outData = this._toString(outData, outputEnc);
                            }
                            return outData;
                        };

                        CipherBase.prototype.setAutoPadding = function() {};

                        CipherBase.prototype.getAuthTag = function() {
                            throw new Error(
                                "trying to get auth tag in unsupported state"
                            );
                        };

                        CipherBase.prototype.setAuthTag = function() {
                            throw new Error(
                                "trying to set auth tag in unsupported state"
                            );
                        };

                        CipherBase.prototype.setAAD = function() {
                            throw new Error(
                                "trying to set aad in unsupported state"
                            );
                        };

                        CipherBase.prototype._transform = function(
                            data,
                            _,
                            next
                        ) {
                            var err;
                            try {
                                if (this.hashMode) {
                                    this._update(data);
                                } else {
                                    this.push(this._update(data));
                                }
                            } catch (e) {
                                err = e;
                            } finally {
                                next(err);
                            }
                        };
                        CipherBase.prototype._flush = function(done) {
                            var err;
                            try {
                                this.push(this._final());
                            } catch (e) {
                                err = e;
                            } finally {
                                done(err);
                            }
                        };
                        CipherBase.prototype._finalOrDigest = function(
                            outputEnc
                        ) {
                            var outData = this._final() || new Buffer("");
                            if (outputEnc) {
                                outData = this._toString(
                                    outData,
                                    outputEnc,
                                    true
                                );
                            }
                            return outData;
                        };

                        CipherBase.prototype._toString = function(
                            value,
                            enc,
                            fin
                        ) {
                            if (!this._decoder) {
                                this._decoder = new StringDecoder(enc);
                                this._encoding = enc;
                            }
                            if (this._encoding !== enc) {
                                throw new Error("can't switch encodings");
                            }
                            var out = this._decoder.write(value);
                            if (fin) {
                                out += this._decoder.end();
                            }
                            return out;
                        };
                    }.call(this, require("buffer").Buffer));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    stream:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/stream-browserify/index.js",
                    string_decoder:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browserify/node_modules/string_decoder/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        // Copyright Joyent, Inc. and other Node contributors.
                        //
                        // Permission is hereby granted, free of charge, to any person obtaining a
                        // copy of this software and associated documentation files (the
                        // "Software"), to deal in the Software without restriction, including
                        // without limitation the rights to use, copy, modify, merge, publish,
                        // distribute, sublicense, and/or sell copies of the Software, and to permit
                        // persons to whom the Software is furnished to do so, subject to the
                        // following conditions:
                        //
                        // The above copyright notice and this permission notice shall be included
                        // in all copies or substantial portions of the Software.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                        // USE OR OTHER DEALINGS IN THE SOFTWARE.

                        // NOTE: These type checking functions intentionally don't use `instanceof`
                        // because it is fragile and can be easily faked with `Object.create()`.

                        function isArray(arg) {
                            if (Array.isArray) {
                                return Array.isArray(arg);
                            }
                            return objectToString(arg) === "[object Array]";
                        }
                        exports.isArray = isArray;

                        function isBoolean(arg) {
                            return typeof arg === "boolean";
                        }
                        exports.isBoolean = isBoolean;

                        function isNull(arg) {
                            return arg === null;
                        }
                        exports.isNull = isNull;

                        function isNullOrUndefined(arg) {
                            return arg == null;
                        }
                        exports.isNullOrUndefined = isNullOrUndefined;

                        function isNumber(arg) {
                            return typeof arg === "number";
                        }
                        exports.isNumber = isNumber;

                        function isString(arg) {
                            return typeof arg === "string";
                        }
                        exports.isString = isString;

                        function isSymbol(arg) {
                            return typeof arg === "symbol";
                        }
                        exports.isSymbol = isSymbol;

                        function isUndefined(arg) {
                            return arg === void 0;
                        }
                        exports.isUndefined = isUndefined;

                        function isRegExp(re) {
                            return objectToString(re) === "[object RegExp]";
                        }
                        exports.isRegExp = isRegExp;

                        function isObject(arg) {
                            return typeof arg === "object" && arg !== null;
                        }
                        exports.isObject = isObject;

                        function isDate(d) {
                            return objectToString(d) === "[object Date]";
                        }
                        exports.isDate = isDate;

                        function isError(e) {
                            return (
                                objectToString(e) === "[object Error]" ||
                                e instanceof Error
                            );
                        }
                        exports.isError = isError;

                        function isFunction(arg) {
                            return typeof arg === "function";
                        }
                        exports.isFunction = isFunction;

                        function isPrimitive(arg) {
                            return (
                                arg === null ||
                                typeof arg === "boolean" ||
                                typeof arg === "number" ||
                                typeof arg === "string" ||
                                typeof arg === "symbol" || // ES6 symbol
                                typeof arg === "undefined"
                            );
                        }
                        exports.isPrimitive = isPrimitive;

                        exports.isBuffer = Buffer.isBuffer;

                        function objectToString(o) {
                            return Object.prototype.toString.call(o);
                        }
                    }.call(this, {
                        isBuffer: require("../../is-buffer/index.js")
                    }));
                },
                {
                    "../../is-buffer/index.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/is-buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hash/browser.js": [
                function(require, module, exports) {
                    "use strict";
                    var inherits = require("inherits");
                    var MD5 = require("md5.js");
                    var RIPEMD160 = require("ripemd160");
                    var sha = require("sha.js");
                    var Base = require("cipher-base");

                    function Hash(hash) {
                        Base.call(this, "digest");

                        this._hash = hash;
                    }

                    inherits(Hash, Base);

                    Hash.prototype._update = function(data) {
                        this._hash.update(data);
                    };

                    Hash.prototype._final = function() {
                        return this._hash.digest();
                    };

                    module.exports = function createHash(alg) {
                        alg = alg.toLowerCase();
                        if (alg === "md5") return new MD5();
                        if (alg === "rmd160" || alg === "ripemd160")
                            return new RIPEMD160();

                        return new Hash(sha(alg));
                    };
                },
                {
                    "cipher-base":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/cipher-base/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "md5.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/md5.js/index.js",
                    ripemd160:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ripemd160/index.js",
                    "sha.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hash/md5.js": [
                function(require, module, exports) {
                    var MD5 = require("md5.js");

                    module.exports = function(buffer) {
                        return new MD5().update(buffer).digest();
                    };
                },
                {
                    "md5.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/md5.js/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hmac/browser.js": [
                function(require, module, exports) {
                    "use strict";
                    var inherits = require("inherits");
                    var Legacy = require("./legacy");
                    var Base = require("cipher-base");
                    var Buffer = require("safe-buffer").Buffer;
                    var md5 = require("create-hash/md5");
                    var RIPEMD160 = require("ripemd160");

                    var sha = require("sha.js");

                    var ZEROS = Buffer.alloc(128);

                    function Hmac(alg, key) {
                        Base.call(this, "digest");
                        if (typeof key === "string") {
                            key = Buffer.from(key);
                        }

                        var blocksize =
                            alg === "sha512" || alg === "sha384" ? 128 : 64;

                        this._alg = alg;
                        this._key = key;
                        if (key.length > blocksize) {
                            var hash =
                                alg === "rmd160" ? new RIPEMD160() : sha(alg);
                            key = hash.update(key).digest();
                        } else if (key.length < blocksize) {
                            key = Buffer.concat([key, ZEROS], blocksize);
                        }

                        var ipad = (this._ipad = Buffer.allocUnsafe(blocksize));
                        var opad = (this._opad = Buffer.allocUnsafe(blocksize));

                        for (var i = 0; i < blocksize; i++) {
                            ipad[i] = key[i] ^ 0x36;
                            opad[i] = key[i] ^ 0x5c;
                        }
                        this._hash =
                            alg === "rmd160" ? new RIPEMD160() : sha(alg);
                        this._hash.update(ipad);
                    }

                    inherits(Hmac, Base);

                    Hmac.prototype._update = function(data) {
                        this._hash.update(data);
                    };

                    Hmac.prototype._final = function() {
                        var h = this._hash.digest();
                        var hash =
                            this._alg === "rmd160"
                                ? new RIPEMD160()
                                : sha(this._alg);
                        return hash
                            .update(this._opad)
                            .update(h)
                            .digest();
                    };

                    module.exports = function createHmac(alg, key) {
                        alg = alg.toLowerCase();
                        if (alg === "rmd160" || alg === "ripemd160") {
                            return new Hmac("rmd160", key);
                        }
                        if (alg === "md5") {
                            return new Legacy(md5, key);
                        }
                        return new Hmac(alg, key);
                    };
                },
                {
                    "./legacy":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hmac/legacy.js",
                    "cipher-base":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/cipher-base/index.js",
                    "create-hash/md5":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hash/md5.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    ripemd160:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ripemd160/index.js",
                    "safe-buffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js",
                    "sha.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/create-hmac/legacy.js": [
                function(require, module, exports) {
                    "use strict";
                    var inherits = require("inherits");
                    var Buffer = require("safe-buffer").Buffer;

                    var Base = require("cipher-base");

                    var ZEROS = Buffer.alloc(128);
                    var blocksize = 64;

                    function Hmac(alg, key) {
                        Base.call(this, "digest");
                        if (typeof key === "string") {
                            key = Buffer.from(key);
                        }

                        this._alg = alg;
                        this._key = key;

                        if (key.length > blocksize) {
                            key = alg(key);
                        } else if (key.length < blocksize) {
                            key = Buffer.concat([key, ZEROS], blocksize);
                        }

                        var ipad = (this._ipad = Buffer.allocUnsafe(blocksize));
                        var opad = (this._opad = Buffer.allocUnsafe(blocksize));

                        for (var i = 0; i < blocksize; i++) {
                            ipad[i] = key[i] ^ 0x36;
                            opad[i] = key[i] ^ 0x5c;
                        }

                        this._hash = [ipad];
                    }

                    inherits(Hmac, Base);

                    Hmac.prototype._update = function(data) {
                        this._hash.push(data);
                    };

                    Hmac.prototype._final = function() {
                        var h = this._alg(Buffer.concat(this._hash));
                        return this._alg(Buffer.concat([this._opad, h]));
                    };
                    module.exports = Hmac;
                },
                {
                    "cipher-base":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/cipher-base/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "safe-buffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/aes.js": [
                function(require, module, exports) {
                    (function(root, factory, undef) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core"),
                                require("./enc-base64"),
                                require("./md5"),
                                require("./evpkdf"),
                                require("./cipher-core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define([
                                "./core",
                                "./enc-base64",
                                "./md5",
                                "./evpkdf",
                                "./cipher-core"
                            ], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function() {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var BlockCipher = C_lib.BlockCipher;
                            var C_algo = C.algo;

                            // Lookup tables
                            var SBOX = [];
                            var INV_SBOX = [];
                            var SUB_MIX_0 = [];
                            var SUB_MIX_1 = [];
                            var SUB_MIX_2 = [];
                            var SUB_MIX_3 = [];
                            var INV_SUB_MIX_0 = [];
                            var INV_SUB_MIX_1 = [];
                            var INV_SUB_MIX_2 = [];
                            var INV_SUB_MIX_3 = [];

                            // Compute lookup tables
                            (function() {
                                // Compute double table
                                var d = [];
                                for (var i = 0; i < 256; i++) {
                                    if (i < 128) {
                                        d[i] = i << 1;
                                    } else {
                                        d[i] = (i << 1) ^ 0x11b;
                                    }
                                }

                                // Walk GF(2^8)
                                var x = 0;
                                var xi = 0;
                                for (var i = 0; i < 256; i++) {
                                    // Compute sbox
                                    var sx =
                                        xi ^
                                        (xi << 1) ^
                                        (xi << 2) ^
                                        (xi << 3) ^
                                        (xi << 4);
                                    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                                    SBOX[x] = sx;
                                    INV_SBOX[sx] = x;

                                    // Compute multiplication
                                    var x2 = d[x];
                                    var x4 = d[x2];
                                    var x8 = d[x4];

                                    // Compute sub bytes, mix columns tables
                                    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                                    SUB_MIX_0[x] = (t << 24) | (t >>> 8);
                                    SUB_MIX_1[x] = (t << 16) | (t >>> 16);
                                    SUB_MIX_2[x] = (t << 8) | (t >>> 24);
                                    SUB_MIX_3[x] = t;

                                    // Compute inv sub bytes, inv mix columns tables
                                    var t =
                                        (x8 * 0x1010101) ^
                                        (x4 * 0x10001) ^
                                        (x2 * 0x101) ^
                                        (x * 0x1010100);
                                    INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
                                    INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
                                    INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
                                    INV_SUB_MIX_3[sx] = t;

                                    // Compute next counter
                                    if (!x) {
                                        x = xi = 1;
                                    } else {
                                        x = x2 ^ d[d[d[x8 ^ x2]]];
                                        xi ^= d[d[xi]];
                                    }
                                }
                            })();

                            // Precomputed Rcon lookup
                            var RCON = [
                                0x00,
                                0x01,
                                0x02,
                                0x04,
                                0x08,
                                0x10,
                                0x20,
                                0x40,
                                0x80,
                                0x1b,
                                0x36
                            ];

                            /**
                             * AES block cipher algorithm.
                             */
                            var AES = (C_algo.AES = BlockCipher.extend({
                                _doReset: function() {
                                    // Skip reset of nRounds has been set before and key did not change
                                    if (
                                        this._nRounds &&
                                        this._keyPriorReset === this._key
                                    ) {
                                        return;
                                    }

                                    // Shortcuts
                                    var key = (this._keyPriorReset = this._key);
                                    var keyWords = key.words;
                                    var keySize = key.sigBytes / 4;

                                    // Compute number of rounds
                                    var nRounds = (this._nRounds = keySize + 6);

                                    // Compute number of key schedule rows
                                    var ksRows = (nRounds + 1) * 4;

                                    // Compute key schedule
                                    var keySchedule = (this._keySchedule = []);
                                    for (
                                        var ksRow = 0;
                                        ksRow < ksRows;
                                        ksRow++
                                    ) {
                                        if (ksRow < keySize) {
                                            keySchedule[ksRow] =
                                                keyWords[ksRow];
                                        } else {
                                            var t = keySchedule[ksRow - 1];

                                            if (!(ksRow % keySize)) {
                                                // Rot word
                                                t = (t << 8) | (t >>> 24);

                                                // Sub word
                                                t =
                                                    (SBOX[t >>> 24] << 24) |
                                                    (SBOX[(t >>> 16) & 0xff] <<
                                                        16) |
                                                    (SBOX[(t >>> 8) & 0xff] <<
                                                        8) |
                                                    SBOX[t & 0xff];

                                                // Mix Rcon
                                                t ^=
                                                    RCON[
                                                        (ksRow / keySize) | 0
                                                    ] << 24;
                                            } else if (
                                                keySize > 6 &&
                                                ksRow % keySize == 4
                                            ) {
                                                // Sub word
                                                t =
                                                    (SBOX[t >>> 24] << 24) |
                                                    (SBOX[(t >>> 16) & 0xff] <<
                                                        16) |
                                                    (SBOX[(t >>> 8) & 0xff] <<
                                                        8) |
                                                    SBOX[t & 0xff];
                                            }

                                            keySchedule[ksRow] =
                                                keySchedule[ksRow - keySize] ^
                                                t;
                                        }
                                    }

                                    // Compute inv key schedule
                                    var invKeySchedule = (this._invKeySchedule = []);
                                    for (
                                        var invKsRow = 0;
                                        invKsRow < ksRows;
                                        invKsRow++
                                    ) {
                                        var ksRow = ksRows - invKsRow;

                                        if (invKsRow % 4) {
                                            var t = keySchedule[ksRow];
                                        } else {
                                            var t = keySchedule[ksRow - 4];
                                        }

                                        if (invKsRow < 4 || ksRow <= 4) {
                                            invKeySchedule[invKsRow] = t;
                                        } else {
                                            invKeySchedule[invKsRow] =
                                                INV_SUB_MIX_0[SBOX[t >>> 24]] ^
                                                INV_SUB_MIX_1[
                                                    SBOX[(t >>> 16) & 0xff]
                                                ] ^
                                                INV_SUB_MIX_2[
                                                    SBOX[(t >>> 8) & 0xff]
                                                ] ^
                                                INV_SUB_MIX_3[SBOX[t & 0xff]];
                                        }
                                    }
                                },

                                encryptBlock: function(M, offset) {
                                    this._doCryptBlock(
                                        M,
                                        offset,
                                        this._keySchedule,
                                        SUB_MIX_0,
                                        SUB_MIX_1,
                                        SUB_MIX_2,
                                        SUB_MIX_3,
                                        SBOX
                                    );
                                },

                                decryptBlock: function(M, offset) {
                                    // Swap 2nd and 4th rows
                                    var t = M[offset + 1];
                                    M[offset + 1] = M[offset + 3];
                                    M[offset + 3] = t;

                                    this._doCryptBlock(
                                        M,
                                        offset,
                                        this._invKeySchedule,
                                        INV_SUB_MIX_0,
                                        INV_SUB_MIX_1,
                                        INV_SUB_MIX_2,
                                        INV_SUB_MIX_3,
                                        INV_SBOX
                                    );

                                    // Inv swap 2nd and 4th rows
                                    var t = M[offset + 1];
                                    M[offset + 1] = M[offset + 3];
                                    M[offset + 3] = t;
                                },

                                _doCryptBlock: function(
                                    M,
                                    offset,
                                    keySchedule,
                                    SUB_MIX_0,
                                    SUB_MIX_1,
                                    SUB_MIX_2,
                                    SUB_MIX_3,
                                    SBOX
                                ) {
                                    // Shortcut
                                    var nRounds = this._nRounds;

                                    // Get input, add round key
                                    var s0 = M[offset] ^ keySchedule[0];
                                    var s1 = M[offset + 1] ^ keySchedule[1];
                                    var s2 = M[offset + 2] ^ keySchedule[2];
                                    var s3 = M[offset + 3] ^ keySchedule[3];

                                    // Key schedule row counter
                                    var ksRow = 4;

                                    // Rounds
                                    for (
                                        var round = 1;
                                        round < nRounds;
                                        round++
                                    ) {
                                        // Shift rows, sub bytes, mix columns, add round key
                                        var t0 =
                                            SUB_MIX_0[s0 >>> 24] ^
                                            SUB_MIX_1[(s1 >>> 16) & 0xff] ^
                                            SUB_MIX_2[(s2 >>> 8) & 0xff] ^
                                            SUB_MIX_3[s3 & 0xff] ^
                                            keySchedule[ksRow++];
                                        var t1 =
                                            SUB_MIX_0[s1 >>> 24] ^
                                            SUB_MIX_1[(s2 >>> 16) & 0xff] ^
                                            SUB_MIX_2[(s3 >>> 8) & 0xff] ^
                                            SUB_MIX_3[s0 & 0xff] ^
                                            keySchedule[ksRow++];
                                        var t2 =
                                            SUB_MIX_0[s2 >>> 24] ^
                                            SUB_MIX_1[(s3 >>> 16) & 0xff] ^
                                            SUB_MIX_2[(s0 >>> 8) & 0xff] ^
                                            SUB_MIX_3[s1 & 0xff] ^
                                            keySchedule[ksRow++];
                                        var t3 =
                                            SUB_MIX_0[s3 >>> 24] ^
                                            SUB_MIX_1[(s0 >>> 16) & 0xff] ^
                                            SUB_MIX_2[(s1 >>> 8) & 0xff] ^
                                            SUB_MIX_3[s2 & 0xff] ^
                                            keySchedule[ksRow++];

                                        // Update state
                                        s0 = t0;
                                        s1 = t1;
                                        s2 = t2;
                                        s3 = t3;
                                    }

                                    // Shift rows, sub bytes, add round key
                                    var t0 =
                                        ((SBOX[s0 >>> 24] << 24) |
                                            (SBOX[(s1 >>> 16) & 0xff] << 16) |
                                            (SBOX[(s2 >>> 8) & 0xff] << 8) |
                                            SBOX[s3 & 0xff]) ^
                                        keySchedule[ksRow++];
                                    var t1 =
                                        ((SBOX[s1 >>> 24] << 24) |
                                            (SBOX[(s2 >>> 16) & 0xff] << 16) |
                                            (SBOX[(s3 >>> 8) & 0xff] << 8) |
                                            SBOX[s0 & 0xff]) ^
                                        keySchedule[ksRow++];
                                    var t2 =
                                        ((SBOX[s2 >>> 24] << 24) |
                                            (SBOX[(s3 >>> 16) & 0xff] << 16) |
                                            (SBOX[(s0 >>> 8) & 0xff] << 8) |
                                            SBOX[s1 & 0xff]) ^
                                        keySchedule[ksRow++];
                                    var t3 =
                                        ((SBOX[s3 >>> 24] << 24) |
                                            (SBOX[(s0 >>> 16) & 0xff] << 16) |
                                            (SBOX[(s1 >>> 8) & 0xff] << 8) |
                                            SBOX[s2 & 0xff]) ^
                                        keySchedule[ksRow++];

                                    // Set output
                                    M[offset] = t0;
                                    M[offset + 1] = t1;
                                    M[offset + 2] = t2;
                                    M[offset + 3] = t3;
                                },

                                keySize: 256 / 32
                            }));

                            /**
                             * Shortcut functions to the cipher's object interface.
                             *
                             * @example
                             *
                             *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
                             *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
                             */
                            C.AES = BlockCipher._createHelper(AES);
                        })();

                        return CryptoJS.AES;
                    });
                },
                {
                    "./cipher-core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/cipher-core.js",
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js",
                    "./enc-base64":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/enc-base64.js",
                    "./evpkdf":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/evpkdf.js",
                    "./md5":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/md5.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/cipher-core.js": [
                function(require, module, exports) {
                    (function(root, factory, undef) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core"),
                                require("./evpkdf")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core", "./evpkdf"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        /**
                         * Cipher core components.
                         */
                        CryptoJS.lib.Cipher ||
                            (function(undefined) {
                                // Shortcuts
                                var C = CryptoJS;
                                var C_lib = C.lib;
                                var Base = C_lib.Base;
                                var WordArray = C_lib.WordArray;
                                var BufferedBlockAlgorithm =
                                    C_lib.BufferedBlockAlgorithm;
                                var C_enc = C.enc;
                                var Utf8 = C_enc.Utf8;
                                var Base64 = C_enc.Base64;
                                var C_algo = C.algo;
                                var EvpKDF = C_algo.EvpKDF;

                                /**
                                 * Abstract base cipher template.
                                 *
                                 * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
                                 * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
                                 * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
                                 * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
                                 */
                                var Cipher = (C_lib.Cipher = BufferedBlockAlgorithm.extend(
                                    {
                                        /**
                                         * Configuration options.
                                         *
                                         * @property {WordArray} iv The IV to use for this operation.
                                         */
                                        cfg: Base.extend(),

                                        /**
                                         * Creates this cipher in encryption mode.
                                         *
                                         * @param {WordArray} key The key.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {Cipher} A cipher instance.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                                         */
                                        createEncryptor: function(key, cfg) {
                                            return this.create(
                                                this._ENC_XFORM_MODE,
                                                key,
                                                cfg
                                            );
                                        },

                                        /**
                                         * Creates this cipher in decryption mode.
                                         *
                                         * @param {WordArray} key The key.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {Cipher} A cipher instance.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                                         */
                                        createDecryptor: function(key, cfg) {
                                            return this.create(
                                                this._DEC_XFORM_MODE,
                                                key,
                                                cfg
                                            );
                                        },

                                        /**
                                         * Initializes a newly created cipher.
                                         *
                                         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                                         * @param {WordArray} key The key.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @example
                                         *
                                         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                                         */
                                        init: function(xformMode, key, cfg) {
                                            // Apply config defaults
                                            this.cfg = this.cfg.extend(cfg);

                                            // Store transform mode and key
                                            this._xformMode = xformMode;
                                            this._key = key;

                                            // Set initial values
                                            this.reset();
                                        },

                                        /**
                                         * Resets this cipher to its initial state.
                                         *
                                         * @example
                                         *
                                         *     cipher.reset();
                                         */
                                        reset: function() {
                                            // Reset data buffer
                                            BufferedBlockAlgorithm.reset.call(
                                                this
                                            );

                                            // Perform concrete-cipher logic
                                            this._doReset();
                                        },

                                        /**
                                         * Adds data to be encrypted or decrypted.
                                         *
                                         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                                         *
                                         * @return {WordArray} The data after processing.
                                         *
                                         * @example
                                         *
                                         *     var encrypted = cipher.process('data');
                                         *     var encrypted = cipher.process(wordArray);
                                         */
                                        process: function(dataUpdate) {
                                            // Append
                                            this._append(dataUpdate);

                                            // Process available blocks
                                            return this._process();
                                        },

                                        /**
                                         * Finalizes the encryption or decryption process.
                                         * Note that the finalize operation is effectively a destructive, read-once operation.
                                         *
                                         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                                         *
                                         * @return {WordArray} The data after final processing.
                                         *
                                         * @example
                                         *
                                         *     var encrypted = cipher.finalize();
                                         *     var encrypted = cipher.finalize('data');
                                         *     var encrypted = cipher.finalize(wordArray);
                                         */
                                        finalize: function(dataUpdate) {
                                            // Final data update
                                            if (dataUpdate) {
                                                this._append(dataUpdate);
                                            }

                                            // Perform concrete-cipher logic
                                            var finalProcessedData = this._doFinalize();

                                            return finalProcessedData;
                                        },

                                        keySize: 128 / 32,

                                        ivSize: 128 / 32,

                                        _ENC_XFORM_MODE: 1,

                                        _DEC_XFORM_MODE: 2,

                                        /**
                                         * Creates shortcut functions to a cipher's object interface.
                                         *
                                         * @param {Cipher} cipher The cipher to create a helper for.
                                         *
                                         * @return {Object} An object with encrypt and decrypt shortcut functions.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                                         */
                                        _createHelper: (function() {
                                            function selectCipherStrategy(key) {
                                                if (typeof key == "string") {
                                                    return PasswordBasedCipher;
                                                } else {
                                                    return SerializableCipher;
                                                }
                                            }

                                            return function(cipher) {
                                                return {
                                                    encrypt: function(
                                                        message,
                                                        key,
                                                        cfg
                                                    ) {
                                                        return selectCipherStrategy(
                                                            key
                                                        ).encrypt(
                                                            cipher,
                                                            message,
                                                            key,
                                                            cfg
                                                        );
                                                    },

                                                    decrypt: function(
                                                        ciphertext,
                                                        key,
                                                        cfg
                                                    ) {
                                                        return selectCipherStrategy(
                                                            key
                                                        ).decrypt(
                                                            cipher,
                                                            ciphertext,
                                                            key,
                                                            cfg
                                                        );
                                                    }
                                                };
                                            };
                                        })()
                                    }
                                ));

                                /**
                                 * Abstract base stream cipher template.
                                 *
                                 * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
                                 */
                                var StreamCipher = (C_lib.StreamCipher = Cipher.extend(
                                    {
                                        _doFinalize: function() {
                                            // Process partial blocks
                                            var finalProcessedBlocks = this._process(
                                                !!"flush"
                                            );

                                            return finalProcessedBlocks;
                                        },

                                        blockSize: 1
                                    }
                                ));

                                /**
                                 * Mode namespace.
                                 */
                                var C_mode = (C.mode = {});

                                /**
                                 * Abstract base block cipher mode template.
                                 */
                                var BlockCipherMode = (C_lib.BlockCipherMode = Base.extend(
                                    {
                                        /**
                                         * Creates this mode for encryption.
                                         *
                                         * @param {Cipher} cipher A block cipher instance.
                                         * @param {Array} iv The IV words.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                                         */
                                        createEncryptor: function(cipher, iv) {
                                            return this.Encryptor.create(
                                                cipher,
                                                iv
                                            );
                                        },

                                        /**
                                         * Creates this mode for decryption.
                                         *
                                         * @param {Cipher} cipher A block cipher instance.
                                         * @param {Array} iv The IV words.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                                         */
                                        createDecryptor: function(cipher, iv) {
                                            return this.Decryptor.create(
                                                cipher,
                                                iv
                                            );
                                        },

                                        /**
                                         * Initializes a newly created mode.
                                         *
                                         * @param {Cipher} cipher A block cipher instance.
                                         * @param {Array} iv The IV words.
                                         *
                                         * @example
                                         *
                                         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                                         */
                                        init: function(cipher, iv) {
                                            this._cipher = cipher;
                                            this._iv = iv;
                                        }
                                    }
                                ));

                                /**
                                 * Cipher Block Chaining mode.
                                 */
                                var CBC = (C_mode.CBC = (function() {
                                    /**
                                     * Abstract base CBC mode.
                                     */
                                    var CBC = BlockCipherMode.extend();

                                    /**
                                     * CBC encryptor.
                                     */
                                    CBC.Encryptor = CBC.extend({
                                        /**
                                         * Processes the data block at offset.
                                         *
                                         * @param {Array} words The data words to operate on.
                                         * @param {number} offset The offset where the block starts.
                                         *
                                         * @example
                                         *
                                         *     mode.processBlock(data.words, offset);
                                         */
                                        processBlock: function(words, offset) {
                                            // Shortcuts
                                            var cipher = this._cipher;
                                            var blockSize = cipher.blockSize;

                                            // XOR and encrypt
                                            xorBlock.call(
                                                this,
                                                words,
                                                offset,
                                                blockSize
                                            );
                                            cipher.encryptBlock(words, offset);

                                            // Remember this block to use with next block
                                            this._prevBlock = words.slice(
                                                offset,
                                                offset + blockSize
                                            );
                                        }
                                    });

                                    /**
                                     * CBC decryptor.
                                     */
                                    CBC.Decryptor = CBC.extend({
                                        /**
                                         * Processes the data block at offset.
                                         *
                                         * @param {Array} words The data words to operate on.
                                         * @param {number} offset The offset where the block starts.
                                         *
                                         * @example
                                         *
                                         *     mode.processBlock(data.words, offset);
                                         */
                                        processBlock: function(words, offset) {
                                            // Shortcuts
                                            var cipher = this._cipher;
                                            var blockSize = cipher.blockSize;

                                            // Remember this block to use with next block
                                            var thisBlock = words.slice(
                                                offset,
                                                offset + blockSize
                                            );

                                            // Decrypt and XOR
                                            cipher.decryptBlock(words, offset);
                                            xorBlock.call(
                                                this,
                                                words,
                                                offset,
                                                blockSize
                                            );

                                            // This block becomes the previous block
                                            this._prevBlock = thisBlock;
                                        }
                                    });

                                    function xorBlock(
                                        words,
                                        offset,
                                        blockSize
                                    ) {
                                        // Shortcut
                                        var iv = this._iv;

                                        // Choose mixing block
                                        if (iv) {
                                            var block = iv;

                                            // Remove IV for subsequent blocks
                                            this._iv = undefined;
                                        } else {
                                            var block = this._prevBlock;
                                        }

                                        // XOR blocks
                                        for (var i = 0; i < blockSize; i++) {
                                            words[offset + i] ^= block[i];
                                        }
                                    }

                                    return CBC;
                                })());

                                /**
                                 * Padding namespace.
                                 */
                                var C_pad = (C.pad = {});

                                /**
                                 * PKCS #5/7 padding strategy.
                                 */
                                var Pkcs7 = (C_pad.Pkcs7 = {
                                    /**
                                     * Pads data using the algorithm defined in PKCS #5/7.
                                     *
                                     * @param {WordArray} data The data to pad.
                                     * @param {number} blockSize The multiple that the data should be padded to.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                                     */
                                    pad: function(data, blockSize) {
                                        // Shortcut
                                        var blockSizeBytes = blockSize * 4;

                                        // Count padding bytes
                                        var nPaddingBytes =
                                            blockSizeBytes -
                                            data.sigBytes % blockSizeBytes;

                                        // Create padding word
                                        var paddingWord =
                                            (nPaddingBytes << 24) |
                                            (nPaddingBytes << 16) |
                                            (nPaddingBytes << 8) |
                                            nPaddingBytes;

                                        // Create padding
                                        var paddingWords = [];
                                        for (
                                            var i = 0;
                                            i < nPaddingBytes;
                                            i += 4
                                        ) {
                                            paddingWords.push(paddingWord);
                                        }
                                        var padding = WordArray.create(
                                            paddingWords,
                                            nPaddingBytes
                                        );

                                        // Add padding
                                        data.concat(padding);
                                    },

                                    /**
                                     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                                     *
                                     * @param {WordArray} data The data to unpad.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                                     */
                                    unpad: function(data) {
                                        // Get number of padding bytes from last byte
                                        var nPaddingBytes =
                                            data.words[
                                                (data.sigBytes - 1) >>> 2
                                            ] & 0xff;

                                        // Remove padding
                                        data.sigBytes -= nPaddingBytes;
                                    }
                                });

                                /**
                                 * Abstract base block cipher template.
                                 *
                                 * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
                                 */
                                var BlockCipher = (C_lib.BlockCipher = Cipher.extend(
                                    {
                                        /**
                                         * Configuration options.
                                         *
                                         * @property {Mode} mode The block mode to use. Default: CBC
                                         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                                         */
                                        cfg: Cipher.cfg.extend({
                                            mode: CBC,
                                            padding: Pkcs7
                                        }),

                                        reset: function() {
                                            // Reset cipher
                                            Cipher.reset.call(this);

                                            // Shortcuts
                                            var cfg = this.cfg;
                                            var iv = cfg.iv;
                                            var mode = cfg.mode;

                                            // Reset block mode
                                            if (
                                                this._xformMode ==
                                                this._ENC_XFORM_MODE
                                            ) {
                                                var modeCreator =
                                                    mode.createEncryptor;
                                            } /* if (this._xformMode == this._DEC_XFORM_MODE) */ else {
                                                var modeCreator =
                                                    mode.createDecryptor;
                                                // Keep at least one block in the buffer for unpadding
                                                this._minBufferSize = 1;
                                            }

                                            if (
                                                this._mode &&
                                                this._mode.__creator ==
                                                    modeCreator
                                            ) {
                                                this._mode.init(
                                                    this,
                                                    iv && iv.words
                                                );
                                            } else {
                                                this._mode = modeCreator.call(
                                                    mode,
                                                    this,
                                                    iv && iv.words
                                                );
                                                this._mode.__creator = modeCreator;
                                            }
                                        },

                                        _doProcessBlock: function(
                                            words,
                                            offset
                                        ) {
                                            this._mode.processBlock(
                                                words,
                                                offset
                                            );
                                        },

                                        _doFinalize: function() {
                                            // Shortcut
                                            var padding = this.cfg.padding;

                                            // Finalize
                                            if (
                                                this._xformMode ==
                                                this._ENC_XFORM_MODE
                                            ) {
                                                // Pad data
                                                padding.pad(
                                                    this._data,
                                                    this.blockSize
                                                );

                                                // Process final blocks
                                                var finalProcessedBlocks = this._process(
                                                    !!"flush"
                                                );
                                            } /* if (this._xformMode == this._DEC_XFORM_MODE) */ else {
                                                // Process final blocks
                                                var finalProcessedBlocks = this._process(
                                                    !!"flush"
                                                );

                                                // Unpad data
                                                padding.unpad(
                                                    finalProcessedBlocks
                                                );
                                            }

                                            return finalProcessedBlocks;
                                        },

                                        blockSize: 128 / 32
                                    }
                                ));

                                /**
                                 * A collection of cipher parameters.
                                 *
                                 * @property {WordArray} ciphertext The raw ciphertext.
                                 * @property {WordArray} key The key to this ciphertext.
                                 * @property {WordArray} iv The IV used in the ciphering operation.
                                 * @property {WordArray} salt The salt used with a key derivation function.
                                 * @property {Cipher} algorithm The cipher algorithm.
                                 * @property {Mode} mode The block mode used in the ciphering operation.
                                 * @property {Padding} padding The padding scheme used in the ciphering operation.
                                 * @property {number} blockSize The block size of the cipher.
                                 * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
                                 */
                                var CipherParams = (C_lib.CipherParams = Base.extend(
                                    {
                                        /**
                                         * Initializes a newly created cipher params object.
                                         *
                                         * @param {Object} cipherParams An object with any of the possible cipher parameters.
                                         *
                                         * @example
                                         *
                                         *     var cipherParams = CryptoJS.lib.CipherParams.create({
                                         *         ciphertext: ciphertextWordArray,
                                         *         key: keyWordArray,
                                         *         iv: ivWordArray,
                                         *         salt: saltWordArray,
                                         *         algorithm: CryptoJS.algo.AES,
                                         *         mode: CryptoJS.mode.CBC,
                                         *         padding: CryptoJS.pad.PKCS7,
                                         *         blockSize: 4,
                                         *         formatter: CryptoJS.format.OpenSSL
                                         *     });
                                         */
                                        init: function(cipherParams) {
                                            this.mixIn(cipherParams);
                                        },

                                        /**
                                         * Converts this cipher params object to a string.
                                         *
                                         * @param {Format} formatter (Optional) The formatting strategy to use.
                                         *
                                         * @return {string} The stringified cipher params.
                                         *
                                         * @throws Error If neither the formatter nor the default formatter is set.
                                         *
                                         * @example
                                         *
                                         *     var string = cipherParams + '';
                                         *     var string = cipherParams.toString();
                                         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                                         */
                                        toString: function(formatter) {
                                            return (
                                                formatter || this.formatter
                                            ).stringify(this);
                                        }
                                    }
                                ));

                                /**
                                 * Format namespace.
                                 */
                                var C_format = (C.format = {});

                                /**
                                 * OpenSSL formatting strategy.
                                 */
                                var OpenSSLFormatter = (C_format.OpenSSL = {
                                    /**
                                     * Converts a cipher params object to an OpenSSL-compatible string.
                                     *
                                     * @param {CipherParams} cipherParams The cipher params object.
                                     *
                                     * @return {string} The OpenSSL-compatible string.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                                     */
                                    stringify: function(cipherParams) {
                                        // Shortcuts
                                        var ciphertext =
                                            cipherParams.ciphertext;
                                        var salt = cipherParams.salt;

                                        // Format
                                        if (salt) {
                                            var wordArray = WordArray.create([
                                                0x53616c74,
                                                0x65645f5f
                                            ])
                                                .concat(salt)
                                                .concat(ciphertext);
                                        } else {
                                            var wordArray = ciphertext;
                                        }

                                        return wordArray.toString(Base64);
                                    },

                                    /**
                                     * Converts an OpenSSL-compatible string to a cipher params object.
                                     *
                                     * @param {string} openSSLStr The OpenSSL-compatible string.
                                     *
                                     * @return {CipherParams} The cipher params object.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                                     */
                                    parse: function(openSSLStr) {
                                        // Parse base64
                                        var ciphertext = Base64.parse(
                                            openSSLStr
                                        );

                                        // Shortcut
                                        var ciphertextWords = ciphertext.words;

                                        // Test for salt
                                        if (
                                            ciphertextWords[0] == 0x53616c74 &&
                                            ciphertextWords[1] == 0x65645f5f
                                        ) {
                                            // Extract salt
                                            var salt = WordArray.create(
                                                ciphertextWords.slice(2, 4)
                                            );

                                            // Remove salt from ciphertext
                                            ciphertextWords.splice(0, 4);
                                            ciphertext.sigBytes -= 16;
                                        }

                                        return CipherParams.create({
                                            ciphertext: ciphertext,
                                            salt: salt
                                        });
                                    }
                                });

                                /**
                                 * A cipher wrapper that returns ciphertext as a serializable cipher params object.
                                 */
                                var SerializableCipher = (C_lib.SerializableCipher = Base.extend(
                                    {
                                        /**
                                         * Configuration options.
                                         *
                                         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                                         */
                                        cfg: Base.extend({
                                            format: OpenSSLFormatter
                                        }),

                                        /**
                                         * Encrypts a message.
                                         *
                                         * @param {Cipher} cipher The cipher algorithm to use.
                                         * @param {WordArray|string} message The message to encrypt.
                                         * @param {WordArray} key The key.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {CipherParams} A cipher params object.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                                         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                                         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                                         */
                                        encrypt: function(
                                            cipher,
                                            message,
                                            key,
                                            cfg
                                        ) {
                                            // Apply config defaults
                                            cfg = this.cfg.extend(cfg);

                                            // Encrypt
                                            var encryptor = cipher.createEncryptor(
                                                key,
                                                cfg
                                            );
                                            var ciphertext = encryptor.finalize(
                                                message
                                            );

                                            // Shortcut
                                            var cipherCfg = encryptor.cfg;

                                            // Create and return serializable cipher params
                                            return CipherParams.create({
                                                ciphertext: ciphertext,
                                                key: key,
                                                iv: cipherCfg.iv,
                                                algorithm: cipher,
                                                mode: cipherCfg.mode,
                                                padding: cipherCfg.padding,
                                                blockSize: cipher.blockSize,
                                                formatter: cfg.format
                                            });
                                        },

                                        /**
                                         * Decrypts serialized ciphertext.
                                         *
                                         * @param {Cipher} cipher The cipher algorithm to use.
                                         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                                         * @param {WordArray} key The key.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {WordArray} The plaintext.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                                         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                                         */
                                        decrypt: function(
                                            cipher,
                                            ciphertext,
                                            key,
                                            cfg
                                        ) {
                                            // Apply config defaults
                                            cfg = this.cfg.extend(cfg);

                                            // Convert string to CipherParams
                                            ciphertext = this._parse(
                                                ciphertext,
                                                cfg.format
                                            );

                                            // Decrypt
                                            var plaintext = cipher
                                                .createDecryptor(key, cfg)
                                                .finalize(
                                                    ciphertext.ciphertext
                                                );

                                            return plaintext;
                                        },

                                        /**
                                         * Converts serialized ciphertext to CipherParams,
                                         * else assumed CipherParams already and returns ciphertext unchanged.
                                         *
                                         * @param {CipherParams|string} ciphertext The ciphertext.
                                         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                                         *
                                         * @return {CipherParams} The unserialized ciphertext.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                                         */
                                        _parse: function(ciphertext, format) {
                                            if (typeof ciphertext == "string") {
                                                return format.parse(
                                                    ciphertext,
                                                    this
                                                );
                                            } else {
                                                return ciphertext;
                                            }
                                        }
                                    }
                                ));

                                /**
                                 * Key derivation function namespace.
                                 */
                                var C_kdf = (C.kdf = {});

                                /**
                                 * OpenSSL key derivation function.
                                 */
                                var OpenSSLKdf = (C_kdf.OpenSSL = {
                                    /**
                                     * Derives a key and IV from a password.
                                     *
                                     * @param {string} password The password to derive from.
                                     * @param {number} keySize The size in words of the key to generate.
                                     * @param {number} ivSize The size in words of the IV to generate.
                                     * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                                     *
                                     * @return {CipherParams} A cipher params object with the key, IV, and salt.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                                     */
                                    execute: function(
                                        password,
                                        keySize,
                                        ivSize,
                                        salt
                                    ) {
                                        // Generate random salt
                                        if (!salt) {
                                            salt = WordArray.random(64 / 8);
                                        }

                                        // Derive key and IV
                                        var key = EvpKDF.create({
                                            keySize: keySize + ivSize
                                        }).compute(password, salt);

                                        // Separate key and IV
                                        var iv = WordArray.create(
                                            key.words.slice(keySize),
                                            ivSize * 4
                                        );
                                        key.sigBytes = keySize * 4;

                                        // Return params
                                        return CipherParams.create({
                                            key: key,
                                            iv: iv,
                                            salt: salt
                                        });
                                    }
                                });

                                /**
                                 * A serializable cipher wrapper that derives the key from a password,
                                 * and returns ciphertext as a serializable cipher params object.
                                 */
                                var PasswordBasedCipher = (C_lib.PasswordBasedCipher = SerializableCipher.extend(
                                    {
                                        /**
                                         * Configuration options.
                                         *
                                         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                                         */
                                        cfg: SerializableCipher.cfg.extend({
                                            kdf: OpenSSLKdf
                                        }),

                                        /**
                                         * Encrypts a message using a password.
                                         *
                                         * @param {Cipher} cipher The cipher algorithm to use.
                                         * @param {WordArray|string} message The message to encrypt.
                                         * @param {string} password The password.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {CipherParams} A cipher params object.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                                         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                                         */
                                        encrypt: function(
                                            cipher,
                                            message,
                                            password,
                                            cfg
                                        ) {
                                            // Apply config defaults
                                            cfg = this.cfg.extend(cfg);

                                            // Derive key and other params
                                            var derivedParams = cfg.kdf.execute(
                                                password,
                                                cipher.keySize,
                                                cipher.ivSize
                                            );

                                            // Add IV to config
                                            cfg.iv = derivedParams.iv;

                                            // Encrypt
                                            var ciphertext = SerializableCipher.encrypt.call(
                                                this,
                                                cipher,
                                                message,
                                                derivedParams.key,
                                                cfg
                                            );

                                            // Mix in derived params
                                            ciphertext.mixIn(derivedParams);

                                            return ciphertext;
                                        },

                                        /**
                                         * Decrypts serialized ciphertext using a password.
                                         *
                                         * @param {Cipher} cipher The cipher algorithm to use.
                                         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                                         * @param {string} password The password.
                                         * @param {Object} cfg (Optional) The configuration options to use for this operation.
                                         *
                                         * @return {WordArray} The plaintext.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                                         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                                         */
                                        decrypt: function(
                                            cipher,
                                            ciphertext,
                                            password,
                                            cfg
                                        ) {
                                            // Apply config defaults
                                            cfg = this.cfg.extend(cfg);

                                            // Convert string to CipherParams
                                            ciphertext = this._parse(
                                                ciphertext,
                                                cfg.format
                                            );

                                            // Derive key and other params
                                            var derivedParams = cfg.kdf.execute(
                                                password,
                                                cipher.keySize,
                                                cipher.ivSize,
                                                ciphertext.salt
                                            );

                                            // Add IV to config
                                            cfg.iv = derivedParams.iv;

                                            // Decrypt
                                            var plaintext = SerializableCipher.decrypt.call(
                                                this,
                                                cipher,
                                                ciphertext,
                                                derivedParams.key,
                                                cfg
                                            );

                                            return plaintext;
                                        }
                                    }
                                ));
                            })();
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js",
                    "./evpkdf":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/evpkdf.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory();
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define([], factory);
                        } else {
                            // Global (browser)
                            root.CryptoJS = factory();
                        }
                    })(this, function() {
                        /**
                         * CryptoJS core components.
                         */
                        var CryptoJS =
                            CryptoJS ||
                            (function(Math, undefined) {
                                /*
	     * Local polyfil of Object.create
	     */
                                var create =
                                    Object.create ||
                                    (function() {
                                        function F() {}

                                        return function(obj) {
                                            var subtype;

                                            F.prototype = obj;

                                            subtype = new F();

                                            F.prototype = null;

                                            return subtype;
                                        };
                                    })();

                                /**
                                 * CryptoJS namespace.
                                 */
                                var C = {};

                                /**
                                 * Library namespace.
                                 */
                                var C_lib = (C.lib = {});

                                /**
                                 * Base object for prototypal inheritance.
                                 */
                                var Base = (C_lib.Base = (function() {
                                    return {
                                        /**
                                         * Creates a new object that inherits from this object.
                                         *
                                         * @param {Object} overrides Properties to copy into the new object.
                                         *
                                         * @return {Object} The new object.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var MyType = CryptoJS.lib.Base.extend({
                                         *         field: 'value',
                                         *
                                         *         method: function () {
                                         *         }
                                         *     });
                                         */
                                        extend: function(overrides) {
                                            // Spawn
                                            var subtype = create(this);

                                            // Augment
                                            if (overrides) {
                                                subtype.mixIn(overrides);
                                            }

                                            // Create default initializer
                                            if (
                                                !subtype.hasOwnProperty(
                                                    "init"
                                                ) ||
                                                this.init === subtype.init
                                            ) {
                                                subtype.init = function() {
                                                    subtype.$super.init.apply(
                                                        this,
                                                        arguments
                                                    );
                                                };
                                            }

                                            // Initializer's prototype is the subtype object
                                            subtype.init.prototype = subtype;

                                            // Reference supertype
                                            subtype.$super = this;

                                            return subtype;
                                        },

                                        /**
                                         * Extends this object and runs the init method.
                                         * Arguments to create() will be passed to init().
                                         *
                                         * @return {Object} The new object.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var instance = MyType.create();
                                         */
                                        create: function() {
                                            var instance = this.extend();
                                            instance.init.apply(
                                                instance,
                                                arguments
                                            );

                                            return instance;
                                        },

                                        /**
                                         * Initializes a newly created object.
                                         * Override this method to add some logic when your objects are created.
                                         *
                                         * @example
                                         *
                                         *     var MyType = CryptoJS.lib.Base.extend({
                                         *         init: function () {
                                         *             // ...
                                         *         }
                                         *     });
                                         */
                                        init: function() {},

                                        /**
                                         * Copies properties into this object.
                                         *
                                         * @param {Object} properties The properties to mix in.
                                         *
                                         * @example
                                         *
                                         *     MyType.mixIn({
                                         *         field: 'value'
                                         *     });
                                         */
                                        mixIn: function(properties) {
                                            for (var propertyName in properties) {
                                                if (
                                                    properties.hasOwnProperty(
                                                        propertyName
                                                    )
                                                ) {
                                                    this[propertyName] =
                                                        properties[
                                                            propertyName
                                                        ];
                                                }
                                            }

                                            // IE won't copy toString using the loop above
                                            if (
                                                properties.hasOwnProperty(
                                                    "toString"
                                                )
                                            ) {
                                                this.toString =
                                                    properties.toString;
                                            }
                                        },

                                        /**
                                         * Creates a copy of this object.
                                         *
                                         * @return {Object} The clone.
                                         *
                                         * @example
                                         *
                                         *     var clone = instance.clone();
                                         */
                                        clone: function() {
                                            return this.init.prototype.extend(
                                                this
                                            );
                                        }
                                    };
                                })());

                                /**
                                 * An array of 32-bit words.
                                 *
                                 * @property {Array} words The array of 32-bit words.
                                 * @property {number} sigBytes The number of significant bytes in this word array.
                                 */
                                var WordArray = (C_lib.WordArray = Base.extend({
                                    /**
                                     * Initializes a newly created word array.
                                     *
                                     * @param {Array} words (Optional) An array of 32-bit words.
                                     * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                                     *
                                     * @example
                                     *
                                     *     var wordArray = CryptoJS.lib.WordArray.create();
                                     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                                     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                                     */
                                    init: function(words, sigBytes) {
                                        words = this.words = words || [];

                                        if (sigBytes != undefined) {
                                            this.sigBytes = sigBytes;
                                        } else {
                                            this.sigBytes = words.length * 4;
                                        }
                                    },

                                    /**
                                     * Converts this word array to a string.
                                     *
                                     * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                                     *
                                     * @return {string} The stringified word array.
                                     *
                                     * @example
                                     *
                                     *     var string = wordArray + '';
                                     *     var string = wordArray.toString();
                                     *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                                     */
                                    toString: function(encoder) {
                                        return (encoder || Hex).stringify(this);
                                    },

                                    /**
                                     * Concatenates a word array to this word array.
                                     *
                                     * @param {WordArray} wordArray The word array to append.
                                     *
                                     * @return {WordArray} This word array.
                                     *
                                     * @example
                                     *
                                     *     wordArray1.concat(wordArray2);
                                     */
                                    concat: function(wordArray) {
                                        // Shortcuts
                                        var thisWords = this.words;
                                        var thatWords = wordArray.words;
                                        var thisSigBytes = this.sigBytes;
                                        var thatSigBytes = wordArray.sigBytes;

                                        // Clamp excess bits
                                        this.clamp();

                                        // Concat
                                        if (thisSigBytes % 4) {
                                            // Copy one byte at a time
                                            for (
                                                var i = 0;
                                                i < thatSigBytes;
                                                i++
                                            ) {
                                                var thatByte =
                                                    (thatWords[i >>> 2] >>>
                                                        (24 - (i % 4) * 8)) &
                                                    0xff;
                                                thisWords[
                                                    (thisSigBytes + i) >>> 2
                                                ] |=
                                                    thatByte <<
                                                    (24 -
                                                        ((thisSigBytes + i) %
                                                            4) *
                                                            8);
                                            }
                                        } else {
                                            // Copy one word at a time
                                            for (
                                                var i = 0;
                                                i < thatSigBytes;
                                                i += 4
                                            ) {
                                                thisWords[
                                                    (thisSigBytes + i) >>> 2
                                                ] =
                                                    thatWords[i >>> 2];
                                            }
                                        }
                                        this.sigBytes += thatSigBytes;

                                        // Chainable
                                        return this;
                                    },

                                    /**
                                     * Removes insignificant bits.
                                     *
                                     * @example
                                     *
                                     *     wordArray.clamp();
                                     */
                                    clamp: function() {
                                        // Shortcuts
                                        var words = this.words;
                                        var sigBytes = this.sigBytes;

                                        // Clamp
                                        words[sigBytes >>> 2] &=
                                            0xffffffff <<
                                            (32 - (sigBytes % 4) * 8);
                                        words.length = Math.ceil(sigBytes / 4);
                                    },

                                    /**
                                     * Creates a copy of this word array.
                                     *
                                     * @return {WordArray} The clone.
                                     *
                                     * @example
                                     *
                                     *     var clone = wordArray.clone();
                                     */
                                    clone: function() {
                                        var clone = Base.clone.call(this);
                                        clone.words = this.words.slice(0);

                                        return clone;
                                    },

                                    /**
                                     * Creates a word array filled with random bytes.
                                     *
                                     * @param {number} nBytes The number of random bytes to generate.
                                     *
                                     * @return {WordArray} The random word array.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var wordArray = CryptoJS.lib.WordArray.random(16);
                                     */
                                    random: function(nBytes) {
                                        var words = [];

                                        var r = function(m_w) {
                                            var m_w = m_w;
                                            var m_z = 0x3ade68b1;
                                            var mask = 0xffffffff;

                                            return function() {
                                                m_z =
                                                    (0x9069 * (m_z & 0xffff) +
                                                        (m_z >> 0x10)) &
                                                    mask;
                                                m_w =
                                                    (0x4650 * (m_w & 0xffff) +
                                                        (m_w >> 0x10)) &
                                                    mask;
                                                var result =
                                                    ((m_z << 0x10) + m_w) &
                                                    mask;
                                                result /= 0x100000000;
                                                result += 0.5;
                                                return (
                                                    result *
                                                    (Math.random() > 0.5
                                                        ? 1
                                                        : -1)
                                                );
                                            };
                                        };

                                        for (
                                            var i = 0, rcache;
                                            i < nBytes;
                                            i += 4
                                        ) {
                                            var _r = r(
                                                (rcache || Math.random()) *
                                                    0x100000000
                                            );

                                            rcache = _r() * 0x3ade67b7;
                                            words.push(
                                                (_r() * 0x100000000) | 0
                                            );
                                        }

                                        return new WordArray.init(
                                            words,
                                            nBytes
                                        );
                                    }
                                }));

                                /**
                                 * Encoder namespace.
                                 */
                                var C_enc = (C.enc = {});

                                /**
                                 * Hex encoding strategy.
                                 */
                                var Hex = (C_enc.Hex = {
                                    /**
                                     * Converts a word array to a hex string.
                                     *
                                     * @param {WordArray} wordArray The word array.
                                     *
                                     * @return {string} The hex string.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                                     */
                                    stringify: function(wordArray) {
                                        // Shortcuts
                                        var words = wordArray.words;
                                        var sigBytes = wordArray.sigBytes;

                                        // Convert
                                        var hexChars = [];
                                        for (var i = 0; i < sigBytes; i++) {
                                            var bite =
                                                (words[i >>> 2] >>>
                                                    (24 - (i % 4) * 8)) &
                                                0xff;
                                            hexChars.push(
                                                (bite >>> 4).toString(16)
                                            );
                                            hexChars.push(
                                                (bite & 0x0f).toString(16)
                                            );
                                        }

                                        return hexChars.join("");
                                    },

                                    /**
                                     * Converts a hex string to a word array.
                                     *
                                     * @param {string} hexStr The hex string.
                                     *
                                     * @return {WordArray} The word array.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                                     */
                                    parse: function(hexStr) {
                                        // Shortcut
                                        var hexStrLength = hexStr.length;

                                        // Convert
                                        var words = [];
                                        for (
                                            var i = 0;
                                            i < hexStrLength;
                                            i += 2
                                        ) {
                                            words[i >>> 3] |=
                                                parseInt(
                                                    hexStr.substr(i, 2),
                                                    16
                                                ) <<
                                                (24 - (i % 8) * 4);
                                        }

                                        return new WordArray.init(
                                            words,
                                            hexStrLength / 2
                                        );
                                    }
                                });

                                /**
                                 * Latin1 encoding strategy.
                                 */
                                var Latin1 = (C_enc.Latin1 = {
                                    /**
                                     * Converts a word array to a Latin1 string.
                                     *
                                     * @param {WordArray} wordArray The word array.
                                     *
                                     * @return {string} The Latin1 string.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                                     */
                                    stringify: function(wordArray) {
                                        // Shortcuts
                                        var words = wordArray.words;
                                        var sigBytes = wordArray.sigBytes;

                                        // Convert
                                        var latin1Chars = [];
                                        for (var i = 0; i < sigBytes; i++) {
                                            var bite =
                                                (words[i >>> 2] >>>
                                                    (24 - (i % 4) * 8)) &
                                                0xff;
                                            latin1Chars.push(
                                                String.fromCharCode(bite)
                                            );
                                        }

                                        return latin1Chars.join("");
                                    },

                                    /**
                                     * Converts a Latin1 string to a word array.
                                     *
                                     * @param {string} latin1Str The Latin1 string.
                                     *
                                     * @return {WordArray} The word array.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                                     */
                                    parse: function(latin1Str) {
                                        // Shortcut
                                        var latin1StrLength = latin1Str.length;

                                        // Convert
                                        var words = [];
                                        for (
                                            var i = 0;
                                            i < latin1StrLength;
                                            i++
                                        ) {
                                            words[i >>> 2] |=
                                                (latin1Str.charCodeAt(i) &
                                                    0xff) <<
                                                (24 - (i % 4) * 8);
                                        }

                                        return new WordArray.init(
                                            words,
                                            latin1StrLength
                                        );
                                    }
                                });

                                /**
                                 * UTF-8 encoding strategy.
                                 */
                                var Utf8 = (C_enc.Utf8 = {
                                    /**
                                     * Converts a word array to a UTF-8 string.
                                     *
                                     * @param {WordArray} wordArray The word array.
                                     *
                                     * @return {string} The UTF-8 string.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                                     */
                                    stringify: function(wordArray) {
                                        try {
                                            return decodeURIComponent(
                                                escape(
                                                    Latin1.stringify(wordArray)
                                                )
                                            );
                                        } catch (e) {
                                            throw new Error(
                                                "Malformed UTF-8 data"
                                            );
                                        }
                                    },

                                    /**
                                     * Converts a UTF-8 string to a word array.
                                     *
                                     * @param {string} utf8Str The UTF-8 string.
                                     *
                                     * @return {WordArray} The word array.
                                     *
                                     * @static
                                     *
                                     * @example
                                     *
                                     *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                                     */
                                    parse: function(utf8Str) {
                                        return Latin1.parse(
                                            unescape(
                                                encodeURIComponent(utf8Str)
                                            )
                                        );
                                    }
                                });

                                /**
                                 * Abstract buffered block algorithm template.
                                 *
                                 * The property blockSize must be implemented in a concrete subtype.
                                 *
                                 * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
                                 */
                                var BufferedBlockAlgorithm = (C_lib.BufferedBlockAlgorithm = Base.extend(
                                    {
                                        /**
                                         * Resets this block algorithm's data buffer to its initial state.
                                         *
                                         * @example
                                         *
                                         *     bufferedBlockAlgorithm.reset();
                                         */
                                        reset: function() {
                                            // Initial values
                                            this._data = new WordArray.init();
                                            this._nDataBytes = 0;
                                        },

                                        /**
                                         * Adds new data to this block algorithm's buffer.
                                         *
                                         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                                         *
                                         * @example
                                         *
                                         *     bufferedBlockAlgorithm._append('data');
                                         *     bufferedBlockAlgorithm._append(wordArray);
                                         */
                                        _append: function(data) {
                                            // Convert string to WordArray, else assume WordArray already
                                            if (typeof data == "string") {
                                                data = Utf8.parse(data);
                                            }

                                            // Append
                                            this._data.concat(data);
                                            this._nDataBytes += data.sigBytes;
                                        },

                                        /**
                                         * Processes available data blocks.
                                         *
                                         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                                         *
                                         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                                         *
                                         * @return {WordArray} The processed data.
                                         *
                                         * @example
                                         *
                                         *     var processedData = bufferedBlockAlgorithm._process();
                                         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                                         */
                                        _process: function(doFlush) {
                                            // Shortcuts
                                            var data = this._data;
                                            var dataWords = data.words;
                                            var dataSigBytes = data.sigBytes;
                                            var blockSize = this.blockSize;
                                            var blockSizeBytes = blockSize * 4;

                                            // Count blocks ready
                                            var nBlocksReady =
                                                dataSigBytes / blockSizeBytes;
                                            if (doFlush) {
                                                // Round up to include partial blocks
                                                nBlocksReady = Math.ceil(
                                                    nBlocksReady
                                                );
                                            } else {
                                                // Round down to include only full blocks,
                                                // less the number of blocks that must remain in the buffer
                                                nBlocksReady = Math.max(
                                                    (nBlocksReady | 0) -
                                                        this._minBufferSize,
                                                    0
                                                );
                                            }

                                            // Count words ready
                                            var nWordsReady =
                                                nBlocksReady * blockSize;

                                            // Count bytes ready
                                            var nBytesReady = Math.min(
                                                nWordsReady * 4,
                                                dataSigBytes
                                            );

                                            // Process blocks
                                            if (nWordsReady) {
                                                for (
                                                    var offset = 0;
                                                    offset < nWordsReady;
                                                    offset += blockSize
                                                ) {
                                                    // Perform concrete-algorithm logic
                                                    this._doProcessBlock(
                                                        dataWords,
                                                        offset
                                                    );
                                                }

                                                // Remove processed words
                                                var processedWords = dataWords.splice(
                                                    0,
                                                    nWordsReady
                                                );
                                                data.sigBytes -= nBytesReady;
                                            }

                                            // Return processed words
                                            return new WordArray.init(
                                                processedWords,
                                                nBytesReady
                                            );
                                        },

                                        /**
                                         * Creates a copy of this object.
                                         *
                                         * @return {Object} The clone.
                                         *
                                         * @example
                                         *
                                         *     var clone = bufferedBlockAlgorithm.clone();
                                         */
                                        clone: function() {
                                            var clone = Base.clone.call(this);
                                            clone._data = this._data.clone();

                                            return clone;
                                        },

                                        _minBufferSize: 0
                                    }
                                ));

                                /**
                                 * Abstract hasher template.
                                 *
                                 * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
                                 */
                                var Hasher = (C_lib.Hasher = BufferedBlockAlgorithm.extend(
                                    {
                                        /**
                                         * Configuration options.
                                         */
                                        cfg: Base.extend(),

                                        /**
                                         * Initializes a newly created hasher.
                                         *
                                         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                                         *
                                         * @example
                                         *
                                         *     var hasher = CryptoJS.algo.SHA256.create();
                                         */
                                        init: function(cfg) {
                                            // Apply config defaults
                                            this.cfg = this.cfg.extend(cfg);

                                            // Set initial values
                                            this.reset();
                                        },

                                        /**
                                         * Resets this hasher to its initial state.
                                         *
                                         * @example
                                         *
                                         *     hasher.reset();
                                         */
                                        reset: function() {
                                            // Reset data buffer
                                            BufferedBlockAlgorithm.reset.call(
                                                this
                                            );

                                            // Perform concrete-hasher logic
                                            this._doReset();
                                        },

                                        /**
                                         * Updates this hasher with a message.
                                         *
                                         * @param {WordArray|string} messageUpdate The message to append.
                                         *
                                         * @return {Hasher} This hasher.
                                         *
                                         * @example
                                         *
                                         *     hasher.update('message');
                                         *     hasher.update(wordArray);
                                         */
                                        update: function(messageUpdate) {
                                            // Append
                                            this._append(messageUpdate);

                                            // Update the hash
                                            this._process();

                                            // Chainable
                                            return this;
                                        },

                                        /**
                                         * Finalizes the hash computation.
                                         * Note that the finalize operation is effectively a destructive, read-once operation.
                                         *
                                         * @param {WordArray|string} messageUpdate (Optional) A final message update.
                                         *
                                         * @return {WordArray} The hash.
                                         *
                                         * @example
                                         *
                                         *     var hash = hasher.finalize();
                                         *     var hash = hasher.finalize('message');
                                         *     var hash = hasher.finalize(wordArray);
                                         */
                                        finalize: function(messageUpdate) {
                                            // Final message update
                                            if (messageUpdate) {
                                                this._append(messageUpdate);
                                            }

                                            // Perform concrete-hasher logic
                                            var hash = this._doFinalize();

                                            return hash;
                                        },

                                        blockSize: 512 / 32,

                                        /**
                                         * Creates a shortcut function to a hasher's object interface.
                                         *
                                         * @param {Hasher} hasher The hasher to create a helper for.
                                         *
                                         * @return {Function} The shortcut function.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                                         */
                                        _createHelper: function(hasher) {
                                            return function(message, cfg) {
                                                return new hasher.init(
                                                    cfg
                                                ).finalize(message);
                                            };
                                        },

                                        /**
                                         * Creates a shortcut function to the HMAC's object interface.
                                         *
                                         * @param {Hasher} hasher The hasher to use in this HMAC helper.
                                         *
                                         * @return {Function} The shortcut function.
                                         *
                                         * @static
                                         *
                                         * @example
                                         *
                                         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                                         */
                                        _createHmacHelper: function(hasher) {
                                            return function(message, key) {
                                                return new C_algo.HMAC.init(
                                                    hasher,
                                                    key
                                                ).finalize(message);
                                            };
                                        }
                                    }
                                ));

                                /**
                                 * Algorithm namespace.
                                 */
                                var C_algo = (C.algo = {});

                                return C;
                            })(Math);

                        return CryptoJS;
                    });
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/enc-base64.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function() {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var WordArray = C_lib.WordArray;
                            var C_enc = C.enc;

                            /**
                             * Base64 encoding strategy.
                             */
                            var Base64 = (C_enc.Base64 = {
                                /**
                                 * Converts a word array to a Base64 string.
                                 *
                                 * @param {WordArray} wordArray The word array.
                                 *
                                 * @return {string} The Base64 string.
                                 *
                                 * @static
                                 *
                                 * @example
                                 *
                                 *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                                 */
                                stringify: function(wordArray) {
                                    // Shortcuts
                                    var words = wordArray.words;
                                    var sigBytes = wordArray.sigBytes;
                                    var map = this._map;

                                    // Clamp excess bits
                                    wordArray.clamp();

                                    // Convert
                                    var base64Chars = [];
                                    for (var i = 0; i < sigBytes; i += 3) {
                                        var byte1 =
                                            (words[i >>> 2] >>>
                                                (24 - (i % 4) * 8)) &
                                            0xff;
                                        var byte2 =
                                            (words[(i + 1) >>> 2] >>>
                                                (24 - ((i + 1) % 4) * 8)) &
                                            0xff;
                                        var byte3 =
                                            (words[(i + 2) >>> 2] >>>
                                                (24 - ((i + 2) % 4) * 8)) &
                                            0xff;

                                        var triplet =
                                            (byte1 << 16) |
                                            (byte2 << 8) |
                                            byte3;

                                        for (
                                            var j = 0;
                                            j < 4 && i + j * 0.75 < sigBytes;
                                            j++
                                        ) {
                                            base64Chars.push(
                                                map.charAt(
                                                    (triplet >>>
                                                        (6 * (3 - j))) &
                                                        0x3f
                                                )
                                            );
                                        }
                                    }

                                    // Add padding
                                    var paddingChar = map.charAt(64);
                                    if (paddingChar) {
                                        while (base64Chars.length % 4) {
                                            base64Chars.push(paddingChar);
                                        }
                                    }

                                    return base64Chars.join("");
                                },

                                /**
                                 * Converts a Base64 string to a word array.
                                 *
                                 * @param {string} base64Str The Base64 string.
                                 *
                                 * @return {WordArray} The word array.
                                 *
                                 * @static
                                 *
                                 * @example
                                 *
                                 *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                                 */
                                parse: function(base64Str) {
                                    // Shortcuts
                                    var base64StrLength = base64Str.length;
                                    var map = this._map;
                                    var reverseMap = this._reverseMap;

                                    if (!reverseMap) {
                                        reverseMap = this._reverseMap = [];
                                        for (var j = 0; j < map.length; j++) {
                                            reverseMap[map.charCodeAt(j)] = j;
                                        }
                                    }

                                    // Ignore padding
                                    var paddingChar = map.charAt(64);
                                    if (paddingChar) {
                                        var paddingIndex = base64Str.indexOf(
                                            paddingChar
                                        );
                                        if (paddingIndex !== -1) {
                                            base64StrLength = paddingIndex;
                                        }
                                    }

                                    // Convert
                                    return parseLoop(
                                        base64Str,
                                        base64StrLength,
                                        reverseMap
                                    );
                                },

                                _map:
                                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                            });

                            function parseLoop(
                                base64Str,
                                base64StrLength,
                                reverseMap
                            ) {
                                var words = [];
                                var nBytes = 0;
                                for (var i = 0; i < base64StrLength; i++) {
                                    if (i % 4) {
                                        var bits1 =
                                            reverseMap[
                                                base64Str.charCodeAt(i - 1)
                                            ] <<
                                            ((i % 4) * 2);
                                        var bits2 =
                                            reverseMap[
                                                base64Str.charCodeAt(i)
                                            ] >>>
                                            (6 - (i % 4) * 2);
                                        words[nBytes >>> 2] |=
                                            (bits1 | bits2) <<
                                            (24 - (nBytes % 4) * 8);
                                        nBytes++;
                                    }
                                }
                                return WordArray.create(words, nBytes);
                            }
                        })();

                        return CryptoJS.enc.Base64;
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/enc-hex.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        return CryptoJS.enc.Hex;
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/evpkdf.js": [
                function(require, module, exports) {
                    (function(root, factory, undef) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core"),
                                require("./sha1"),
                                require("./hmac")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core", "./sha1", "./hmac"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function() {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var Base = C_lib.Base;
                            var WordArray = C_lib.WordArray;
                            var C_algo = C.algo;
                            var MD5 = C_algo.MD5;

                            /**
                             * This key derivation function is meant to conform with EVP_BytesToKey.
                             * www.openssl.org/docs/crypto/EVP_BytesToKey.html
                             */
                            var EvpKDF = (C_algo.EvpKDF = Base.extend({
                                /**
                                 * Configuration options.
                                 *
                                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                                 * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                                 * @property {number} iterations The number of iterations to perform. Default: 1
                                 */
                                cfg: Base.extend({
                                    keySize: 128 / 32,
                                    hasher: MD5,
                                    iterations: 1
                                }),

                                /**
                                 * Initializes a newly created key derivation function.
                                 *
                                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                                 *
                                 * @example
                                 *
                                 *     var kdf = CryptoJS.algo.EvpKDF.create();
                                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                                 */
                                init: function(cfg) {
                                    this.cfg = this.cfg.extend(cfg);
                                },

                                /**
                                 * Derives a key from a password.
                                 *
                                 * @param {WordArray|string} password The password.
                                 * @param {WordArray|string} salt A salt.
                                 *
                                 * @return {WordArray} The derived key.
                                 *
                                 * @example
                                 *
                                 *     var key = kdf.compute(password, salt);
                                 */
                                compute: function(password, salt) {
                                    // Shortcut
                                    var cfg = this.cfg;

                                    // Init hasher
                                    var hasher = cfg.hasher.create();

                                    // Initial values
                                    var derivedKey = WordArray.create();

                                    // Shortcuts
                                    var derivedKeyWords = derivedKey.words;
                                    var keySize = cfg.keySize;
                                    var iterations = cfg.iterations;

                                    // Generate key
                                    while (derivedKeyWords.length < keySize) {
                                        if (block) {
                                            hasher.update(block);
                                        }
                                        var block = hasher
                                            .update(password)
                                            .finalize(salt);
                                        hasher.reset();

                                        // Iterations
                                        for (var i = 1; i < iterations; i++) {
                                            block = hasher.finalize(block);
                                            hasher.reset();
                                        }

                                        derivedKey.concat(block);
                                    }
                                    derivedKey.sigBytes = keySize * 4;

                                    return derivedKey;
                                }
                            }));

                            /**
                             * Derives a key from a password.
                             *
                             * @param {WordArray|string} password The password.
                             * @param {WordArray|string} salt A salt.
                             * @param {Object} cfg (Optional) The configuration options to use for this computation.
                             *
                             * @return {WordArray} The derived key.
                             *
                             * @static
                             *
                             * @example
                             *
                             *     var key = CryptoJS.EvpKDF(password, salt);
                             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
                             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
                             */
                            C.EvpKDF = function(password, salt, cfg) {
                                return EvpKDF.create(cfg).compute(
                                    password,
                                    salt
                                );
                            };
                        })();

                        return CryptoJS.EvpKDF;
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js",
                    "./hmac":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/hmac.js",
                    "./sha1":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/sha1.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/hmac.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function() {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var Base = C_lib.Base;
                            var C_enc = C.enc;
                            var Utf8 = C_enc.Utf8;
                            var C_algo = C.algo;

                            /**
                             * HMAC algorithm.
                             */
                            var HMAC = (C_algo.HMAC = Base.extend({
                                /**
                                 * Initializes a newly created HMAC.
                                 *
                                 * @param {Hasher} hasher The hash algorithm to use.
                                 * @param {WordArray|string} key The secret key.
                                 *
                                 * @example
                                 *
                                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                                 */
                                init: function(hasher, key) {
                                    // Init hasher
                                    hasher = this._hasher = new hasher.init();

                                    // Convert string to WordArray, else assume WordArray already
                                    if (typeof key == "string") {
                                        key = Utf8.parse(key);
                                    }

                                    // Shortcuts
                                    var hasherBlockSize = hasher.blockSize;
                                    var hasherBlockSizeBytes =
                                        hasherBlockSize * 4;

                                    // Allow arbitrary length keys
                                    if (key.sigBytes > hasherBlockSizeBytes) {
                                        key = hasher.finalize(key);
                                    }

                                    // Clamp excess bits
                                    key.clamp();

                                    // Clone key for inner and outer pads
                                    var oKey = (this._oKey = key.clone());
                                    var iKey = (this._iKey = key.clone());

                                    // Shortcuts
                                    var oKeyWords = oKey.words;
                                    var iKeyWords = iKey.words;

                                    // XOR keys with pad constants
                                    for (var i = 0; i < hasherBlockSize; i++) {
                                        oKeyWords[i] ^= 0x5c5c5c5c;
                                        iKeyWords[i] ^= 0x36363636;
                                    }
                                    oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

                                    // Set initial values
                                    this.reset();
                                },

                                /**
                                 * Resets this HMAC to its initial state.
                                 *
                                 * @example
                                 *
                                 *     hmacHasher.reset();
                                 */
                                reset: function() {
                                    // Shortcut
                                    var hasher = this._hasher;

                                    // Reset
                                    hasher.reset();
                                    hasher.update(this._iKey);
                                },

                                /**
                                 * Updates this HMAC with a message.
                                 *
                                 * @param {WordArray|string} messageUpdate The message to append.
                                 *
                                 * @return {HMAC} This HMAC instance.
                                 *
                                 * @example
                                 *
                                 *     hmacHasher.update('message');
                                 *     hmacHasher.update(wordArray);
                                 */
                                update: function(messageUpdate) {
                                    this._hasher.update(messageUpdate);

                                    // Chainable
                                    return this;
                                },

                                /**
                                 * Finalizes the HMAC computation.
                                 * Note that the finalize operation is effectively a destructive, read-once operation.
                                 *
                                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                                 *
                                 * @return {WordArray} The HMAC.
                                 *
                                 * @example
                                 *
                                 *     var hmac = hmacHasher.finalize();
                                 *     var hmac = hmacHasher.finalize('message');
                                 *     var hmac = hmacHasher.finalize(wordArray);
                                 */
                                finalize: function(messageUpdate) {
                                    // Shortcut
                                    var hasher = this._hasher;

                                    // Compute HMAC
                                    var innerHash = hasher.finalize(
                                        messageUpdate
                                    );
                                    hasher.reset();
                                    var hmac = hasher.finalize(
                                        this._oKey.clone().concat(innerHash)
                                    );

                                    return hmac;
                                }
                            }));
                        })();
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/md5.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function(Math) {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var WordArray = C_lib.WordArray;
                            var Hasher = C_lib.Hasher;
                            var C_algo = C.algo;

                            // Constants table
                            var T = [];

                            // Compute constants
                            (function() {
                                for (var i = 0; i < 64; i++) {
                                    T[i] =
                                        (Math.abs(Math.sin(i + 1)) *
                                            0x100000000) |
                                        0;
                                }
                            })();

                            /**
                             * MD5 hash algorithm.
                             */
                            var MD5 = (C_algo.MD5 = Hasher.extend({
                                _doReset: function() {
                                    this._hash = new WordArray.init([
                                        0x67452301,
                                        0xefcdab89,
                                        0x98badcfe,
                                        0x10325476
                                    ]);
                                },

                                _doProcessBlock: function(M, offset) {
                                    // Swap endian
                                    for (var i = 0; i < 16; i++) {
                                        // Shortcuts
                                        var offset_i = offset + i;
                                        var M_offset_i = M[offset_i];

                                        M[offset_i] =
                                            (((M_offset_i << 8) |
                                                (M_offset_i >>> 24)) &
                                                0x00ff00ff) |
                                            (((M_offset_i << 24) |
                                                (M_offset_i >>> 8)) &
                                                0xff00ff00);
                                    }

                                    // Shortcuts
                                    var H = this._hash.words;

                                    var M_offset_0 = M[offset + 0];
                                    var M_offset_1 = M[offset + 1];
                                    var M_offset_2 = M[offset + 2];
                                    var M_offset_3 = M[offset + 3];
                                    var M_offset_4 = M[offset + 4];
                                    var M_offset_5 = M[offset + 5];
                                    var M_offset_6 = M[offset + 6];
                                    var M_offset_7 = M[offset + 7];
                                    var M_offset_8 = M[offset + 8];
                                    var M_offset_9 = M[offset + 9];
                                    var M_offset_10 = M[offset + 10];
                                    var M_offset_11 = M[offset + 11];
                                    var M_offset_12 = M[offset + 12];
                                    var M_offset_13 = M[offset + 13];
                                    var M_offset_14 = M[offset + 14];
                                    var M_offset_15 = M[offset + 15];

                                    // Working varialbes
                                    var a = H[0];
                                    var b = H[1];
                                    var c = H[2];
                                    var d = H[3];

                                    // Computation
                                    a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                                    d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                                    c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                                    b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                                    a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                                    d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                                    c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                                    b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                                    a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                                    d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                                    a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);

                                    a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                                    d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                                    b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                                    a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                                    d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                                    b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                                    a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                                    d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                                    c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                                    b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                                    a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                                    d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                                    c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);

                                    a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                                    d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                                    a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                                    d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                                    c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                                    a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                                    d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                                    c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                                    b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                                    a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                                    b = HH(b, c, d, a, M_offset_2, 23, T[47]);

                                    a = II(a, b, c, d, M_offset_0, 6, T[48]);
                                    d = II(d, a, b, c, M_offset_7, 10, T[49]);
                                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                                    b = II(b, c, d, a, M_offset_5, 21, T[51]);
                                    a = II(a, b, c, d, M_offset_12, 6, T[52]);
                                    d = II(d, a, b, c, M_offset_3, 10, T[53]);
                                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                                    b = II(b, c, d, a, M_offset_1, 21, T[55]);
                                    a = II(a, b, c, d, M_offset_8, 6, T[56]);
                                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                                    c = II(c, d, a, b, M_offset_6, 15, T[58]);
                                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                                    a = II(a, b, c, d, M_offset_4, 6, T[60]);
                                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                                    c = II(c, d, a, b, M_offset_2, 15, T[62]);
                                    b = II(b, c, d, a, M_offset_9, 21, T[63]);

                                    // Intermediate hash value
                                    H[0] = (H[0] + a) | 0;
                                    H[1] = (H[1] + b) | 0;
                                    H[2] = (H[2] + c) | 0;
                                    H[3] = (H[3] + d) | 0;
                                },

                                _doFinalize: function() {
                                    // Shortcuts
                                    var data = this._data;
                                    var dataWords = data.words;

                                    var nBitsTotal = this._nDataBytes * 8;
                                    var nBitsLeft = data.sigBytes * 8;

                                    // Add padding
                                    dataWords[nBitsLeft >>> 5] |=
                                        0x80 << (24 - nBitsLeft % 32);

                                    var nBitsTotalH = Math.floor(
                                        nBitsTotal / 0x100000000
                                    );
                                    var nBitsTotalL = nBitsTotal;
                                    dataWords[
                                        (((nBitsLeft + 64) >>> 9) << 4) + 15
                                    ] =
                                        (((nBitsTotalH << 8) |
                                            (nBitsTotalH >>> 24)) &
                                            0x00ff00ff) |
                                        (((nBitsTotalH << 24) |
                                            (nBitsTotalH >>> 8)) &
                                            0xff00ff00);
                                    dataWords[
                                        (((nBitsLeft + 64) >>> 9) << 4) + 14
                                    ] =
                                        (((nBitsTotalL << 8) |
                                            (nBitsTotalL >>> 24)) &
                                            0x00ff00ff) |
                                        (((nBitsTotalL << 24) |
                                            (nBitsTotalL >>> 8)) &
                                            0xff00ff00);

                                    data.sigBytes = (dataWords.length + 1) * 4;

                                    // Hash final blocks
                                    this._process();

                                    // Shortcuts
                                    var hash = this._hash;
                                    var H = hash.words;

                                    // Swap endian
                                    for (var i = 0; i < 4; i++) {
                                        // Shortcut
                                        var H_i = H[i];

                                        H[i] =
                                            (((H_i << 8) | (H_i >>> 24)) &
                                                0x00ff00ff) |
                                            (((H_i << 24) | (H_i >>> 8)) &
                                                0xff00ff00);
                                    }

                                    // Return final computed hash
                                    return hash;
                                },

                                clone: function() {
                                    var clone = Hasher.clone.call(this);
                                    clone._hash = this._hash.clone();

                                    return clone;
                                }
                            }));

                            function FF(a, b, c, d, x, s, t) {
                                var n = a + ((b & c) | (~b & d)) + x + t;
                                return ((n << s) | (n >>> (32 - s))) + b;
                            }

                            function GG(a, b, c, d, x, s, t) {
                                var n = a + ((b & d) | (c & ~d)) + x + t;
                                return ((n << s) | (n >>> (32 - s))) + b;
                            }

                            function HH(a, b, c, d, x, s, t) {
                                var n = a + (b ^ c ^ d) + x + t;
                                return ((n << s) | (n >>> (32 - s))) + b;
                            }

                            function II(a, b, c, d, x, s, t) {
                                var n = a + (c ^ (b | ~d)) + x + t;
                                return ((n << s) | (n >>> (32 - s))) + b;
                            }

                            /**
                             * Shortcut function to the hasher's object interface.
                             *
                             * @param {WordArray|string} message The message to hash.
                             *
                             * @return {WordArray} The hash.
                             *
                             * @static
                             *
                             * @example
                             *
                             *     var hash = CryptoJS.MD5('message');
                             *     var hash = CryptoJS.MD5(wordArray);
                             */
                            C.MD5 = Hasher._createHelper(MD5);

                            /**
                             * Shortcut function to the HMAC's object interface.
                             *
                             * @param {WordArray|string} message The message to hash.
                             * @param {WordArray|string} key The secret key.
                             *
                             * @return {WordArray} The HMAC.
                             *
                             * @static
                             *
                             * @example
                             *
                             *     var hmac = CryptoJS.HmacMD5(message, key);
                             */
                            C.HmacMD5 = Hasher._createHmacHelper(MD5);
                        })(Math);

                        return CryptoJS.MD5;
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/sha1.js": [
                function(require, module, exports) {
                    (function(root, factory) {
                        if (typeof exports === "object") {
                            // CommonJS
                            module.exports = exports = factory(
                                require("./core")
                            );
                        } else if (typeof define === "function" && define.amd) {
                            // AMD
                            define(["./core"], factory);
                        } else {
                            // Global (browser)
                            factory(root.CryptoJS);
                        }
                    })(this, function(CryptoJS) {
                        (function() {
                            // Shortcuts
                            var C = CryptoJS;
                            var C_lib = C.lib;
                            var WordArray = C_lib.WordArray;
                            var Hasher = C_lib.Hasher;
                            var C_algo = C.algo;

                            // Reusable object
                            var W = [];

                            /**
                             * SHA-1 hash algorithm.
                             */
                            var SHA1 = (C_algo.SHA1 = Hasher.extend({
                                _doReset: function() {
                                    this._hash = new WordArray.init([
                                        0x67452301,
                                        0xefcdab89,
                                        0x98badcfe,
                                        0x10325476,
                                        0xc3d2e1f0
                                    ]);
                                },

                                _doProcessBlock: function(M, offset) {
                                    // Shortcut
                                    var H = this._hash.words;

                                    // Working variables
                                    var a = H[0];
                                    var b = H[1];
                                    var c = H[2];
                                    var d = H[3];
                                    var e = H[4];

                                    // Computation
                                    for (var i = 0; i < 80; i++) {
                                        if (i < 16) {
                                            W[i] = M[offset + i] | 0;
                                        } else {
                                            var n =
                                                W[i - 3] ^
                                                W[i - 8] ^
                                                W[i - 14] ^
                                                W[i - 16];
                                            W[i] = (n << 1) | (n >>> 31);
                                        }

                                        var t =
                                            ((a << 5) | (a >>> 27)) + e + W[i];
                                        if (i < 20) {
                                            t +=
                                                ((b & c) | (~b & d)) +
                                                0x5a827999;
                                        } else if (i < 40) {
                                            t += (b ^ c ^ d) + 0x6ed9eba1;
                                        } else if (i < 60) {
                                            t +=
                                                ((b & c) | (b & d) | (c & d)) -
                                                0x70e44324;
                                        } /* if (i < 80) */ else {
                                            t += (b ^ c ^ d) - 0x359d3e2a;
                                        }

                                        e = d;
                                        d = c;
                                        c = (b << 30) | (b >>> 2);
                                        b = a;
                                        a = t;
                                    }

                                    // Intermediate hash value
                                    H[0] = (H[0] + a) | 0;
                                    H[1] = (H[1] + b) | 0;
                                    H[2] = (H[2] + c) | 0;
                                    H[3] = (H[3] + d) | 0;
                                    H[4] = (H[4] + e) | 0;
                                },

                                _doFinalize: function() {
                                    // Shortcuts
                                    var data = this._data;
                                    var dataWords = data.words;

                                    var nBitsTotal = this._nDataBytes * 8;
                                    var nBitsLeft = data.sigBytes * 8;

                                    // Add padding
                                    dataWords[nBitsLeft >>> 5] |=
                                        0x80 << (24 - nBitsLeft % 32);
                                    dataWords[
                                        (((nBitsLeft + 64) >>> 9) << 4) + 14
                                    ] = Math.floor(nBitsTotal / 0x100000000);
                                    dataWords[
                                        (((nBitsLeft + 64) >>> 9) << 4) + 15
                                    ] = nBitsTotal;
                                    data.sigBytes = dataWords.length * 4;

                                    // Hash final blocks
                                    this._process();

                                    // Return final computed hash
                                    return this._hash;
                                },

                                clone: function() {
                                    var clone = Hasher.clone.call(this);
                                    clone._hash = this._hash.clone();

                                    return clone;
                                }
                            }));

                            /**
                             * Shortcut function to the hasher's object interface.
                             *
                             * @param {WordArray|string} message The message to hash.
                             *
                             * @return {WordArray} The hash.
                             *
                             * @static
                             *
                             * @example
                             *
                             *     var hash = CryptoJS.SHA1('message');
                             *     var hash = CryptoJS.SHA1(wordArray);
                             */
                            C.SHA1 = Hasher._createHelper(SHA1);

                            /**
                             * Shortcut function to the HMAC's object interface.
                             *
                             * @param {WordArray|string} message The message to hash.
                             * @param {WordArray|string} key The secret key.
                             *
                             * @return {WordArray} The HMAC.
                             *
                             * @static
                             *
                             * @example
                             *
                             *     var hmac = CryptoJS.HmacSHA1(message, key);
                             */
                            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
                        })();

                        return CryptoJS.SHA1;
                    });
                },
                {
                    "./core":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/crypto-js/core.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/index.js": [
                function(require, module, exports) {
                    var pSlice = Array.prototype.slice;
                    var objectKeys = require("./lib/keys.js");
                    var isArguments = require("./lib/is_arguments.js");

                    var deepEqual = (module.exports = function(
                        actual,
                        expected,
                        opts
                    ) {
                        if (!opts) opts = {};
                        // 7.1. All identical values are equivalent, as determined by ===.
                        if (actual === expected) {
                            return true;
                        } else if (
                            actual instanceof Date &&
                            expected instanceof Date
                        ) {
                            return actual.getTime() === expected.getTime();

                            // 7.3. Other pairs that do not both pass typeof value == 'object',
                            // equivalence is determined by ==.
                        } else if (
                            !actual ||
                            !expected ||
                            (typeof actual != "object" &&
                                typeof expected != "object")
                        ) {
                            return opts.strict
                                ? actual === expected
                                : actual == expected;

                            // 7.4. For all other Object pairs, including Array objects, equivalence is
                            // determined by having the same number of owned properties (as verified
                            // with Object.prototype.hasOwnProperty.call), the same set of keys
                            // (although not necessarily the same order), equivalent values for every
                            // corresponding key, and an identical 'prototype' property. Note: this
                            // accounts for both named and indexed properties on Arrays.
                        } else {
                            return objEquiv(actual, expected, opts);
                        }
                    });

                    function isUndefinedOrNull(value) {
                        return value === null || value === undefined;
                    }

                    function isBuffer(x) {
                        if (
                            !x ||
                            typeof x !== "object" ||
                            typeof x.length !== "number"
                        )
                            return false;
                        if (
                            typeof x.copy !== "function" ||
                            typeof x.slice !== "function"
                        ) {
                            return false;
                        }
                        if (x.length > 0 && typeof x[0] !== "number")
                            return false;
                        return true;
                    }

                    function objEquiv(a, b, opts) {
                        var i, key;
                        if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
                            return false;
                        // an identical 'prototype' property.
                        if (a.prototype !== b.prototype) return false;
                        //~~~I've managed to break Object.keys through screwy arguments passing.
                        //   Converting to array solves the problem.
                        if (isArguments(a)) {
                            if (!isArguments(b)) {
                                return false;
                            }
                            a = pSlice.call(a);
                            b = pSlice.call(b);
                            return deepEqual(a, b, opts);
                        }
                        if (isBuffer(a)) {
                            if (!isBuffer(b)) {
                                return false;
                            }
                            if (a.length !== b.length) return false;
                            for (i = 0; i < a.length; i++) {
                                if (a[i] !== b[i]) return false;
                            }
                            return true;
                        }
                        try {
                            var ka = objectKeys(a),
                                kb = objectKeys(b);
                        } catch (e) {
                            //happens when one is a string literal and the other isn't
                            return false;
                        }
                        // having the same number of owned properties (keys incorporates
                        // hasOwnProperty)
                        if (ka.length != kb.length) return false;
                        //the same set of keys (although not necessarily the same order),
                        ka.sort();
                        kb.sort();
                        //~~~cheap key test
                        for (i = ka.length - 1; i >= 0; i--) {
                            if (ka[i] != kb[i]) return false;
                        }
                        //equivalent values for every corresponding key, and
                        //~~~possibly expensive deep test
                        for (i = ka.length - 1; i >= 0; i--) {
                            key = ka[i];
                            if (!deepEqual(a[key], b[key], opts)) return false;
                        }
                        return typeof a === typeof b;
                    }
                },
                {
                    "./lib/is_arguments.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/lib/is_arguments.js",
                    "./lib/keys.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/lib/keys.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/lib/is_arguments.js": [
                function(require, module, exports) {
                    var supportsArgumentsClass =
                        (function() {
                            return Object.prototype.toString.call(arguments);
                        })() == "[object Arguments]";

                    exports = module.exports = supportsArgumentsClass
                        ? supported
                        : unsupported;

                    exports.supported = supported;
                    function supported(object) {
                        return (
                            Object.prototype.toString.call(object) ==
                            "[object Arguments]"
                        );
                    }

                    exports.unsupported = unsupported;
                    function unsupported(object) {
                        return (
                            (object &&
                                typeof object == "object" &&
                                typeof object.length == "number" &&
                                Object.prototype.hasOwnProperty.call(
                                    object,
                                    "callee"
                                ) &&
                                !Object.prototype.propertyIsEnumerable.call(
                                    object,
                                    "callee"
                                )) ||
                            false
                        );
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/deep-equal/lib/keys.js": [
                function(require, module, exports) {
                    exports = module.exports =
                        typeof Object.keys === "function" ? Object.keys : shim;

                    exports.shim = shim;
                    function shim(obj) {
                        var keys = [];
                        for (var key in obj) keys.push(key);
                        return keys;
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/curve.js": [
                function(require, module, exports) {
                    var assert = require("assert");
                    var BigInteger = require("bigi");

                    var Point = require("./point");

                    function Curve(p, a, b, Gx, Gy, n, h) {
                        this.p = p;
                        this.a = a;
                        this.b = b;
                        this.G = Point.fromAffine(this, Gx, Gy);
                        this.n = n;
                        this.h = h;

                        this.infinity = new Point(
                            this,
                            null,
                            null,
                            BigInteger.ZERO
                        );

                        // result caching
                        this.pOverFour = p.add(BigInteger.ONE).shiftRight(2);

                        // determine size of p in bytes
                        this.pLength = Math.floor((this.p.bitLength() + 7) / 8);
                    }

                    Curve.prototype.pointFromX = function(isOdd, x) {
                        var alpha = x
                            .pow(3)
                            .add(this.a.multiply(x))
                            .add(this.b)
                            .mod(this.p);
                        var beta = alpha.modPow(this.pOverFour, this.p); // XXX: not compatible with all curves

                        var y = beta;
                        if (beta.isEven() ^ !isOdd) {
                            y = this.p.subtract(y); // -y % p
                        }

                        return Point.fromAffine(this, x, y);
                    };

                    Curve.prototype.isInfinity = function(Q) {
                        if (Q === this.infinity) return true;

                        return Q.z.signum() === 0 && Q.y.signum() !== 0;
                    };

                    Curve.prototype.isOnCurve = function(Q) {
                        if (this.isInfinity(Q)) return true;

                        var x = Q.affineX;
                        var y = Q.affineY;
                        var a = this.a;
                        var b = this.b;
                        var p = this.p;

                        // Check that xQ and yQ are integers in the interval [0, p - 1]
                        if (x.signum() < 0 || x.compareTo(p) >= 0) return false;
                        if (y.signum() < 0 || y.compareTo(p) >= 0) return false;

                        // and check that y^2 = x^3 + ax + b (mod p)
                        var lhs = y.square().mod(p);
                        var rhs = x
                            .pow(3)
                            .add(a.multiply(x))
                            .add(b)
                            .mod(p);
                        return lhs.equals(rhs);
                    };

                    /**
                     * Validate an elliptic curve point.
                     *
                     * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
                     */
                    Curve.prototype.validate = function(Q) {
                        // Check Q != O
                        assert(!this.isInfinity(Q), "Point is at infinity");
                        assert(this.isOnCurve(Q), "Point is not on the curve");

                        // Check nQ = O (where Q is a scalar multiple of G)
                        var nQ = Q.multiply(this.n);
                        assert(
                            this.isInfinity(nQ),
                            "Point is not a scalar multiple of G"
                        );

                        return true;
                    };

                    module.exports = Curve;
                },
                {
                    "./point":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/point.js",
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/curves.json": [
                function(require, module, exports) {
                    module.exports = {
                        secp128r1: {
                            p: "fffffffdffffffffffffffffffffffff",
                            a: "fffffffdfffffffffffffffffffffffc",
                            b: "e87579c11079f43dd824993c2cee5ed3",
                            n: "fffffffe0000000075a30d1b9038a115",
                            h: "01",
                            Gx: "161ff7528b899b2d0c28607ca52c5b86",
                            Gy: "cf5ac8395bafeb13c02da292dded7a83"
                        },
                        secp160k1: {
                            p: "fffffffffffffffffffffffffffffffeffffac73",
                            a: "00",
                            b: "07",
                            n: "0100000000000000000001b8fa16dfab9aca16b6b3",
                            h: "01",
                            Gx: "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
                            Gy: "938cf935318fdced6bc28286531733c3f03c4fee"
                        },
                        secp160r1: {
                            p: "ffffffffffffffffffffffffffffffff7fffffff",
                            a: "ffffffffffffffffffffffffffffffff7ffffffc",
                            b: "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
                            n: "0100000000000000000001f4c8f927aed3ca752257",
                            h: "01",
                            Gx: "4a96b5688ef573284664698968c38bb913cbfc82",
                            Gy: "23a628553168947d59dcc912042351377ac5fb32"
                        },
                        secp192k1: {
                            p:
                                "fffffffffffffffffffffffffffffffffffffffeffffee37",
                            a: "00",
                            b: "03",
                            n:
                                "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
                            h: "01",
                            Gx:
                                "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
                            Gy:
                                "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
                        },
                        secp192r1: {
                            p:
                                "fffffffffffffffffffffffffffffffeffffffffffffffff",
                            a:
                                "fffffffffffffffffffffffffffffffefffffffffffffffc",
                            b:
                                "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
                            n:
                                "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
                            h: "01",
                            Gx:
                                "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
                            Gy:
                                "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
                        },
                        secp256k1: {
                            p:
                                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
                            a: "00",
                            b: "07",
                            n:
                                "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
                            h: "01",
                            Gx:
                                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                            Gy:
                                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
                        },
                        secp256r1: {
                            p:
                                "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
                            a:
                                "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
                            b:
                                "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
                            n:
                                "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
                            h: "01",
                            Gx:
                                "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
                            Gy:
                                "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
                        }
                    };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/index.js": [
                function(require, module, exports) {
                    var Point = require("./point");
                    var Curve = require("./curve");

                    var getCurveByName = require("./names");

                    module.exports = {
                        Curve: Curve,
                        Point: Point,
                        getCurveByName: getCurveByName
                    };
                },
                {
                    "./curve":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/curve.js",
                    "./names":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/names.js",
                    "./point":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/point.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/names.js": [
                function(require, module, exports) {
                    var BigInteger = require("bigi");

                    var curves = require("./curves.json");
                    var Curve = require("./curve");

                    function getCurveByName(name) {
                        var curve = curves[name];
                        if (!curve) return null;

                        var p = new BigInteger(curve.p, 16);
                        var a = new BigInteger(curve.a, 16);
                        var b = new BigInteger(curve.b, 16);
                        var n = new BigInteger(curve.n, 16);
                        var h = new BigInteger(curve.h, 16);
                        var Gx = new BigInteger(curve.Gx, 16);
                        var Gy = new BigInteger(curve.Gy, 16);

                        return new Curve(p, a, b, Gx, Gy, n, h);
                    }

                    module.exports = getCurveByName;
                },
                {
                    "./curve":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/curve.js",
                    "./curves.json":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/curves.json",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ecurve/lib/point.js": [
                function(require, module, exports) {
                    var assert = require("assert");
                    var Buffer = require("safe-buffer").Buffer;
                    var BigInteger = require("bigi");

                    var THREE = BigInteger.valueOf(3);

                    function Point(curve, x, y, z) {
                        assert.notStrictEqual(
                            z,
                            undefined,
                            "Missing Z coordinate"
                        );

                        this.curve = curve;
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this._zInv = null;

                        this.compressed = true;
                    }

                    Object.defineProperty(Point.prototype, "zInv", {
                        get: function() {
                            if (this._zInv === null) {
                                this._zInv = this.z.modInverse(this.curve.p);
                            }

                            return this._zInv;
                        }
                    });

                    Object.defineProperty(Point.prototype, "affineX", {
                        get: function() {
                            return this.x.multiply(this.zInv).mod(this.curve.p);
                        }
                    });

                    Object.defineProperty(Point.prototype, "affineY", {
                        get: function() {
                            return this.y.multiply(this.zInv).mod(this.curve.p);
                        }
                    });

                    Point.fromAffine = function(curve, x, y) {
                        return new Point(curve, x, y, BigInteger.ONE);
                    };

                    Point.prototype.equals = function(other) {
                        if (other === this) return true;
                        if (this.curve.isInfinity(this))
                            return this.curve.isInfinity(other);
                        if (this.curve.isInfinity(other))
                            return this.curve.isInfinity(this);

                        // u = Y2 * Z1 - Y1 * Z2
                        var u = other.y
                            .multiply(this.z)
                            .subtract(this.y.multiply(other.z))
                            .mod(this.curve.p);

                        if (u.signum() !== 0) return false;

                        // v = X2 * Z1 - X1 * Z2
                        var v = other.x
                            .multiply(this.z)
                            .subtract(this.x.multiply(other.z))
                            .mod(this.curve.p);

                        return v.signum() === 0;
                    };

                    Point.prototype.negate = function() {
                        var y = this.curve.p.subtract(this.y);

                        return new Point(this.curve, this.x, y, this.z);
                    };

                    Point.prototype.add = function(b) {
                        if (this.curve.isInfinity(this)) return b;
                        if (this.curve.isInfinity(b)) return this;

                        var x1 = this.x;
                        var y1 = this.y;
                        var x2 = b.x;
                        var y2 = b.y;

                        // u = Y2 * Z1 - Y1 * Z2
                        var u = y2
                            .multiply(this.z)
                            .subtract(y1.multiply(b.z))
                            .mod(this.curve.p);
                        // v = X2 * Z1 - X1 * Z2
                        var v = x2
                            .multiply(this.z)
                            .subtract(x1.multiply(b.z))
                            .mod(this.curve.p);

                        if (v.signum() === 0) {
                            if (u.signum() === 0) {
                                return this.twice(); // this == b, so double
                            }

                            return this.curve.infinity; // this = -b, so infinity
                        }

                        var v2 = v.square();
                        var v3 = v2.multiply(v);
                        var x1v2 = x1.multiply(v2);
                        var zu2 = u.square().multiply(this.z);

                        // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
                        var x3 = zu2
                            .subtract(x1v2.shiftLeft(1))
                            .multiply(b.z)
                            .subtract(v3)
                            .multiply(v)
                            .mod(this.curve.p);
                        // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
                        var y3 = x1v2
                            .multiply(THREE)
                            .multiply(u)
                            .subtract(y1.multiply(v3))
                            .subtract(zu2.multiply(u))
                            .multiply(b.z)
                            .add(u.multiply(v3))
                            .mod(this.curve.p);
                        // z3 = v^3 * z1 * z2
                        var z3 = v3
                            .multiply(this.z)
                            .multiply(b.z)
                            .mod(this.curve.p);

                        return new Point(this.curve, x3, y3, z3);
                    };

                    Point.prototype.twice = function() {
                        if (this.curve.isInfinity(this)) return this;
                        if (this.y.signum() === 0) return this.curve.infinity;

                        var x1 = this.x;
                        var y1 = this.y;

                        var y1z1 = y1.multiply(this.z).mod(this.curve.p);
                        var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);
                        var a = this.curve.a;

                        // w = 3 * x1^2 + a * z1^2
                        var w = x1.square().multiply(THREE);

                        if (a.signum() !== 0) {
                            w = w.add(this.z.square().multiply(a));
                        }

                        w = w.mod(this.curve.p);
                        // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
                        var x3 = w
                            .square()
                            .subtract(x1.shiftLeft(3).multiply(y1sqz1))
                            .shiftLeft(1)
                            .multiply(y1z1)
                            .mod(this.curve.p);
                        // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
                        var y3 = w
                            .multiply(THREE)
                            .multiply(x1)
                            .subtract(y1sqz1.shiftLeft(1))
                            .shiftLeft(2)
                            .multiply(y1sqz1)
                            .subtract(w.pow(3))
                            .mod(this.curve.p);
                        // z3 = 8 * (y1 * z1)^3
                        var z3 = y1z1
                            .pow(3)
                            .shiftLeft(3)
                            .mod(this.curve.p);

                        return new Point(this.curve, x3, y3, z3);
                    };

                    // Simple NAF (Non-Adjacent Form) multiplication algorithm
                    // TODO: modularize the multiplication algorithm
                    Point.prototype.multiply = function(k) {
                        if (this.curve.isInfinity(this)) return this;
                        if (k.signum() === 0) return this.curve.infinity;

                        var e = k;
                        var h = e.multiply(THREE);

                        var neg = this.negate();
                        var R = this;

                        for (var i = h.bitLength() - 2; i > 0; --i) {
                            var hBit = h.testBit(i);
                            var eBit = e.testBit(i);

                            R = R.twice();

                            if (hBit !== eBit) {
                                R = R.add(hBit ? this : neg);
                            }
                        }

                        return R;
                    };

                    // Compute this*j + x*k (simultaneous multiplication)
                    Point.prototype.multiplyTwo = function(j, x, k) {
                        var i = Math.max(j.bitLength(), k.bitLength()) - 1;
                        var R = this.curve.infinity;
                        var both = this.add(x);

                        while (i >= 0) {
                            var jBit = j.testBit(i);
                            var kBit = k.testBit(i);

                            R = R.twice();

                            if (jBit) {
                                if (kBit) {
                                    R = R.add(both);
                                } else {
                                    R = R.add(this);
                                }
                            } else if (kBit) {
                                R = R.add(x);
                            }
                            --i;
                        }

                        return R;
                    };

                    Point.prototype.getEncoded = function(compressed) {
                        if (compressed == null) compressed = this.compressed;
                        if (this.curve.isInfinity(this))
                            return Buffer.alloc(1, 0); // Infinity point encoded is simply '00'

                        var x = this.affineX;
                        var y = this.affineY;
                        var byteLength = this.curve.pLength;
                        var buffer;

                        // 0x02/0x03 | X
                        if (compressed) {
                            buffer = Buffer.allocUnsafe(1 + byteLength);
                            buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0);

                            // 0x04 | X | Y
                        } else {
                            buffer = Buffer.allocUnsafe(
                                1 + byteLength + byteLength
                            );
                            buffer.writeUInt8(0x04, 0);

                            y.toBuffer(byteLength).copy(buffer, 1 + byteLength);
                        }

                        x.toBuffer(byteLength).copy(buffer, 1);

                        return buffer;
                    };

                    Point.decodeFrom = function(curve, buffer) {
                        var type = buffer.readUInt8(0);
                        var compressed = type !== 4;

                        var byteLength = Math.floor(
                            (curve.p.bitLength() + 7) / 8
                        );
                        var x = BigInteger.fromBuffer(
                            buffer.slice(1, 1 + byteLength)
                        );

                        var Q;
                        if (compressed) {
                            assert.equal(
                                buffer.length,
                                byteLength + 1,
                                "Invalid sequence length"
                            );
                            assert(
                                type === 0x02 || type === 0x03,
                                "Invalid sequence tag"
                            );

                            var isOdd = type === 0x03;
                            Q = curve.pointFromX(isOdd, x);
                        } else {
                            assert.equal(
                                buffer.length,
                                1 + byteLength + byteLength,
                                "Invalid sequence length"
                            );

                            var y = BigInteger.fromBuffer(
                                buffer.slice(1 + byteLength)
                            );
                            Q = Point.fromAffine(curve, x, y);
                        }

                        Q.compressed = compressed;
                        return Q;
                    };

                    Point.prototype.toString = function() {
                        if (this.curve.isInfinity(this)) return "(INFINITY)";

                        return (
                            "(" +
                            this.affineX.toString() +
                            "," +
                            this.affineY.toString() +
                            ")"
                        );
                    };

                    module.exports = Point;
                },
                {
                    assert:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/assert/assert.js",
                    bigi:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/bigi/lib/index.js",
                    "safe-buffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/events/events.js": [
                function(require, module, exports) {
                    // Copyright Joyent, Inc. and other Node contributors.
                    //
                    // Permission is hereby granted, free of charge, to any person obtaining a
                    // copy of this software and associated documentation files (the
                    // "Software"), to deal in the Software without restriction, including
                    // without limitation the rights to use, copy, modify, merge, publish,
                    // distribute, sublicense, and/or sell copies of the Software, and to permit
                    // persons to whom the Software is furnished to do so, subject to the
                    // following conditions:
                    //
                    // The above copyright notice and this permission notice shall be included
                    // in all copies or substantial portions of the Software.
                    //
                    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                    // USE OR OTHER DEALINGS IN THE SOFTWARE.

                    function EventEmitter() {
                        this._events = this._events || {};
                        this._maxListeners = this._maxListeners || undefined;
                    }
                    module.exports = EventEmitter;

                    // Backwards-compat with node 0.10.x
                    EventEmitter.EventEmitter = EventEmitter;

                    EventEmitter.prototype._events = undefined;
                    EventEmitter.prototype._maxListeners = undefined;

                    // By default EventEmitters will print a warning if more than 10 listeners are
                    // added to it. This is a useful default which helps finding memory leaks.
                    EventEmitter.defaultMaxListeners = 10;

                    // Obviously not all Emitters should be limited to 10. This function allows
                    // that to be increased. Set to zero for unlimited.
                    EventEmitter.prototype.setMaxListeners = function(n) {
                        if (!isNumber(n) || n < 0 || isNaN(n))
                            throw TypeError("n must be a positive number");
                        this._maxListeners = n;
                        return this;
                    };

                    EventEmitter.prototype.emit = function(type) {
                        var er, handler, len, args, i, listeners;

                        if (!this._events) this._events = {};

                        // If there is no 'error' event listener then throw.
                        if (type === "error") {
                            if (
                                !this._events.error ||
                                (isObject(this._events.error) &&
                                    !this._events.error.length)
                            ) {
                                er = arguments[1];
                                if (er instanceof Error) {
                                    throw er; // Unhandled 'error' event
                                } else {
                                    // At least give some kind of context to the user
                                    var err = new Error(
                                        'Uncaught, unspecified "error" event. (' +
                                            er +
                                            ")"
                                    );
                                    err.context = er;
                                    throw err;
                                }
                            }
                        }

                        handler = this._events[type];

                        if (isUndefined(handler)) return false;

                        if (isFunction(handler)) {
                            switch (arguments.length) {
                                // fast cases
                                case 1:
                                    handler.call(this);
                                    break;
                                case 2:
                                    handler.call(this, arguments[1]);
                                    break;
                                case 3:
                                    handler.call(
                                        this,
                                        arguments[1],
                                        arguments[2]
                                    );
                                    break;
                                // slower
                                default:
                                    args = Array.prototype.slice.call(
                                        arguments,
                                        1
                                    );
                                    handler.apply(this, args);
                            }
                        } else if (isObject(handler)) {
                            args = Array.prototype.slice.call(arguments, 1);
                            listeners = handler.slice();
                            len = listeners.length;
                            for (i = 0; i < len; i++)
                                listeners[i].apply(this, args);
                        }

                        return true;
                    };

                    EventEmitter.prototype.addListener = function(
                        type,
                        listener
                    ) {
                        var m;

                        if (!isFunction(listener))
                            throw TypeError("listener must be a function");

                        if (!this._events) this._events = {};

                        // To avoid recursion in the case that type === "newListener"! Before
                        // adding it to the listeners, first emit "newListener".
                        if (this._events.newListener)
                            this.emit(
                                "newListener",
                                type,
                                isFunction(listener.listener)
                                    ? listener.listener
                                    : listener
                            );

                        if (!this._events[type])
                            // Optimize the case of one listener. Don't need the extra array object.
                            this._events[type] = listener;
                        else if (isObject(this._events[type]))
                            // If we've already got an array, just append.
                            this._events[type].push(listener);
                        // Adding the second element, need to change to array.
                        else
                            this._events[type] = [this._events[type], listener];

                        // Check for listener leak
                        if (
                            isObject(this._events[type]) &&
                            !this._events[type].warned
                        ) {
                            if (!isUndefined(this._maxListeners)) {
                                m = this._maxListeners;
                            } else {
                                m = EventEmitter.defaultMaxListeners;
                            }

                            if (m && m > 0 && this._events[type].length > m) {
                                this._events[type].warned = true;
                                console.error(
                                    "(node) warning: possible EventEmitter memory " +
                                        "leak detected. %d listeners added. " +
                                        "Use emitter.setMaxListeners() to increase limit.",
                                    this._events[type].length
                                );
                                if (typeof console.trace === "function") {
                                    // not supported in IE 10
                                    console.trace();
                                }
                            }
                        }

                        return this;
                    };

                    EventEmitter.prototype.on =
                        EventEmitter.prototype.addListener;

                    EventEmitter.prototype.once = function(type, listener) {
                        if (!isFunction(listener))
                            throw TypeError("listener must be a function");

                        var fired = false;

                        function g() {
                            this.removeListener(type, g);

                            if (!fired) {
                                fired = true;
                                listener.apply(this, arguments);
                            }
                        }

                        g.listener = listener;
                        this.on(type, g);

                        return this;
                    };

                    // emits a 'removeListener' event iff the listener was removed
                    EventEmitter.prototype.removeListener = function(
                        type,
                        listener
                    ) {
                        var list, position, length, i;

                        if (!isFunction(listener))
                            throw TypeError("listener must be a function");

                        if (!this._events || !this._events[type]) return this;

                        list = this._events[type];
                        length = list.length;
                        position = -1;

                        if (
                            list === listener ||
                            (isFunction(list.listener) &&
                                list.listener === listener)
                        ) {
                            delete this._events[type];
                            if (this._events.removeListener)
                                this.emit("removeListener", type, listener);
                        } else if (isObject(list)) {
                            for (i = length; i-- > 0; ) {
                                if (
                                    list[i] === listener ||
                                    (list[i].listener &&
                                        list[i].listener === listener)
                                ) {
                                    position = i;
                                    break;
                                }
                            }

                            if (position < 0) return this;

                            if (list.length === 1) {
                                list.length = 0;
                                delete this._events[type];
                            } else {
                                list.splice(position, 1);
                            }

                            if (this._events.removeListener)
                                this.emit("removeListener", type, listener);
                        }

                        return this;
                    };

                    EventEmitter.prototype.removeAllListeners = function(type) {
                        var key, listeners;

                        if (!this._events) return this;

                        // not listening for removeListener, no need to emit
                        if (!this._events.removeListener) {
                            if (arguments.length === 0) this._events = {};
                            else if (this._events[type])
                                delete this._events[type];
                            return this;
                        }

                        // emit removeListener for all listeners on all events
                        if (arguments.length === 0) {
                            for (key in this._events) {
                                if (key === "removeListener") continue;
                                this.removeAllListeners(key);
                            }
                            this.removeAllListeners("removeListener");
                            this._events = {};
                            return this;
                        }

                        listeners = this._events[type];

                        if (isFunction(listeners)) {
                            this.removeListener(type, listeners);
                        } else if (listeners) {
                            // LIFO order
                            while (listeners.length)
                                this.removeListener(
                                    type,
                                    listeners[listeners.length - 1]
                                );
                        }
                        delete this._events[type];

                        return this;
                    };

                    EventEmitter.prototype.listeners = function(type) {
                        var ret;
                        if (!this._events || !this._events[type]) ret = [];
                        else if (isFunction(this._events[type]))
                            ret = [this._events[type]];
                        else ret = this._events[type].slice();
                        return ret;
                    };

                    EventEmitter.prototype.listenerCount = function(type) {
                        if (this._events) {
                            var evlistener = this._events[type];

                            if (isFunction(evlistener)) return 1;
                            else if (evlistener) return evlistener.length;
                        }
                        return 0;
                    };

                    EventEmitter.listenerCount = function(emitter, type) {
                        return emitter.listenerCount(type);
                    };

                    function isFunction(arg) {
                        return typeof arg === "function";
                    }

                    function isNumber(arg) {
                        return typeof arg === "number";
                    }

                    function isObject(arg) {
                        return typeof arg === "object" && arg !== null;
                    }

                    function isUndefined(arg) {
                        return arg === void 0;
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/hash-base/index.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";
                        var Transform = require("stream").Transform;
                        var inherits = require("inherits");

                        function HashBase(blockSize) {
                            Transform.call(this);

                            this._block = new Buffer(blockSize);
                            this._blockSize = blockSize;
                            this._blockOffset = 0;
                            this._length = [0, 0, 0, 0];

                            this._finalized = false;
                        }

                        inherits(HashBase, Transform);

                        HashBase.prototype._transform = function(
                            chunk,
                            encoding,
                            callback
                        ) {
                            var error = null;
                            try {
                                if (encoding !== "buffer")
                                    chunk = new Buffer(chunk, encoding);
                                this.update(chunk);
                            } catch (err) {
                                error = err;
                            }

                            callback(error);
                        };

                        HashBase.prototype._flush = function(callback) {
                            var error = null;
                            try {
                                this.push(this._digest());
                            } catch (err) {
                                error = err;
                            }

                            callback(error);
                        };

                        HashBase.prototype.update = function(data, encoding) {
                            if (
                                !Buffer.isBuffer(data) &&
                                typeof data !== "string"
                            )
                                throw new TypeError(
                                    "Data must be a string or a buffer"
                                );
                            if (this._finalized)
                                throw new Error("Digest already called");
                            if (!Buffer.isBuffer(data))
                                data = new Buffer(data, encoding || "binary");

                            // consume data
                            var block = this._block;
                            var offset = 0;
                            while (
                                this._blockOffset + data.length - offset >=
                                this._blockSize
                            ) {
                                for (
                                    var i = this._blockOffset;
                                    i < this._blockSize;

                                )
                                    block[i++] = data[offset++];
                                this._update();
                                this._blockOffset = 0;
                            }
                            while (offset < data.length)
                                block[this._blockOffset++] = data[offset++];

                            // update length
                            for (
                                var j = 0, carry = data.length * 8;
                                carry > 0;
                                ++j
                            ) {
                                this._length[j] += carry;
                                carry = (this._length[j] / 0x0100000000) | 0;
                                if (carry > 0)
                                    this._length[j] -= 0x0100000000 * carry;
                            }

                            return this;
                        };

                        HashBase.prototype._update = function(data) {
                            throw new Error("_update is not implemented");
                        };

                        HashBase.prototype.digest = function(encoding) {
                            if (this._finalized)
                                throw new Error("Digest already called");
                            this._finalized = true;

                            var digest = this._digest();
                            if (encoding !== undefined)
                                digest = digest.toString(encoding);
                            return digest;
                        };

                        HashBase.prototype._digest = function() {
                            throw new Error("_digest is not implemented");
                        };

                        module.exports = HashBase;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    stream:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/stream-browserify/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ieee754/index.js": [
                function(require, module, exports) {
                    exports.read = function(
                        buffer,
                        offset,
                        isLE,
                        mLen,
                        nBytes
                    ) {
                        var e, m;
                        var eLen = nBytes * 8 - mLen - 1;
                        var eMax = (1 << eLen) - 1;
                        var eBias = eMax >> 1;
                        var nBits = -7;
                        var i = isLE ? nBytes - 1 : 0;
                        var d = isLE ? -1 : 1;
                        var s = buffer[offset + i];

                        i += d;

                        e = s & ((1 << -nBits) - 1);
                        s >>= -nBits;
                        nBits += eLen;
                        for (
                            ;
                            nBits > 0;
                            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
                        ) {}

                        m = e & ((1 << -nBits) - 1);
                        e >>= -nBits;
                        nBits += mLen;
                        for (
                            ;
                            nBits > 0;
                            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
                        ) {}

                        if (e === 0) {
                            e = 1 - eBias;
                        } else if (e === eMax) {
                            return m ? NaN : (s ? -1 : 1) * Infinity;
                        } else {
                            m = m + Math.pow(2, mLen);
                            e = e - eBias;
                        }
                        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                    };

                    exports.write = function(
                        buffer,
                        value,
                        offset,
                        isLE,
                        mLen,
                        nBytes
                    ) {
                        var e, m, c;
                        var eLen = nBytes * 8 - mLen - 1;
                        var eMax = (1 << eLen) - 1;
                        var eBias = eMax >> 1;
                        var rt =
                            mLen === 23
                                ? Math.pow(2, -24) - Math.pow(2, -77)
                                : 0;
                        var i = isLE ? 0 : nBytes - 1;
                        var d = isLE ? 1 : -1;
                        var s =
                            value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

                        value = Math.abs(value);

                        if (isNaN(value) || value === Infinity) {
                            m = isNaN(value) ? 1 : 0;
                            e = eMax;
                        } else {
                            e = Math.floor(Math.log(value) / Math.LN2);
                            if (value * (c = Math.pow(2, -e)) < 1) {
                                e--;
                                c *= 2;
                            }
                            if (e + eBias >= 1) {
                                value += rt / c;
                            } else {
                                value += rt * Math.pow(2, 1 - eBias);
                            }
                            if (value * c >= 2) {
                                e++;
                                c /= 2;
                            }

                            if (e + eBias >= eMax) {
                                m = 0;
                                e = eMax;
                            } else if (e + eBias >= 1) {
                                m = (value * c - 1) * Math.pow(2, mLen);
                                e = e + eBias;
                            } else {
                                m =
                                    value *
                                    Math.pow(2, eBias - 1) *
                                    Math.pow(2, mLen);
                                e = 0;
                            }
                        }

                        for (
                            ;
                            mLen >= 8;
                            buffer[offset + i] = m & 0xff,
                                i += d,
                                m /= 256,
                                mLen -= 8
                        ) {}

                        e = (e << mLen) | m;
                        eLen += mLen;
                        for (
                            ;
                            eLen > 0;
                            buffer[offset + i] = e & 0xff,
                                i += d,
                                e /= 256,
                                eLen -= 8
                        ) {}

                        buffer[offset + i - d] |= s * 128;
                    };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js": [
                function(require, module, exports) {
                    if (typeof Object.create === "function") {
                        // implementation from standard node.js 'util' module
                        module.exports = function inherits(ctor, superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(
                                superCtor.prototype,
                                {
                                    constructor: {
                                        value: ctor,
                                        enumerable: false,
                                        writable: true,
                                        configurable: true
                                    }
                                }
                            );
                        };
                    } else {
                        // old school shim for old browsers
                        module.exports = function inherits(ctor, superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        };
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/is-buffer/index.js": [
                function(require, module, exports) {
                    /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

                    // The _isBuffer check is for Safari 5-7 support, because it's missing
                    // Object.prototype.constructor. Remove this eventually
                    module.exports = function(obj) {
                        return (
                            obj != null &&
                            (isBuffer(obj) ||
                                isSlowBuffer(obj) ||
                                !!obj._isBuffer)
                        );
                    };

                    function isBuffer(obj) {
                        return (
                            !!obj.constructor &&
                            typeof obj.constructor.isBuffer === "function" &&
                            obj.constructor.isBuffer(obj)
                        );
                    }

                    // For Node v0.10 support. Remove this eventually.
                    function isSlowBuffer(obj) {
                        return (
                            typeof obj.readFloatLE === "function" &&
                            typeof obj.slice === "function" &&
                            isBuffer(obj.slice(0, 0))
                        );
                    }
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/isarray/index.js": [
                function(require, module, exports) {
                    var toString = {}.toString;

                    module.exports =
                        Array.isArray ||
                        function(arr) {
                            return toString.call(arr) == "[object Array]";
                        };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/long/dist/long.js": [
                function(require, module, exports) {
                    /*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

                    /**
                     * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
                     * Released under the Apache License, Version 2.0
                     * see: https://github.com/dcodeIO/long.js for details
                     */
                    (function(global, factory) {
                        /* AMD */ if (
                            typeof define === "function" &&
                            define["amd"]
                        )
                            define([], factory);
                        /* CommonJS */ else if (
                            typeof require === "function" &&
                            typeof module === "object" &&
                            module &&
                            module["exports"]
                        )
                            module["exports"] = factory();
                        /* Global */ else
                            (global["dcodeIO"] = global["dcodeIO"] || {})[
                                "Long"
                            ] = factory();
                    })(this, function() {
                        "use strict";

                        /**
                         * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
                         *  See the from* functions below for more convenient ways of constructing Longs.
                         * @exports Long
                         * @class A Long class for representing a 64 bit two's-complement integer value.
                         * @param {number} low The low (signed) 32 bits of the long
                         * @param {number} high The high (signed) 32 bits of the long
                         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
                         * @constructor
                         */
                        function Long(low, high, unsigned) {
                            /**
                             * The low 32 bits as a signed value.
                             * @type {number}
                             */
                            this.low = low | 0;

                            /**
                             * The high 32 bits as a signed value.
                             * @type {number}
                             */
                            this.high = high | 0;

                            /**
                             * Whether unsigned or not.
                             * @type {boolean}
                             */
                            this.unsigned = !!unsigned;
                        }

                        // The internal representation of a long is the two given signed, 32-bit values.
                        // We use 32-bit pieces because these are the size of integers on which
                        // Javascript performs bit-operations.  For operations like addition and
                        // multiplication, we split each number into 16 bit pieces, which can easily be
                        // multiplied within Javascript's floating-point representation without overflow
                        // or change in sign.
                        //
                        // In the algorithms below, we frequently reduce the negative case to the
                        // positive case by negating the input(s) and then post-processing the result.
                        // Note that we must ALWAYS check specially whether those values are MIN_VALUE
                        // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
                        // a positive number, it overflows back into a negative).  Not handling this
                        // case would often result in infinite recursion.
                        //
                        // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
                        // methods on which they depend.

                        /**
                         * An indicator used to reliably determine if an object is a Long or not.
                         * @type {boolean}
                         * @const
                         * @private
                         */
                        Long.prototype.__isLong__;

                        Object.defineProperty(Long.prototype, "__isLong__", {
                            value: true,
                            enumerable: false,
                            configurable: false
                        });

                        /**
                         * @function
                         * @param {*} obj Object
                         * @returns {boolean}
                         * @inner
                         */
                        function isLong(obj) {
                            return (obj && obj["__isLong__"]) === true;
                        }

                        /**
                         * Tests if the specified object is a Long.
                         * @function
                         * @param {*} obj Object
                         * @returns {boolean}
                         */
                        Long.isLong = isLong;

                        /**
                         * A cache of the Long representations of small integer values.
                         * @type {!Object}
                         * @inner
                         */
                        var INT_CACHE = {};

                        /**
                         * A cache of the Long representations of small unsigned integer values.
                         * @type {!Object}
                         * @inner
                         */
                        var UINT_CACHE = {};

                        /**
                         * @param {number} value
                         * @param {boolean=} unsigned
                         * @returns {!Long}
                         * @inner
                         */
                        function fromInt(value, unsigned) {
                            var obj, cachedObj, cache;
                            if (unsigned) {
                                value >>>= 0;
                                if ((cache = 0 <= value && value < 256)) {
                                    cachedObj = UINT_CACHE[value];
                                    if (cachedObj) return cachedObj;
                                }
                                obj = fromBits(
                                    value,
                                    (value | 0) < 0 ? -1 : 0,
                                    true
                                );
                                if (cache) UINT_CACHE[value] = obj;
                                return obj;
                            } else {
                                value |= 0;
                                if ((cache = -128 <= value && value < 128)) {
                                    cachedObj = INT_CACHE[value];
                                    if (cachedObj) return cachedObj;
                                }
                                obj = fromBits(
                                    value,
                                    value < 0 ? -1 : 0,
                                    false
                                );
                                if (cache) INT_CACHE[value] = obj;
                                return obj;
                            }
                        }

                        /**
                         * Returns a Long representing the given 32 bit integer value.
                         * @function
                         * @param {number} value The 32 bit integer in question
                         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
                         * @returns {!Long} The corresponding Long value
                         */
                        Long.fromInt = fromInt;

                        /**
                         * @param {number} value
                         * @param {boolean=} unsigned
                         * @returns {!Long}
                         * @inner
                         */
                        function fromNumber(value, unsigned) {
                            if (isNaN(value) || !isFinite(value))
                                return unsigned ? UZERO : ZERO;
                            if (unsigned) {
                                if (value < 0) return UZERO;
                                if (value >= TWO_PWR_64_DBL)
                                    return MAX_UNSIGNED_VALUE;
                            } else {
                                if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
                                if (value + 1 >= TWO_PWR_63_DBL)
                                    return MAX_VALUE;
                            }
                            if (value < 0)
                                return fromNumber(-value, unsigned).neg();
                            return fromBits(
                                (value % TWO_PWR_32_DBL) | 0,
                                (value / TWO_PWR_32_DBL) | 0,
                                unsigned
                            );
                        }

                        /**
                         * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
                         * @function
                         * @param {number} value The number in question
                         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
                         * @returns {!Long} The corresponding Long value
                         */
                        Long.fromNumber = fromNumber;

                        /**
                         * @param {number} lowBits
                         * @param {number} highBits
                         * @param {boolean=} unsigned
                         * @returns {!Long}
                         * @inner
                         */
                        function fromBits(lowBits, highBits, unsigned) {
                            return new Long(lowBits, highBits, unsigned);
                        }

                        /**
                         * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
                         *  assumed to use 32 bits.
                         * @function
                         * @param {number} lowBits The low 32 bits
                         * @param {number} highBits The high 32 bits
                         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
                         * @returns {!Long} The corresponding Long value
                         */
                        Long.fromBits = fromBits;

                        /**
                         * @function
                         * @param {number} base
                         * @param {number} exponent
                         * @returns {number}
                         * @inner
                         */
                        var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

                        /**
                         * @param {string} str
                         * @param {(boolean|number)=} unsigned
                         * @param {number=} radix
                         * @returns {!Long}
                         * @inner
                         */
                        function fromString(str, unsigned, radix) {
                            if (str.length === 0) throw Error("empty string");
                            if (
                                str === "NaN" ||
                                str === "Infinity" ||
                                str === "+Infinity" ||
                                str === "-Infinity"
                            )
                                return ZERO;
                            if (typeof unsigned === "number") {
                                // For goog.math.long compatibility
                                (radix = unsigned), (unsigned = false);
                            } else {
                                unsigned = !!unsigned;
                            }
                            radix = radix || 10;
                            if (radix < 2 || 36 < radix)
                                throw RangeError("radix");

                            var p;
                            if ((p = str.indexOf("-")) > 0)
                                throw Error("interior hyphen");
                            else if (p === 0) {
                                return fromString(
                                    str.substring(1),
                                    unsigned,
                                    radix
                                ).neg();
                            }

                            // Do several (8) digits each time through the loop, so as to
                            // minimize the calls to the very expensive emulated div.
                            var radixToPower = fromNumber(pow_dbl(radix, 8));

                            var result = ZERO;
                            for (var i = 0; i < str.length; i += 8) {
                                var size = Math.min(8, str.length - i),
                                    value = parseInt(
                                        str.substring(i, i + size),
                                        radix
                                    );
                                if (size < 8) {
                                    var power = fromNumber(
                                        pow_dbl(radix, size)
                                    );
                                    result = result
                                        .mul(power)
                                        .add(fromNumber(value));
                                } else {
                                    result = result.mul(radixToPower);
                                    result = result.add(fromNumber(value));
                                }
                            }
                            result.unsigned = unsigned;
                            return result;
                        }

                        /**
                         * Returns a Long representation of the given string, written using the specified radix.
                         * @function
                         * @param {string} str The textual representation of the Long
                         * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
                         * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
                         * @returns {!Long} The corresponding Long value
                         */
                        Long.fromString = fromString;

                        /**
                         * @function
                         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
                         * @returns {!Long}
                         * @inner
                         */
                        function fromValue(val) {
                            if (val /* is compatible */ instanceof Long)
                                return val;
                            if (typeof val === "number") return fromNumber(val);
                            if (typeof val === "string") return fromString(val);
                            // Throws for non-objects, converts non-instanceof Long:
                            return fromBits(val.low, val.high, val.unsigned);
                        }

                        /**
                         * Converts the specified value to a Long.
                         * @function
                         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
                         * @returns {!Long}
                         */
                        Long.fromValue = fromValue;

                        // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
                        // no runtime penalty for these.

                        /**
                         * @type {number}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_16_DBL = 1 << 16;

                        /**
                         * @type {number}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_24_DBL = 1 << 24;

                        /**
                         * @type {number}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

                        /**
                         * @type {number}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

                        /**
                         * @type {number}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

                        /**
                         * @type {!Long}
                         * @const
                         * @inner
                         */
                        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var ZERO = fromInt(0);

                        /**
                         * Signed zero.
                         * @type {!Long}
                         */
                        Long.ZERO = ZERO;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var UZERO = fromInt(0, true);

                        /**
                         * Unsigned zero.
                         * @type {!Long}
                         */
                        Long.UZERO = UZERO;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var ONE = fromInt(1);

                        /**
                         * Signed one.
                         * @type {!Long}
                         */
                        Long.ONE = ONE;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var UONE = fromInt(1, true);

                        /**
                         * Unsigned one.
                         * @type {!Long}
                         */
                        Long.UONE = UONE;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var NEG_ONE = fromInt(-1);

                        /**
                         * Signed negative one.
                         * @type {!Long}
                         */
                        Long.NEG_ONE = NEG_ONE;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var MAX_VALUE = fromBits(
                            0xffffffff | 0,
                            0x7fffffff | 0,
                            false
                        );

                        /**
                         * Maximum signed value.
                         * @type {!Long}
                         */
                        Long.MAX_VALUE = MAX_VALUE;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var MAX_UNSIGNED_VALUE = fromBits(
                            0xffffffff | 0,
                            0xffffffff | 0,
                            true
                        );

                        /**
                         * Maximum unsigned value.
                         * @type {!Long}
                         */
                        Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

                        /**
                         * @type {!Long}
                         * @inner
                         */
                        var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

                        /**
                         * Minimum signed value.
                         * @type {!Long}
                         */
                        Long.MIN_VALUE = MIN_VALUE;

                        /**
                         * @alias Long.prototype
                         * @inner
                         */
                        var LongPrototype = Long.prototype;

                        /**
                         * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
                         * @returns {number}
                         */
                        LongPrototype.toInt = function toInt() {
                            return this.unsigned ? this.low >>> 0 : this.low;
                        };

                        /**
                         * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
                         * @returns {number}
                         */
                        LongPrototype.toNumber = function toNumber() {
                            if (this.unsigned)
                                return (
                                    (this.high >>> 0) * TWO_PWR_32_DBL +
                                    (this.low >>> 0)
                                );
                            return (
                                this.high * TWO_PWR_32_DBL + (this.low >>> 0)
                            );
                        };

                        /**
                         * Converts the Long to a string written in the specified radix.
                         * @param {number=} radix Radix (2-36), defaults to 10
                         * @returns {string}
                         * @override
                         * @throws {RangeError} If `radix` is out of range
                         */
                        LongPrototype.toString = function toString(radix) {
                            radix = radix || 10;
                            if (radix < 2 || 36 < radix)
                                throw RangeError("radix");
                            if (this.isZero()) return "0";
                            if (this.isNegative()) {
                                // Unsigned Longs are never negative
                                if (this.eq(MIN_VALUE)) {
                                    // We need to change the Long value before it can be negated, so we remove
                                    // the bottom-most digit in this base and then recurse to do the rest.
                                    var radixLong = fromNumber(radix),
                                        div = this.div(radixLong),
                                        rem1 = div.mul(radixLong).sub(this);
                                    return (
                                        div.toString(radix) +
                                        rem1.toInt().toString(radix)
                                    );
                                } else return "-" + this.neg().toString(radix);
                            }

                            // Do several (6) digits each time through the loop, so as to
                            // minimize the calls to the very expensive emulated div.
                            var radixToPower = fromNumber(
                                    pow_dbl(radix, 6),
                                    this.unsigned
                                ),
                                rem = this;
                            var result = "";
                            while (true) {
                                var remDiv = rem.div(radixToPower),
                                    intval =
                                        rem
                                            .sub(remDiv.mul(radixToPower))
                                            .toInt() >>> 0,
                                    digits = intval.toString(radix);
                                rem = remDiv;
                                if (rem.isZero()) return digits + result;
                                else {
                                    while (digits.length < 6)
                                        digits = "0" + digits;
                                    result = "" + digits + result;
                                }
                            }
                        };

                        /**
                         * Gets the high 32 bits as a signed integer.
                         * @returns {number} Signed high bits
                         */
                        LongPrototype.getHighBits = function getHighBits() {
                            return this.high;
                        };

                        /**
                         * Gets the high 32 bits as an unsigned integer.
                         * @returns {number} Unsigned high bits
                         */
                        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
                            return this.high >>> 0;
                        };

                        /**
                         * Gets the low 32 bits as a signed integer.
                         * @returns {number} Signed low bits
                         */
                        LongPrototype.getLowBits = function getLowBits() {
                            return this.low;
                        };

                        /**
                         * Gets the low 32 bits as an unsigned integer.
                         * @returns {number} Unsigned low bits
                         */
                        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
                            return this.low >>> 0;
                        };

                        /**
                         * Gets the number of bits needed to represent the absolute value of this Long.
                         * @returns {number}
                         */
                        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
                            if (this.isNegative())
                                // Unsigned Longs are never negative
                                return this.eq(MIN_VALUE)
                                    ? 64
                                    : this.neg().getNumBitsAbs();
                            var val = this.high != 0 ? this.high : this.low;
                            for (var bit = 31; bit > 0; bit--)
                                if ((val & (1 << bit)) != 0) break;
                            return this.high != 0 ? bit + 33 : bit + 1;
                        };

                        /**
                         * Tests if this Long's value equals zero.
                         * @returns {boolean}
                         */
                        LongPrototype.isZero = function isZero() {
                            return this.high === 0 && this.low === 0;
                        };

                        /**
                         * Tests if this Long's value is negative.
                         * @returns {boolean}
                         */
                        LongPrototype.isNegative = function isNegative() {
                            return !this.unsigned && this.high < 0;
                        };

                        /**
                         * Tests if this Long's value is positive.
                         * @returns {boolean}
                         */
                        LongPrototype.isPositive = function isPositive() {
                            return this.unsigned || this.high >= 0;
                        };

                        /**
                         * Tests if this Long's value is odd.
                         * @returns {boolean}
                         */
                        LongPrototype.isOdd = function isOdd() {
                            return (this.low & 1) === 1;
                        };

                        /**
                         * Tests if this Long's value is even.
                         * @returns {boolean}
                         */
                        LongPrototype.isEven = function isEven() {
                            return (this.low & 1) === 0;
                        };

                        /**
                         * Tests if this Long's value equals the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.equals = function equals(other) {
                            if (!isLong(other)) other = fromValue(other);
                            if (
                                this.unsigned !== other.unsigned &&
                                this.high >>> 31 === 1 &&
                                other.high >>> 31 === 1
                            )
                                return false;
                            return (
                                this.high === other.high &&
                                this.low === other.low
                            );
                        };

                        /**
                         * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.eq = LongPrototype.equals;

                        /**
                         * Tests if this Long's value differs from the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.notEquals = function notEquals(other) {
                            return !this.eq(/* validates */ other);
                        };

                        /**
                         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.neq = LongPrototype.notEquals;

                        /**
                         * Tests if this Long's value is less than the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.lessThan = function lessThan(other) {
                            return this.comp(/* validates */ other) < 0;
                        };

                        /**
                         * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.lt = LongPrototype.lessThan;

                        /**
                         * Tests if this Long's value is less than or equal the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.lessThanOrEqual = function lessThanOrEqual(
                            other
                        ) {
                            return this.comp(/* validates */ other) <= 0;
                        };

                        /**
                         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.lte = LongPrototype.lessThanOrEqual;

                        /**
                         * Tests if this Long's value is greater than the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.greaterThan = function greaterThan(
                            other
                        ) {
                            return this.comp(/* validates */ other) > 0;
                        };

                        /**
                         * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.gt = LongPrototype.greaterThan;

                        /**
                         * Tests if this Long's value is greater than or equal the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(
                            other
                        ) {
                            return this.comp(/* validates */ other) >= 0;
                        };

                        /**
                         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {boolean}
                         */
                        LongPrototype.gte = LongPrototype.greaterThanOrEqual;

                        /**
                         * Compares this Long's value with the specified's.
                         * @param {!Long|number|string} other Other value
                         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
                         *  if the given one is greater
                         */
                        LongPrototype.compare = function compare(other) {
                            if (!isLong(other)) other = fromValue(other);
                            if (this.eq(other)) return 0;
                            var thisNeg = this.isNegative(),
                                otherNeg = other.isNegative();
                            if (thisNeg && !otherNeg) return -1;
                            if (!thisNeg && otherNeg) return 1;
                            // At this point the sign bits are the same
                            if (!this.unsigned)
                                return this.sub(other).isNegative() ? -1 : 1;
                            // Both are positive if at least one is unsigned
                            return other.high >>> 0 > this.high >>> 0 ||
                                (other.high === this.high &&
                                    other.low >>> 0 > this.low >>> 0)
                                ? -1
                                : 1;
                        };

                        /**
                         * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
                         * @function
                         * @param {!Long|number|string} other Other value
                         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
                         *  if the given one is greater
                         */
                        LongPrototype.comp = LongPrototype.compare;

                        /**
                         * Negates this Long's value.
                         * @returns {!Long} Negated Long
                         */
                        LongPrototype.negate = function negate() {
                            if (!this.unsigned && this.eq(MIN_VALUE))
                                return MIN_VALUE;
                            return this.not().add(ONE);
                        };

                        /**
                         * Negates this Long's value. This is an alias of {@link Long#negate}.
                         * @function
                         * @returns {!Long} Negated Long
                         */
                        LongPrototype.neg = LongPrototype.negate;

                        /**
                         * Returns the sum of this and the specified Long.
                         * @param {!Long|number|string} addend Addend
                         * @returns {!Long} Sum
                         */
                        LongPrototype.add = function add(addend) {
                            if (!isLong(addend)) addend = fromValue(addend);

                            // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

                            var a48 = this.high >>> 16;
                            var a32 = this.high & 0xffff;
                            var a16 = this.low >>> 16;
                            var a00 = this.low & 0xffff;

                            var b48 = addend.high >>> 16;
                            var b32 = addend.high & 0xffff;
                            var b16 = addend.low >>> 16;
                            var b00 = addend.low & 0xffff;

                            var c48 = 0,
                                c32 = 0,
                                c16 = 0,
                                c00 = 0;
                            c00 += a00 + b00;
                            c16 += c00 >>> 16;
                            c00 &= 0xffff;
                            c16 += a16 + b16;
                            c32 += c16 >>> 16;
                            c16 &= 0xffff;
                            c32 += a32 + b32;
                            c48 += c32 >>> 16;
                            c32 &= 0xffff;
                            c48 += a48 + b48;
                            c48 &= 0xffff;
                            return fromBits(
                                (c16 << 16) | c00,
                                (c48 << 16) | c32,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns the difference of this and the specified Long.
                         * @param {!Long|number|string} subtrahend Subtrahend
                         * @returns {!Long} Difference
                         */
                        LongPrototype.subtract = function subtract(subtrahend) {
                            if (!isLong(subtrahend))
                                subtrahend = fromValue(subtrahend);
                            return this.add(subtrahend.neg());
                        };

                        /**
                         * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
                         * @function
                         * @param {!Long|number|string} subtrahend Subtrahend
                         * @returns {!Long} Difference
                         */
                        LongPrototype.sub = LongPrototype.subtract;

                        /**
                         * Returns the product of this and the specified Long.
                         * @param {!Long|number|string} multiplier Multiplier
                         * @returns {!Long} Product
                         */
                        LongPrototype.multiply = function multiply(multiplier) {
                            if (this.isZero()) return ZERO;
                            if (!isLong(multiplier))
                                multiplier = fromValue(multiplier);
                            if (multiplier.isZero()) return ZERO;
                            if (this.eq(MIN_VALUE))
                                return multiplier.isOdd() ? MIN_VALUE : ZERO;
                            if (multiplier.eq(MIN_VALUE))
                                return this.isOdd() ? MIN_VALUE : ZERO;

                            if (this.isNegative()) {
                                if (multiplier.isNegative())
                                    return this.neg().mul(multiplier.neg());
                                else
                                    return this.neg()
                                        .mul(multiplier)
                                        .neg();
                            } else if (multiplier.isNegative())
                                return this.mul(multiplier.neg()).neg();

                            // If both longs are small, use float multiplication
                            if (
                                this.lt(TWO_PWR_24) &&
                                multiplier.lt(TWO_PWR_24)
                            )
                                return fromNumber(
                                    this.toNumber() * multiplier.toNumber(),
                                    this.unsigned
                                );

                            // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
                            // We can skip products that would overflow.

                            var a48 = this.high >>> 16;
                            var a32 = this.high & 0xffff;
                            var a16 = this.low >>> 16;
                            var a00 = this.low & 0xffff;

                            var b48 = multiplier.high >>> 16;
                            var b32 = multiplier.high & 0xffff;
                            var b16 = multiplier.low >>> 16;
                            var b00 = multiplier.low & 0xffff;

                            var c48 = 0,
                                c32 = 0,
                                c16 = 0,
                                c00 = 0;
                            c00 += a00 * b00;
                            c16 += c00 >>> 16;
                            c00 &= 0xffff;
                            c16 += a16 * b00;
                            c32 += c16 >>> 16;
                            c16 &= 0xffff;
                            c16 += a00 * b16;
                            c32 += c16 >>> 16;
                            c16 &= 0xffff;
                            c32 += a32 * b00;
                            c48 += c32 >>> 16;
                            c32 &= 0xffff;
                            c32 += a16 * b16;
                            c48 += c32 >>> 16;
                            c32 &= 0xffff;
                            c32 += a00 * b32;
                            c48 += c32 >>> 16;
                            c32 &= 0xffff;
                            c48 +=
                                a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
                            c48 &= 0xffff;
                            return fromBits(
                                (c16 << 16) | c00,
                                (c48 << 16) | c32,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
                         * @function
                         * @param {!Long|number|string} multiplier Multiplier
                         * @returns {!Long} Product
                         */
                        LongPrototype.mul = LongPrototype.multiply;

                        /**
                         * Returns this Long divided by the specified. The result is signed if this Long is signed or
                         *  unsigned if this Long is unsigned.
                         * @param {!Long|number|string} divisor Divisor
                         * @returns {!Long} Quotient
                         */
                        LongPrototype.divide = function divide(divisor) {
                            if (!isLong(divisor)) divisor = fromValue(divisor);
                            if (divisor.isZero())
                                throw Error("division by zero");
                            if (this.isZero())
                                return this.unsigned ? UZERO : ZERO;
                            var approx, rem, res;
                            if (!this.unsigned) {
                                // This section is only relevant for signed longs and is derived from the
                                // closure library as a whole.
                                if (this.eq(MIN_VALUE)) {
                                    if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                                        return MIN_VALUE;
                                    // recall that -MIN_VALUE == MIN_VALUE
                                    else if (divisor.eq(MIN_VALUE)) return ONE;
                                    else {
                                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                                        var halfThis = this.shr(1);
                                        approx = halfThis.div(divisor).shl(1);
                                        if (approx.eq(ZERO)) {
                                            return divisor.isNegative()
                                                ? ONE
                                                : NEG_ONE;
                                        } else {
                                            rem = this.sub(divisor.mul(approx));
                                            res = approx.add(rem.div(divisor));
                                            return res;
                                        }
                                    }
                                } else if (divisor.eq(MIN_VALUE))
                                    return this.unsigned ? UZERO : ZERO;
                                if (this.isNegative()) {
                                    if (divisor.isNegative())
                                        return this.neg().div(divisor.neg());
                                    return this.neg()
                                        .div(divisor)
                                        .neg();
                                } else if (divisor.isNegative())
                                    return this.div(divisor.neg()).neg();
                                res = ZERO;
                            } else {
                                // The algorithm below has not been made for unsigned longs. It's therefore
                                // required to take special care of the MSB prior to running it.
                                if (!divisor.unsigned)
                                    divisor = divisor.toUnsigned();
                                if (divisor.gt(this)) return UZERO;
                                if (divisor.gt(this.shru(1)))
                                    // 15 >>> 1 = 7 ; with divisor = 8 ; true
                                    return UONE;
                                res = UZERO;
                            }

                            // Repeat the following until the remainder is less than other:  find a
                            // floating-point that approximates remainder / other *from below*, add this
                            // into the result, and subtract it from the remainder.  It is critical that
                            // the approximate value is less than or equal to the real value so that the
                            // remainder never becomes negative.
                            rem = this;
                            while (rem.gte(divisor)) {
                                // Approximate the result of division. This may be a little greater or
                                // smaller than the actual value.
                                approx = Math.max(
                                    1,
                                    Math.floor(
                                        rem.toNumber() / divisor.toNumber()
                                    )
                                );

                                // We will tweak the approximate result by changing it in the 48-th digit or
                                // the smallest non-fractional digit, whichever is larger.
                                var log2 = Math.ceil(
                                        Math.log(approx) / Math.LN2
                                    ),
                                    delta =
                                        log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
                                    // Decrease the approximation until it is smaller than the remainder.  Note
                                    // that if it is too large, the product overflows and is negative.
                                    approxRes = fromNumber(approx),
                                    approxRem = approxRes.mul(divisor);
                                while (
                                    approxRem.isNegative() ||
                                    approxRem.gt(rem)
                                ) {
                                    approx -= delta;
                                    approxRes = fromNumber(
                                        approx,
                                        this.unsigned
                                    );
                                    approxRem = approxRes.mul(divisor);
                                }

                                // We know the answer can't be zero... and actually, zero would cause
                                // infinite recursion since we would make no progress.
                                if (approxRes.isZero()) approxRes = ONE;

                                res = res.add(approxRes);
                                rem = rem.sub(approxRem);
                            }
                            return res;
                        };

                        /**
                         * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
                         * @function
                         * @param {!Long|number|string} divisor Divisor
                         * @returns {!Long} Quotient
                         */
                        LongPrototype.div = LongPrototype.divide;

                        /**
                         * Returns this Long modulo the specified.
                         * @param {!Long|number|string} divisor Divisor
                         * @returns {!Long} Remainder
                         */
                        LongPrototype.modulo = function modulo(divisor) {
                            if (!isLong(divisor)) divisor = fromValue(divisor);
                            return this.sub(this.div(divisor).mul(divisor));
                        };

                        /**
                         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
                         * @function
                         * @param {!Long|number|string} divisor Divisor
                         * @returns {!Long} Remainder
                         */
                        LongPrototype.mod = LongPrototype.modulo;

                        /**
                         * Returns the bitwise NOT of this Long.
                         * @returns {!Long}
                         */
                        LongPrototype.not = function not() {
                            return fromBits(
                                ~this.low,
                                ~this.high,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns the bitwise AND of this Long and the specified.
                         * @param {!Long|number|string} other Other Long
                         * @returns {!Long}
                         */
                        LongPrototype.and = function and(other) {
                            if (!isLong(other)) other = fromValue(other);
                            return fromBits(
                                this.low & other.low,
                                this.high & other.high,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns the bitwise OR of this Long and the specified.
                         * @param {!Long|number|string} other Other Long
                         * @returns {!Long}
                         */
                        LongPrototype.or = function or(other) {
                            if (!isLong(other)) other = fromValue(other);
                            return fromBits(
                                this.low | other.low,
                                this.high | other.high,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns the bitwise XOR of this Long and the given one.
                         * @param {!Long|number|string} other Other Long
                         * @returns {!Long}
                         */
                        LongPrototype.xor = function xor(other) {
                            if (!isLong(other)) other = fromValue(other);
                            return fromBits(
                                this.low ^ other.low,
                                this.high ^ other.high,
                                this.unsigned
                            );
                        };

                        /**
                         * Returns this Long with bits shifted to the left by the given amount.
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shiftLeft = function shiftLeft(numBits) {
                            if (isLong(numBits)) numBits = numBits.toInt();
                            if ((numBits &= 63) === 0) return this;
                            else if (numBits < 32)
                                return fromBits(
                                    this.low << numBits,
                                    (this.high << numBits) |
                                        (this.low >>> (32 - numBits)),
                                    this.unsigned
                                );
                            else
                                return fromBits(
                                    0,
                                    this.low << (numBits - 32),
                                    this.unsigned
                                );
                        };

                        /**
                         * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
                         * @function
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shl = LongPrototype.shiftLeft;

                        /**
                         * Returns this Long with bits arithmetically shifted to the right by the given amount.
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shiftRight = function shiftRight(
                            numBits
                        ) {
                            if (isLong(numBits)) numBits = numBits.toInt();
                            if ((numBits &= 63) === 0) return this;
                            else if (numBits < 32)
                                return fromBits(
                                    (this.low >>> numBits) |
                                        (this.high << (32 - numBits)),
                                    this.high >> numBits,
                                    this.unsigned
                                );
                            else
                                return fromBits(
                                    this.high >> (numBits - 32),
                                    this.high >= 0 ? 0 : -1,
                                    this.unsigned
                                );
                        };

                        /**
                         * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
                         * @function
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shr = LongPrototype.shiftRight;

                        /**
                         * Returns this Long with bits logically shifted to the right by the given amount.
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(
                            numBits
                        ) {
                            if (isLong(numBits)) numBits = numBits.toInt();
                            numBits &= 63;
                            if (numBits === 0) return this;
                            else {
                                var high = this.high;
                                if (numBits < 32) {
                                    var low = this.low;
                                    return fromBits(
                                        (low >>> numBits) |
                                            (high << (32 - numBits)),
                                        high >>> numBits,
                                        this.unsigned
                                    );
                                } else if (numBits === 32)
                                    return fromBits(high, 0, this.unsigned);
                                else
                                    return fromBits(
                                        high >>> (numBits - 32),
                                        0,
                                        this.unsigned
                                    );
                            }
                        };

                        /**
                         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
                         * @function
                         * @param {number|!Long} numBits Number of bits
                         * @returns {!Long} Shifted Long
                         */
                        LongPrototype.shru = LongPrototype.shiftRightUnsigned;

                        /**
                         * Converts this Long to signed.
                         * @returns {!Long} Signed long
                         */
                        LongPrototype.toSigned = function toSigned() {
                            if (!this.unsigned) return this;
                            return fromBits(this.low, this.high, false);
                        };

                        /**
                         * Converts this Long to unsigned.
                         * @returns {!Long} Unsigned long
                         */
                        LongPrototype.toUnsigned = function toUnsigned() {
                            if (this.unsigned) return this;
                            return fromBits(this.low, this.high, true);
                        };

                        /**
                         * Converts this Long to its byte representation.
                         * @param {boolean=} le Whether little or big endian, defaults to big endian
                         * @returns {!Array.<number>} Byte representation
                         */
                        LongPrototype.toBytes = function(le) {
                            return le ? this.toBytesLE() : this.toBytesBE();
                        };

                        /**
                         * Converts this Long to its little endian byte representation.
                         * @returns {!Array.<number>} Little endian byte representation
                         */
                        LongPrototype.toBytesLE = function() {
                            var hi = this.high,
                                lo = this.low;
                            return [
                                lo & 0xff,
                                (lo >>> 8) & 0xff,
                                (lo >>> 16) & 0xff,
                                (lo >>> 24) & 0xff,
                                hi & 0xff,
                                (hi >>> 8) & 0xff,
                                (hi >>> 16) & 0xff,
                                (hi >>> 24) & 0xff
                            ];
                        };

                        /**
                         * Converts this Long to its big endian byte representation.
                         * @returns {!Array.<number>} Big endian byte representation
                         */
                        LongPrototype.toBytesBE = function() {
                            var hi = this.high,
                                lo = this.low;
                            return [
                                (hi >>> 24) & 0xff,
                                (hi >>> 16) & 0xff,
                                (hi >>> 8) & 0xff,
                                hi & 0xff,
                                (lo >>> 24) & 0xff,
                                (lo >>> 16) & 0xff,
                                (lo >>> 8) & 0xff,
                                lo & 0xff
                            ];
                        };

                        return Long;
                    });
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/md5.js/index.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";
                        var inherits = require("inherits");
                        var HashBase = require("hash-base");

                        var ARRAY16 = new Array(16);

                        function MD5() {
                            HashBase.call(this, 64);

                            // state
                            this._a = 0x67452301;
                            this._b = 0xefcdab89;
                            this._c = 0x98badcfe;
                            this._d = 0x10325476;
                        }

                        inherits(MD5, HashBase);

                        MD5.prototype._update = function() {
                            var M = ARRAY16;
                            for (var i = 0; i < 16; ++i)
                                M[i] = this._block.readInt32LE(i * 4);

                            var a = this._a;
                            var b = this._b;
                            var c = this._c;
                            var d = this._d;

                            a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
                            d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
                            c = fnF(c, d, a, b, M[2], 0x242070db, 17);
                            b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
                            a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
                            d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
                            c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
                            b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
                            a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
                            d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
                            c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
                            b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
                            a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
                            d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
                            c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
                            b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

                            a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
                            d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
                            c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
                            b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
                            a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
                            d = fnG(d, a, b, c, M[10], 0x02441453, 9);
                            c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
                            b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
                            a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
                            d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
                            c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
                            b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
                            a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
                            d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
                            c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
                            b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

                            a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
                            d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
                            c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
                            b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
                            a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
                            d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
                            c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
                            b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
                            a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
                            d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
                            c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
                            b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
                            a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
                            d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
                            c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
                            b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

                            a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
                            d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
                            c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
                            b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
                            a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
                            d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
                            c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
                            b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
                            a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
                            d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
                            c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
                            b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
                            a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
                            d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
                            c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
                            b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

                            this._a = (this._a + a) | 0;
                            this._b = (this._b + b) | 0;
                            this._c = (this._c + c) | 0;
                            this._d = (this._d + d) | 0;
                        };

                        MD5.prototype._digest = function() {
                            // create padding and handle blocks
                            this._block[this._blockOffset++] = 0x80;
                            if (this._blockOffset > 56) {
                                this._block.fill(0, this._blockOffset, 64);
                                this._update();
                                this._blockOffset = 0;
                            }

                            this._block.fill(0, this._blockOffset, 56);
                            this._block.writeUInt32LE(this._length[0], 56);
                            this._block.writeUInt32LE(this._length[1], 60);
                            this._update();

                            // produce result
                            var buffer = new Buffer(16);
                            buffer.writeInt32LE(this._a, 0);
                            buffer.writeInt32LE(this._b, 4);
                            buffer.writeInt32LE(this._c, 8);
                            buffer.writeInt32LE(this._d, 12);
                            return buffer;
                        };

                        function rotl(x, n) {
                            return (x << n) | (x >>> (32 - n));
                        }

                        function fnF(a, b, c, d, m, k, s) {
                            return (
                                (rotl(
                                    (a + ((b & c) | (~b & d)) + m + k) | 0,
                                    s
                                ) +
                                    b) |
                                0
                            );
                        }

                        function fnG(a, b, c, d, m, k, s) {
                            return (
                                (rotl(
                                    (a + ((b & d) | (c & ~d)) + m + k) | 0,
                                    s
                                ) +
                                    b) |
                                0
                            );
                        }

                        function fnH(a, b, c, d, m, k, s) {
                            return (
                                (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
                            );
                        }

                        function fnI(a, b, c, d, m, k, s) {
                            return (
                                (rotl((a + (c ^ (b | ~d)) + m + k) | 0, s) +
                                    b) |
                                0
                            );
                        }

                        module.exports = MD5;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "hash-base":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/md5.js/node_modules/hash-base/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/md5.js/node_modules/hash-base/index.js": [
                function(require, module, exports) {
                    "use strict";
                    var Buffer = require("safe-buffer").Buffer;
                    var Transform = require("stream").Transform;
                    var inherits = require("inherits");

                    function throwIfNotStringOrBuffer(val, prefix) {
                        if (!Buffer.isBuffer(val) && typeof val !== "string") {
                            throw new TypeError(
                                prefix + " must be a string or a buffer"
                            );
                        }
                    }

                    function HashBase(blockSize) {
                        Transform.call(this);

                        this._block = Buffer.allocUnsafe(blockSize);
                        this._blockSize = blockSize;
                        this._blockOffset = 0;
                        this._length = [0, 0, 0, 0];

                        this._finalized = false;
                    }

                    inherits(HashBase, Transform);

                    HashBase.prototype._transform = function(
                        chunk,
                        encoding,
                        callback
                    ) {
                        var error = null;
                        try {
                            this.update(chunk, encoding);
                        } catch (err) {
                            error = err;
                        }

                        callback(error);
                    };

                    HashBase.prototype._flush = function(callback) {
                        var error = null;
                        try {
                            this.push(this.digest());
                        } catch (err) {
                            error = err;
                        }

                        callback(error);
                    };

                    HashBase.prototype.update = function(data, encoding) {
                        throwIfNotStringOrBuffer(data, "Data");
                        if (this._finalized)
                            throw new Error("Digest already called");
                        if (!Buffer.isBuffer(data))
                            data = Buffer.from(data, encoding);

                        // consume data
                        var block = this._block;
                        var offset = 0;
                        while (
                            this._blockOffset + data.length - offset >=
                            this._blockSize
                        ) {
                            for (
                                var i = this._blockOffset;
                                i < this._blockSize;

                            )
                                block[i++] = data[offset++];
                            this._update();
                            this._blockOffset = 0;
                        }
                        while (offset < data.length)
                            block[this._blockOffset++] = data[offset++];

                        // update length
                        for (
                            var j = 0, carry = data.length * 8;
                            carry > 0;
                            ++j
                        ) {
                            this._length[j] += carry;
                            carry = (this._length[j] / 0x0100000000) | 0;
                            if (carry > 0)
                                this._length[j] -= 0x0100000000 * carry;
                        }

                        return this;
                    };

                    HashBase.prototype._update = function() {
                        throw new Error("_update is not implemented");
                    };

                    HashBase.prototype.digest = function(encoding) {
                        if (this._finalized)
                            throw new Error("Digest already called");
                        this._finalized = true;

                        var digest = this._digest();
                        if (encoding !== undefined)
                            digest = digest.toString(encoding);

                        // reset state
                        this._block.fill(0);
                        this._blockOffset = 0;
                        for (var i = 0; i < 4; ++i) this._length[i] = 0;

                        return digest;
                    };

                    HashBase.prototype._digest = function() {
                        throw new Error("_digest is not implemented");
                    };

                    module.exports = HashBase;
                },
                {
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "safe-buffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js",
                    stream:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/stream-browserify/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process-nextick-args/index.js": [
                function(require, module, exports) {
                    (function(process) {
                        "use strict";

                        if (
                            !process.version ||
                            process.version.indexOf("v0.") === 0 ||
                            (process.version.indexOf("v1.") === 0 &&
                                process.version.indexOf("v1.8.") !== 0)
                        ) {
                            module.exports = nextTick;
                        } else {
                            module.exports = process.nextTick;
                        }

                        function nextTick(fn, arg1, arg2, arg3) {
                            if (typeof fn !== "function") {
                                throw new TypeError(
                                    '"callback" argument must be a function'
                                );
                            }
                            var len = arguments.length;
                            var args, i;
                            switch (len) {
                                case 0:
                                case 1:
                                    return process.nextTick(fn);
                                case 2:
                                    return process.nextTick(
                                        function afterTickOne() {
                                            fn.call(null, arg1);
                                        }
                                    );
                                case 3:
                                    return process.nextTick(
                                        function afterTickTwo() {
                                            fn.call(null, arg1, arg2);
                                        }
                                    );
                                case 4:
                                    return process.nextTick(
                                        function afterTickThree() {
                                            fn.call(null, arg1, arg2, arg3);
                                        }
                                    );
                                default:
                                    args = new Array(len - 1);
                                    i = 0;
                                    while (i < args.length) {
                                        args[i++] = arguments[i];
                                    }
                                    return process.nextTick(
                                        function afterTick() {
                                            fn.apply(null, args);
                                        }
                                    );
                            }
                        }
                    }.call(this, require("_process")));
                },
                {
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js": [
                function(require, module, exports) {
                    // shim for using process in browser
                    var process = (module.exports = {});

                    // cached from whatever global is present so that test runners that stub it
                    // don't break things.  But we need to wrap it in a try catch in case it is
                    // wrapped in strict mode code which doesn't define any globals.  It's inside a
                    // function because try/catches deoptimize in certain engines.

                    var cachedSetTimeout;
                    var cachedClearTimeout;

                    function defaultSetTimout() {
                        throw new Error("setTimeout has not been defined");
                    }
                    function defaultClearTimeout() {
                        throw new Error("clearTimeout has not been defined");
                    }
                    (function() {
                        try {
                            if (typeof setTimeout === "function") {
                                cachedSetTimeout = setTimeout;
                            } else {
                                cachedSetTimeout = defaultSetTimout;
                            }
                        } catch (e) {
                            cachedSetTimeout = defaultSetTimout;
                        }
                        try {
                            if (typeof clearTimeout === "function") {
                                cachedClearTimeout = clearTimeout;
                            } else {
                                cachedClearTimeout = defaultClearTimeout;
                            }
                        } catch (e) {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    })();
                    function runTimeout(fun) {
                        if (cachedSetTimeout === setTimeout) {
                            //normal enviroments in sane situations
                            return setTimeout(fun, 0);
                        }
                        // if setTimeout wasn't available but was latter defined
                        if (
                            (cachedSetTimeout === defaultSetTimout ||
                                !cachedSetTimeout) &&
                            setTimeout
                        ) {
                            cachedSetTimeout = setTimeout;
                            return setTimeout(fun, 0);
                        }
                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedSetTimeout(fun, 0);
                        } catch (e) {
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                                return cachedSetTimeout.call(null, fun, 0);
                            } catch (e) {
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                                return cachedSetTimeout.call(this, fun, 0);
                            }
                        }
                    }
                    function runClearTimeout(marker) {
                        if (cachedClearTimeout === clearTimeout) {
                            //normal enviroments in sane situations
                            return clearTimeout(marker);
                        }
                        // if clearTimeout wasn't available but was latter defined
                        if (
                            (cachedClearTimeout === defaultClearTimeout ||
                                !cachedClearTimeout) &&
                            clearTimeout
                        ) {
                            cachedClearTimeout = clearTimeout;
                            return clearTimeout(marker);
                        }
                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedClearTimeout(marker);
                        } catch (e) {
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                                return cachedClearTimeout.call(null, marker);
                            } catch (e) {
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                                return cachedClearTimeout.call(this, marker);
                            }
                        }
                    }
                    var queue = [];
                    var draining = false;
                    var currentQueue;
                    var queueIndex = -1;

                    function cleanUpNextTick() {
                        if (!draining || !currentQueue) {
                            return;
                        }
                        draining = false;
                        if (currentQueue.length) {
                            queue = currentQueue.concat(queue);
                        } else {
                            queueIndex = -1;
                        }
                        if (queue.length) {
                            drainQueue();
                        }
                    }

                    function drainQueue() {
                        if (draining) {
                            return;
                        }
                        var timeout = runTimeout(cleanUpNextTick);
                        draining = true;

                        var len = queue.length;
                        while (len) {
                            currentQueue = queue;
                            queue = [];
                            while (++queueIndex < len) {
                                if (currentQueue) {
                                    currentQueue[queueIndex].run();
                                }
                            }
                            queueIndex = -1;
                            len = queue.length;
                        }
                        currentQueue = null;
                        draining = false;
                        runClearTimeout(timeout);
                    }

                    process.nextTick = function(fun) {
                        var args = new Array(arguments.length - 1);
                        if (arguments.length > 1) {
                            for (var i = 1; i < arguments.length; i++) {
                                args[i - 1] = arguments[i];
                            }
                        }
                        queue.push(new Item(fun, args));
                        if (queue.length === 1 && !draining) {
                            runTimeout(drainQueue);
                        }
                    };

                    // v8 likes predictible objects
                    function Item(fun, array) {
                        this.fun = fun;
                        this.array = array;
                    }
                    Item.prototype.run = function() {
                        this.fun.apply(null, this.array);
                    };
                    process.title = "browser";
                    process.browser = true;
                    process.env = {};
                    process.argv = [];
                    process.version = ""; // empty string to avoid regexp issues
                    process.versions = {};

                    function noop() {}

                    process.on = noop;
                    process.addListener = noop;
                    process.once = noop;
                    process.off = noop;
                    process.removeListener = noop;
                    process.removeAllListeners = noop;
                    process.emit = noop;
                    process.prependListener = noop;
                    process.prependOnceListener = noop;

                    process.listeners = function(name) {
                        return [];
                    };

                    process.binding = function(name) {
                        throw new Error("process.binding is not supported");
                    };

                    process.cwd = function() {
                        return "/";
                    };
                    process.chdir = function(dir) {
                        throw new Error("process.chdir is not supported");
                    };
                    process.umask = function() {
                        return 0;
                    };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/duplex-browser.js": [
                function(require, module, exports) {
                    module.exports = require("./lib/_stream_duplex.js");
                },
                {
                    "./lib/_stream_duplex.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js": [
                function(require, module, exports) {
                    // a duplex stream is just a stream that is both readable and writable.
                    // Since JS doesn't have multiple prototypal inheritance, this class
                    // prototypally inherits from Readable, and then parasitically from
                    // Writable.

                    "use strict";

                    /*<replacement>*/

                    var objectKeys =
                        Object.keys ||
                        function(obj) {
                            var keys = [];
                            for (var key in obj) {
                                keys.push(key);
                            }
                            return keys;
                        };
                    /*</replacement>*/

                    module.exports = Duplex;

                    /*<replacement>*/
                    var processNextTick = require("process-nextick-args");
                    /*</replacement>*/

                    /*<replacement>*/
                    var util = require("core-util-is");
                    util.inherits = require("inherits");
                    /*</replacement>*/

                    var Readable = require("./_stream_readable");
                    var Writable = require("./_stream_writable");

                    util.inherits(Duplex, Readable);

                    var keys = objectKeys(Writable.prototype);
                    for (var v = 0; v < keys.length; v++) {
                        var method = keys[v];
                        if (!Duplex.prototype[method])
                            Duplex.prototype[method] =
                                Writable.prototype[method];
                    }

                    function Duplex(options) {
                        if (!(this instanceof Duplex))
                            return new Duplex(options);

                        Readable.call(this, options);
                        Writable.call(this, options);

                        if (options && options.readable === false)
                            this.readable = false;

                        if (options && options.writable === false)
                            this.writable = false;

                        this.allowHalfOpen = true;
                        if (options && options.allowHalfOpen === false)
                            this.allowHalfOpen = false;

                        this.once("end", onend);
                    }

                    // the no-half-open enforcer
                    function onend() {
                        // if we allow half-open state, or if the writable side ended,
                        // then we're ok.
                        if (this.allowHalfOpen || this._writableState.ended)
                            return;

                        // no more data can be written.
                        // But allow more writes to happen in this tick.
                        processNextTick(onEndNT, this);
                    }

                    function onEndNT(self) {
                        self.end();
                    }

                    function forEach(xs, f) {
                        for (var i = 0, l = xs.length; i < l; i++) {
                            f(xs[i], i);
                        }
                    }
                },
                {
                    "./_stream_readable":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_readable.js",
                    "./_stream_writable":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_writable.js",
                    "core-util-is":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "process-nextick-args":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process-nextick-args/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_passthrough.js": [
                function(require, module, exports) {
                    // a passthrough stream.
                    // basically just the most minimal sort of Transform stream.
                    // Every written chunk gets output as-is.

                    "use strict";

                    module.exports = PassThrough;

                    var Transform = require("./_stream_transform");

                    /*<replacement>*/
                    var util = require("core-util-is");
                    util.inherits = require("inherits");
                    /*</replacement>*/

                    util.inherits(PassThrough, Transform);

                    function PassThrough(options) {
                        if (!(this instanceof PassThrough))
                            return new PassThrough(options);

                        Transform.call(this, options);
                    }

                    PassThrough.prototype._transform = function(
                        chunk,
                        encoding,
                        cb
                    ) {
                        cb(null, chunk);
                    };
                },
                {
                    "./_stream_transform":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_transform.js",
                    "core-util-is":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_readable.js": [
                function(require, module, exports) {
                    (function(process) {
                        "use strict";

                        module.exports = Readable;

                        /*<replacement>*/
                        var processNextTick = require("process-nextick-args");
                        /*</replacement>*/

                        /*<replacement>*/
                        var isArray = require("isarray");
                        /*</replacement>*/

                        /*<replacement>*/
                        var Duplex;
                        /*</replacement>*/

                        Readable.ReadableState = ReadableState;

                        /*<replacement>*/
                        var EE = require("events").EventEmitter;

                        var EElistenerCount = function(emitter, type) {
                            return emitter.listeners(type).length;
                        };
                        /*</replacement>*/

                        /*<replacement>*/
                        var Stream = require("./internal/streams/stream");
                        /*</replacement>*/

                        var Buffer = require("buffer").Buffer;
                        /*<replacement>*/
                        var bufferShim = require("buffer-shims");
                        /*</replacement>*/

                        /*<replacement>*/
                        var util = require("core-util-is");
                        util.inherits = require("inherits");
                        /*</replacement>*/

                        /*<replacement>*/
                        var debugUtil = require("util");
                        var debug = void 0;
                        if (debugUtil && debugUtil.debuglog) {
                            debug = debugUtil.debuglog("stream");
                        } else {
                            debug = function() {};
                        }
                        /*</replacement>*/

                        var BufferList = require("./internal/streams/BufferList");
                        var StringDecoder;

                        util.inherits(Readable, Stream);

                        var kProxyEvents = [
                            "error",
                            "close",
                            "destroy",
                            "pause",
                            "resume"
                        ];

                        function prependListener(emitter, event, fn) {
                            // Sadly this is not cacheable as some libraries bundle their own
                            // event emitter implementation with them.
                            if (typeof emitter.prependListener === "function") {
                                return emitter.prependListener(event, fn);
                            } else {
                                // This is a hack to make sure that our error handler is attached before any
                                // userland ones.  NEVER DO THIS. This is here only because this code needs
                                // to continue to work with older versions of Node.js that do not include
                                // the prependListener() method. The goal is to eventually remove this hack.
                                if (!emitter._events || !emitter._events[event])
                                    emitter.on(event, fn);
                                else if (isArray(emitter._events[event]))
                                    emitter._events[event].unshift(fn);
                                else
                                    emitter._events[event] = [
                                        fn,
                                        emitter._events[event]
                                    ];
                            }
                        }

                        function ReadableState(options, stream) {
                            Duplex = Duplex || require("./_stream_duplex");

                            options = options || {};

                            // object stream flag. Used to make read(n) ignore n and to
                            // make all the buffer merging and length checks go away
                            this.objectMode = !!options.objectMode;

                            if (stream instanceof Duplex)
                                this.objectMode =
                                    this.objectMode ||
                                    !!options.readableObjectMode;

                            // the point at which it stops calling _read() to fill the buffer
                            // Note: 0 is a valid value, means "don't call _read preemptively ever"
                            var hwm = options.highWaterMark;
                            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                            this.highWaterMark =
                                hwm || hwm === 0 ? hwm : defaultHwm;

                            // cast to ints.
                            this.highWaterMark = ~~this.highWaterMark;

                            // A linked list is used to store data chunks instead of an array because the
                            // linked list can remove elements from the beginning faster than
                            // array.shift()
                            this.buffer = new BufferList();
                            this.length = 0;
                            this.pipes = null;
                            this.pipesCount = 0;
                            this.flowing = null;
                            this.ended = false;
                            this.endEmitted = false;
                            this.reading = false;

                            // a flag to be able to tell if the onwrite cb is called immediately,
                            // or on a later tick.  We set this to true at first, because any
                            // actions that shouldn't happen until "later" should generally also
                            // not happen before the first write call.
                            this.sync = true;

                            // whenever we return null, then we set a flag to say
                            // that we're awaiting a 'readable' event emission.
                            this.needReadable = false;
                            this.emittedReadable = false;
                            this.readableListening = false;
                            this.resumeScheduled = false;

                            // Crypto is kind of old and crusty.  Historically, its default string
                            // encoding is 'binary' so we have to make this configurable.
                            // Everything else in the universe uses 'utf8', though.
                            this.defaultEncoding =
                                options.defaultEncoding || "utf8";

                            // when piping, we only care about 'readable' events that happen
                            // after read()ing all the bytes and not getting any pushback.
                            this.ranOut = false;

                            // the number of writers that are awaiting a drain event in .pipe()s
                            this.awaitDrain = 0;

                            // if true, a maybeReadMore has been scheduled
                            this.readingMore = false;

                            this.decoder = null;
                            this.encoding = null;
                            if (options.encoding) {
                                if (!StringDecoder)
                                    StringDecoder = require("string_decoder/")
                                        .StringDecoder;
                                this.decoder = new StringDecoder(
                                    options.encoding
                                );
                                this.encoding = options.encoding;
                            }
                        }

                        function Readable(options) {
                            Duplex = Duplex || require("./_stream_duplex");

                            if (!(this instanceof Readable))
                                return new Readable(options);

                            this._readableState = new ReadableState(
                                options,
                                this
                            );

                            // legacy
                            this.readable = true;

                            if (options && typeof options.read === "function")
                                this._read = options.read;

                            Stream.call(this);
                        }

                        // Manually shove something into the read() buffer.
                        // This returns true if the highWaterMark has not been hit yet,
                        // similar to how Writable.write() returns true if you should
                        // write() some more.
                        Readable.prototype.push = function(chunk, encoding) {
                            var state = this._readableState;

                            if (
                                !state.objectMode &&
                                typeof chunk === "string"
                            ) {
                                encoding = encoding || state.defaultEncoding;
                                if (encoding !== state.encoding) {
                                    chunk = bufferShim.from(chunk, encoding);
                                    encoding = "";
                                }
                            }

                            return readableAddChunk(
                                this,
                                state,
                                chunk,
                                encoding,
                                false
                            );
                        };

                        // Unshift should *always* be something directly out of read()
                        Readable.prototype.unshift = function(chunk) {
                            var state = this._readableState;
                            return readableAddChunk(
                                this,
                                state,
                                chunk,
                                "",
                                true
                            );
                        };

                        Readable.prototype.isPaused = function() {
                            return this._readableState.flowing === false;
                        };

                        function readableAddChunk(
                            stream,
                            state,
                            chunk,
                            encoding,
                            addToFront
                        ) {
                            var er = chunkInvalid(state, chunk);
                            if (er) {
                                stream.emit("error", er);
                            } else if (chunk === null) {
                                state.reading = false;
                                onEofChunk(stream, state);
                            } else if (
                                state.objectMode ||
                                (chunk && chunk.length > 0)
                            ) {
                                if (state.ended && !addToFront) {
                                    var e = new Error(
                                        "stream.push() after EOF"
                                    );
                                    stream.emit("error", e);
                                } else if (state.endEmitted && addToFront) {
                                    var _e = new Error(
                                        "stream.unshift() after end event"
                                    );
                                    stream.emit("error", _e);
                                } else {
                                    var skipAdd;
                                    if (
                                        state.decoder &&
                                        !addToFront &&
                                        !encoding
                                    ) {
                                        chunk = state.decoder.write(chunk);
                                        skipAdd =
                                            !state.objectMode &&
                                            chunk.length === 0;
                                    }

                                    if (!addToFront) state.reading = false;

                                    // Don't add to the buffer if we've decoded to an empty string chunk and
                                    // we're not in object mode
                                    if (!skipAdd) {
                                        // if we want the data now, just emit it.
                                        if (
                                            state.flowing &&
                                            state.length === 0 &&
                                            !state.sync
                                        ) {
                                            stream.emit("data", chunk);
                                            stream.read(0);
                                        } else {
                                            // update the buffer info.
                                            state.length += state.objectMode
                                                ? 1
                                                : chunk.length;
                                            if (addToFront)
                                                state.buffer.unshift(chunk);
                                            else state.buffer.push(chunk);

                                            if (state.needReadable)
                                                emitReadable(stream);
                                        }
                                    }

                                    maybeReadMore(stream, state);
                                }
                            } else if (!addToFront) {
                                state.reading = false;
                            }

                            return needMoreData(state);
                        }

                        // if it's past the high water mark, we can push in some more.
                        // Also, if we have no data yet, we can stand some
                        // more bytes.  This is to work around cases where hwm=0,
                        // such as the repl.  Also, if the push() triggered a
                        // readable event, and the user called read(largeNumber) such that
                        // needReadable was set, then we ought to push more, so that another
                        // 'readable' event will be triggered.
                        function needMoreData(state) {
                            return (
                                !state.ended &&
                                (state.needReadable ||
                                    state.length < state.highWaterMark ||
                                    state.length === 0)
                            );
                        }

                        // backwards compatibility.
                        Readable.prototype.setEncoding = function(enc) {
                            if (!StringDecoder)
                                StringDecoder = require("string_decoder/")
                                    .StringDecoder;
                            this._readableState.decoder = new StringDecoder(
                                enc
                            );
                            this._readableState.encoding = enc;
                            return this;
                        };

                        // Don't raise the hwm > 8MB
                        var MAX_HWM = 0x800000;
                        function computeNewHighWaterMark(n) {
                            if (n >= MAX_HWM) {
                                n = MAX_HWM;
                            } else {
                                // Get the next highest power of 2 to prevent increasing hwm excessively in
                                // tiny amounts
                                n--;
                                n |= n >>> 1;
                                n |= n >>> 2;
                                n |= n >>> 4;
                                n |= n >>> 8;
                                n |= n >>> 16;
                                n++;
                            }
                            return n;
                        }

                        // This function is designed to be inlinable, so please take care when making
                        // changes to the function body.
                        function howMuchToRead(n, state) {
                            if (n <= 0 || (state.length === 0 && state.ended))
                                return 0;
                            if (state.objectMode) return 1;
                            if (n !== n) {
                                // Only flow one buffer at a time
                                if (state.flowing && state.length)
                                    return state.buffer.head.data.length;
                                else return state.length;
                            }
                            // If we're asking for more than the current hwm, then raise the hwm.
                            if (n > state.highWaterMark)
                                state.highWaterMark = computeNewHighWaterMark(
                                    n
                                );
                            if (n <= state.length) return n;
                            // Don't have enough
                            if (!state.ended) {
                                state.needReadable = true;
                                return 0;
                            }
                            return state.length;
                        }

                        // you can override either this method, or the async _read(n) below.
                        Readable.prototype.read = function(n) {
                            debug("read", n);
                            n = parseInt(n, 10);
                            var state = this._readableState;
                            var nOrig = n;

                            if (n !== 0) state.emittedReadable = false;

                            // if we're doing read(0) to trigger a readable event, but we
                            // already have a bunch of data in the buffer, then just trigger
                            // the 'readable' event and move on.
                            if (
                                n === 0 &&
                                state.needReadable &&
                                (state.length >= state.highWaterMark ||
                                    state.ended)
                            ) {
                                debug(
                                    "read: emitReadable",
                                    state.length,
                                    state.ended
                                );
                                if (state.length === 0 && state.ended)
                                    endReadable(this);
                                else emitReadable(this);
                                return null;
                            }

                            n = howMuchToRead(n, state);

                            // if we've ended, and we're now clear, then finish it up.
                            if (n === 0 && state.ended) {
                                if (state.length === 0) endReadable(this);
                                return null;
                            }

                            // All the actual chunk generation logic needs to be
                            // *below* the call to _read.  The reason is that in certain
                            // synthetic stream cases, such as passthrough streams, _read
                            // may be a completely synchronous operation which may change
                            // the state of the read buffer, providing enough data when
                            // before there was *not* enough.
                            //
                            // So, the steps are:
                            // 1. Figure out what the state of things will be after we do
                            // a read from the buffer.
                            //
                            // 2. If that resulting state will trigger a _read, then call _read.
                            // Note that this may be asynchronous, or synchronous.  Yes, it is
                            // deeply ugly to write APIs this way, but that still doesn't mean
                            // that the Readable class should behave improperly, as streams are
                            // designed to be sync/async agnostic.
                            // Take note if the _read call is sync or async (ie, if the read call
                            // has returned yet), so that we know whether or not it's safe to emit
                            // 'readable' etc.
                            //
                            // 3. Actually pull the requested chunks out of the buffer and return.

                            // if we need a readable event, then we need to do some reading.
                            var doRead = state.needReadable;
                            debug("need readable", doRead);

                            // if we currently have less than the highWaterMark, then also read some
                            if (
                                state.length === 0 ||
                                state.length - n < state.highWaterMark
                            ) {
                                doRead = true;
                                debug("length less than watermark", doRead);
                            }

                            // however, if we've ended, then there's no point, and if we're already
                            // reading, then it's unnecessary.
                            if (state.ended || state.reading) {
                                doRead = false;
                                debug("reading or ended", doRead);
                            } else if (doRead) {
                                debug("do read");
                                state.reading = true;
                                state.sync = true;
                                // if the length is currently zero, then we *need* a readable event.
                                if (state.length === 0)
                                    state.needReadable = true;
                                // call internal read method
                                this._read(state.highWaterMark);
                                state.sync = false;
                                // If _read pushed data synchronously, then `reading` will be false,
                                // and we need to re-evaluate how much data we can return to the user.
                                if (!state.reading)
                                    n = howMuchToRead(nOrig, state);
                            }

                            var ret;
                            if (n > 0) ret = fromList(n, state);
                            else ret = null;

                            if (ret === null) {
                                state.needReadable = true;
                                n = 0;
                            } else {
                                state.length -= n;
                            }

                            if (state.length === 0) {
                                // If we have nothing in the buffer, then we want to know
                                // as soon as we *do* get something into the buffer.
                                if (!state.ended) state.needReadable = true;

                                // If we tried to read() past the EOF, then emit end on the next tick.
                                if (nOrig !== n && state.ended)
                                    endReadable(this);
                            }

                            if (ret !== null) this.emit("data", ret);

                            return ret;
                        };

                        function chunkInvalid(state, chunk) {
                            var er = null;
                            if (
                                !Buffer.isBuffer(chunk) &&
                                typeof chunk !== "string" &&
                                chunk !== null &&
                                chunk !== undefined &&
                                !state.objectMode
                            ) {
                                er = new TypeError(
                                    "Invalid non-string/buffer chunk"
                                );
                            }
                            return er;
                        }

                        function onEofChunk(stream, state) {
                            if (state.ended) return;
                            if (state.decoder) {
                                var chunk = state.decoder.end();
                                if (chunk && chunk.length) {
                                    state.buffer.push(chunk);
                                    state.length += state.objectMode
                                        ? 1
                                        : chunk.length;
                                }
                            }
                            state.ended = true;

                            // emit 'readable' now to make sure it gets picked up.
                            emitReadable(stream);
                        }

                        // Don't emit readable right away in sync mode, because this can trigger
                        // another read() call => stack overflow.  This way, it might trigger
                        // a nextTick recursion warning, but that's not so bad.
                        function emitReadable(stream) {
                            var state = stream._readableState;
                            state.needReadable = false;
                            if (!state.emittedReadable) {
                                debug("emitReadable", state.flowing);
                                state.emittedReadable = true;
                                if (state.sync)
                                    processNextTick(emitReadable_, stream);
                                else emitReadable_(stream);
                            }
                        }

                        function emitReadable_(stream) {
                            debug("emit readable");
                            stream.emit("readable");
                            flow(stream);
                        }

                        // at this point, the user has presumably seen the 'readable' event,
                        // and called read() to consume some data.  that may have triggered
                        // in turn another _read(n) call, in which case reading = true if
                        // it's in progress.
                        // However, if we're not ended, or reading, and the length < hwm,
                        // then go ahead and try to read some more preemptively.
                        function maybeReadMore(stream, state) {
                            if (!state.readingMore) {
                                state.readingMore = true;
                                processNextTick(maybeReadMore_, stream, state);
                            }
                        }

                        function maybeReadMore_(stream, state) {
                            var len = state.length;
                            while (
                                !state.reading &&
                                !state.flowing &&
                                !state.ended &&
                                state.length < state.highWaterMark
                            ) {
                                debug("maybeReadMore read 0");
                                stream.read(0);
                                if (len === state.length)
                                    // didn't get any data, stop spinning.
                                    break;
                                else len = state.length;
                            }
                            state.readingMore = false;
                        }

                        // abstract method.  to be overridden in specific implementation classes.
                        // call cb(er, data) where data is <= n in length.
                        // for virtual (non-string, non-buffer) streams, "length" is somewhat
                        // arbitrary, and perhaps not very meaningful.
                        Readable.prototype._read = function(n) {
                            this.emit(
                                "error",
                                new Error("_read() is not implemented")
                            );
                        };

                        Readable.prototype.pipe = function(dest, pipeOpts) {
                            var src = this;
                            var state = this._readableState;

                            switch (state.pipesCount) {
                                case 0:
                                    state.pipes = dest;
                                    break;
                                case 1:
                                    state.pipes = [state.pipes, dest];
                                    break;
                                default:
                                    state.pipes.push(dest);
                                    break;
                            }
                            state.pipesCount += 1;
                            debug(
                                "pipe count=%d opts=%j",
                                state.pipesCount,
                                pipeOpts
                            );

                            var doEnd =
                                (!pipeOpts || pipeOpts.end !== false) &&
                                dest !== process.stdout &&
                                dest !== process.stderr;

                            var endFn = doEnd ? onend : cleanup;
                            if (state.endEmitted) processNextTick(endFn);
                            else src.once("end", endFn);

                            dest.on("unpipe", onunpipe);
                            function onunpipe(readable) {
                                debug("onunpipe");
                                if (readable === src) {
                                    cleanup();
                                }
                            }

                            function onend() {
                                debug("onend");
                                dest.end();
                            }

                            // when the dest drains, it reduces the awaitDrain counter
                            // on the source.  This would be more elegant with a .once()
                            // handler in flow(), but adding and removing repeatedly is
                            // too slow.
                            var ondrain = pipeOnDrain(src);
                            dest.on("drain", ondrain);

                            var cleanedUp = false;
                            function cleanup() {
                                debug("cleanup");
                                // cleanup event handlers once the pipe is broken
                                dest.removeListener("close", onclose);
                                dest.removeListener("finish", onfinish);
                                dest.removeListener("drain", ondrain);
                                dest.removeListener("error", onerror);
                                dest.removeListener("unpipe", onunpipe);
                                src.removeListener("end", onend);
                                src.removeListener("end", cleanup);
                                src.removeListener("data", ondata);

                                cleanedUp = true;

                                // if the reader is waiting for a drain event from this
                                // specific writer, then it would cause it to never start
                                // flowing again.
                                // So, if this is awaiting a drain, then we just call it now.
                                // If we don't know, then assume that we are waiting for one.
                                if (
                                    state.awaitDrain &&
                                    (!dest._writableState ||
                                        dest._writableState.needDrain)
                                )
                                    ondrain();
                            }

                            // If the user pushes more data while we're writing to dest then we'll end up
                            // in ondata again. However, we only want to increase awaitDrain once because
                            // dest will only emit one 'drain' event for the multiple writes.
                            // => Introduce a guard on increasing awaitDrain.
                            var increasedAwaitDrain = false;
                            src.on("data", ondata);
                            function ondata(chunk) {
                                debug("ondata");
                                increasedAwaitDrain = false;
                                var ret = dest.write(chunk);
                                if (false === ret && !increasedAwaitDrain) {
                                    // If the user unpiped during `dest.write()`, it is possible
                                    // to get stuck in a permanently paused state if that write
                                    // also returned false.
                                    // => Check whether `dest` is still a piping destination.
                                    if (
                                        ((state.pipesCount === 1 &&
                                            state.pipes === dest) ||
                                            (state.pipesCount > 1 &&
                                                indexOf(state.pipes, dest) !==
                                                    -1)) &&
                                        !cleanedUp
                                    ) {
                                        debug(
                                            "false write response, pause",
                                            src._readableState.awaitDrain
                                        );
                                        src._readableState.awaitDrain++;
                                        increasedAwaitDrain = true;
                                    }
                                    src.pause();
                                }
                            }

                            // if the dest has an error, then stop piping into it.
                            // however, don't suppress the throwing behavior for this.
                            function onerror(er) {
                                debug("onerror", er);
                                unpipe();
                                dest.removeListener("error", onerror);
                                if (EElistenerCount(dest, "error") === 0)
                                    dest.emit("error", er);
                            }

                            // Make sure our error handler is attached before userland ones.
                            prependListener(dest, "error", onerror);

                            // Both close and finish should trigger unpipe, but only once.
                            function onclose() {
                                dest.removeListener("finish", onfinish);
                                unpipe();
                            }
                            dest.once("close", onclose);
                            function onfinish() {
                                debug("onfinish");
                                dest.removeListener("close", onclose);
                                unpipe();
                            }
                            dest.once("finish", onfinish);

                            function unpipe() {
                                debug("unpipe");
                                src.unpipe(dest);
                            }

                            // tell the dest that it's being piped to
                            dest.emit("pipe", src);

                            // start the flow if it hasn't been started already.
                            if (!state.flowing) {
                                debug("pipe resume");
                                src.resume();
                            }

                            return dest;
                        };

                        function pipeOnDrain(src) {
                            return function() {
                                var state = src._readableState;
                                debug("pipeOnDrain", state.awaitDrain);
                                if (state.awaitDrain) state.awaitDrain--;
                                if (
                                    state.awaitDrain === 0 &&
                                    EElistenerCount(src, "data")
                                ) {
                                    state.flowing = true;
                                    flow(src);
                                }
                            };
                        }

                        Readable.prototype.unpipe = function(dest) {
                            var state = this._readableState;

                            // if we're not piping anywhere, then do nothing.
                            if (state.pipesCount === 0) return this;

                            // just one destination.  most common case.
                            if (state.pipesCount === 1) {
                                // passed in one, but it's not the right one.
                                if (dest && dest !== state.pipes) return this;

                                if (!dest) dest = state.pipes;

                                // got a match.
                                state.pipes = null;
                                state.pipesCount = 0;
                                state.flowing = false;
                                if (dest) dest.emit("unpipe", this);
                                return this;
                            }

                            // slow case. multiple pipe destinations.

                            if (!dest) {
                                // remove all.
                                var dests = state.pipes;
                                var len = state.pipesCount;
                                state.pipes = null;
                                state.pipesCount = 0;
                                state.flowing = false;

                                for (var i = 0; i < len; i++) {
                                    dests[i].emit("unpipe", this);
                                }
                                return this;
                            }

                            // try to find the right one.
                            var index = indexOf(state.pipes, dest);
                            if (index === -1) return this;

                            state.pipes.splice(index, 1);
                            state.pipesCount -= 1;
                            if (state.pipesCount === 1)
                                state.pipes = state.pipes[0];

                            dest.emit("unpipe", this);

                            return this;
                        };

                        // set up data events if they are asked for
                        // Ensure readable listeners eventually get something
                        Readable.prototype.on = function(ev, fn) {
                            var res = Stream.prototype.on.call(this, ev, fn);

                            if (ev === "data") {
                                // Start flowing on next tick if stream isn't explicitly paused
                                if (this._readableState.flowing !== false)
                                    this.resume();
                            } else if (ev === "readable") {
                                var state = this._readableState;
                                if (
                                    !state.endEmitted &&
                                    !state.readableListening
                                ) {
                                    state.readableListening = state.needReadable = true;
                                    state.emittedReadable = false;
                                    if (!state.reading) {
                                        processNextTick(nReadingNextTick, this);
                                    } else if (state.length) {
                                        emitReadable(this, state);
                                    }
                                }
                            }

                            return res;
                        };
                        Readable.prototype.addListener = Readable.prototype.on;

                        function nReadingNextTick(self) {
                            debug("readable nexttick read 0");
                            self.read(0);
                        }

                        // pause() and resume() are remnants of the legacy readable stream API
                        // If the user uses them, then switch into old mode.
                        Readable.prototype.resume = function() {
                            var state = this._readableState;
                            if (!state.flowing) {
                                debug("resume");
                                state.flowing = true;
                                resume(this, state);
                            }
                            return this;
                        };

                        function resume(stream, state) {
                            if (!state.resumeScheduled) {
                                state.resumeScheduled = true;
                                processNextTick(resume_, stream, state);
                            }
                        }

                        function resume_(stream, state) {
                            if (!state.reading) {
                                debug("resume read 0");
                                stream.read(0);
                            }

                            state.resumeScheduled = false;
                            state.awaitDrain = 0;
                            stream.emit("resume");
                            flow(stream);
                            if (state.flowing && !state.reading) stream.read(0);
                        }

                        Readable.prototype.pause = function() {
                            debug(
                                "call pause flowing=%j",
                                this._readableState.flowing
                            );
                            if (false !== this._readableState.flowing) {
                                debug("pause");
                                this._readableState.flowing = false;
                                this.emit("pause");
                            }
                            return this;
                        };

                        function flow(stream) {
                            var state = stream._readableState;
                            debug("flow", state.flowing);
                            while (state.flowing && stream.read() !== null) {}
                        }

                        // wrap an old-style stream as the async data source.
                        // This is *not* part of the readable stream interface.
                        // It is an ugly unfortunate mess of history.
                        Readable.prototype.wrap = function(stream) {
                            var state = this._readableState;
                            var paused = false;

                            var self = this;
                            stream.on("end", function() {
                                debug("wrapped end");
                                if (state.decoder && !state.ended) {
                                    var chunk = state.decoder.end();
                                    if (chunk && chunk.length) self.push(chunk);
                                }

                                self.push(null);
                            });

                            stream.on("data", function(chunk) {
                                debug("wrapped data");
                                if (state.decoder)
                                    chunk = state.decoder.write(chunk);

                                // don't skip over falsy values in objectMode
                                if (
                                    state.objectMode &&
                                    (chunk === null || chunk === undefined)
                                )
                                    return;
                                else if (
                                    !state.objectMode &&
                                    (!chunk || !chunk.length)
                                )
                                    return;

                                var ret = self.push(chunk);
                                if (!ret) {
                                    paused = true;
                                    stream.pause();
                                }
                            });

                            // proxy all the other methods.
                            // important when wrapping filters and duplexes.
                            for (var i in stream) {
                                if (
                                    this[i] === undefined &&
                                    typeof stream[i] === "function"
                                ) {
                                    this[i] = (function(method) {
                                        return function() {
                                            return stream[method].apply(
                                                stream,
                                                arguments
                                            );
                                        };
                                    })(i);
                                }
                            }

                            // proxy certain important events.
                            for (var n = 0; n < kProxyEvents.length; n++) {
                                stream.on(
                                    kProxyEvents[n],
                                    self.emit.bind(self, kProxyEvents[n])
                                );
                            }

                            // when we try to consume some more bytes, simply unpause the
                            // underlying stream.
                            self._read = function(n) {
                                debug("wrapped _read", n);
                                if (paused) {
                                    paused = false;
                                    stream.resume();
                                }
                            };

                            return self;
                        };

                        // exposed for testing purposes only.
                        Readable._fromList = fromList;

                        // Pluck off n bytes from an array of buffers.
                        // Length is the combined lengths of all the buffers in the list.
                        // This function is designed to be inlinable, so please take care when making
                        // changes to the function body.
                        function fromList(n, state) {
                            // nothing buffered
                            if (state.length === 0) return null;

                            var ret;
                            if (state.objectMode) ret = state.buffer.shift();
                            else if (!n || n >= state.length) {
                                // read it all, truncate the list
                                if (state.decoder) ret = state.buffer.join("");
                                else if (state.buffer.length === 1)
                                    ret = state.buffer.head.data;
                                else ret = state.buffer.concat(state.length);
                                state.buffer.clear();
                            } else {
                                // read part of list
                                ret = fromListPartial(
                                    n,
                                    state.buffer,
                                    state.decoder
                                );
                            }

                            return ret;
                        }

                        // Extracts only enough buffered data to satisfy the amount requested.
                        // This function is designed to be inlinable, so please take care when making
                        // changes to the function body.
                        function fromListPartial(n, list, hasStrings) {
                            var ret;
                            if (n < list.head.data.length) {
                                // slice is the same for buffers and strings
                                ret = list.head.data.slice(0, n);
                                list.head.data = list.head.data.slice(n);
                            } else if (n === list.head.data.length) {
                                // first chunk is a perfect match
                                ret = list.shift();
                            } else {
                                // result spans more than one buffer
                                ret = hasStrings
                                    ? copyFromBufferString(n, list)
                                    : copyFromBuffer(n, list);
                            }
                            return ret;
                        }

                        // Copies a specified amount of characters from the list of buffered data
                        // chunks.
                        // This function is designed to be inlinable, so please take care when making
                        // changes to the function body.
                        function copyFromBufferString(n, list) {
                            var p = list.head;
                            var c = 1;
                            var ret = p.data;
                            n -= ret.length;
                            while ((p = p.next)) {
                                var str = p.data;
                                var nb = n > str.length ? str.length : n;
                                if (nb === str.length) ret += str;
                                else ret += str.slice(0, n);
                                n -= nb;
                                if (n === 0) {
                                    if (nb === str.length) {
                                        ++c;
                                        if (p.next) list.head = p.next;
                                        else list.head = list.tail = null;
                                    } else {
                                        list.head = p;
                                        p.data = str.slice(nb);
                                    }
                                    break;
                                }
                                ++c;
                            }
                            list.length -= c;
                            return ret;
                        }

                        // Copies a specified amount of bytes from the list of buffered data chunks.
                        // This function is designed to be inlinable, so please take care when making
                        // changes to the function body.
                        function copyFromBuffer(n, list) {
                            var ret = bufferShim.allocUnsafe(n);
                            var p = list.head;
                            var c = 1;
                            p.data.copy(ret);
                            n -= p.data.length;
                            while ((p = p.next)) {
                                var buf = p.data;
                                var nb = n > buf.length ? buf.length : n;
                                buf.copy(ret, ret.length - n, 0, nb);
                                n -= nb;
                                if (n === 0) {
                                    if (nb === buf.length) {
                                        ++c;
                                        if (p.next) list.head = p.next;
                                        else list.head = list.tail = null;
                                    } else {
                                        list.head = p;
                                        p.data = buf.slice(nb);
                                    }
                                    break;
                                }
                                ++c;
                            }
                            list.length -= c;
                            return ret;
                        }

                        function endReadable(stream) {
                            var state = stream._readableState;

                            // If we get here before consuming all the bytes, then that is a
                            // bug in node.  Should never happen.
                            if (state.length > 0)
                                throw new Error(
                                    '"endReadable()" called on non-empty stream'
                                );

                            if (!state.endEmitted) {
                                state.ended = true;
                                processNextTick(endReadableNT, state, stream);
                            }
                        }

                        function endReadableNT(state, stream) {
                            // Check that we didn't get one last unshift.
                            if (!state.endEmitted && state.length === 0) {
                                state.endEmitted = true;
                                stream.readable = false;
                                stream.emit("end");
                            }
                        }

                        function forEach(xs, f) {
                            for (var i = 0, l = xs.length; i < l; i++) {
                                f(xs[i], i);
                            }
                        }

                        function indexOf(xs, x) {
                            for (var i = 0, l = xs.length; i < l; i++) {
                                if (xs[i] === x) return i;
                            }
                            return -1;
                        }
                    }.call(this, require("_process")));
                },
                {
                    "./_stream_duplex":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js",
                    "./internal/streams/BufferList":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/internal/streams/BufferList.js",
                    "./internal/streams/stream":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/internal/streams/stream-browser.js",
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "buffer-shims":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer-shims/index.js",
                    "core-util-is":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js",
                    events:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/events/events.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    isarray:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/isarray/index.js",
                    "process-nextick-args":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process-nextick-args/index.js",
                    "string_decoder/":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/string_decoder/lib/string_decoder.js",
                    util:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browser-resolve/empty.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_transform.js": [
                function(require, module, exports) {
                    // a transform stream is a readable/writable stream where you do
                    // something with the data.  Sometimes it's called a "filter",
                    // but that's not a great name for it, since that implies a thing where
                    // some bits pass through, and others are simply ignored.  (That would
                    // be a valid example of a transform, of course.)
                    //
                    // While the output is causally related to the input, it's not a
                    // necessarily symmetric or synchronous transformation.  For example,
                    // a zlib stream might take multiple plain-text writes(), and then
                    // emit a single compressed chunk some time in the future.
                    //
                    // Here's how this works:
                    //
                    // The Transform stream has all the aspects of the readable and writable
                    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
                    // internally, and returns false if there's a lot of pending writes
                    // buffered up.  When you call read(), that calls _read(n) until
                    // there's enough pending readable data buffered up.
                    //
                    // In a transform stream, the written data is placed in a buffer.  When
                    // _read(n) is called, it transforms the queued up data, calling the
                    // buffered _write cb's as it consumes chunks.  If consuming a single
                    // written chunk would result in multiple output chunks, then the first
                    // outputted bit calls the readcb, and subsequent chunks just go into
                    // the read buffer, and will cause it to emit 'readable' if necessary.
                    //
                    // This way, back-pressure is actually determined by the reading side,
                    // since _read has to be called to start processing a new chunk.  However,
                    // a pathological inflate type of transform can cause excessive buffering
                    // here.  For example, imagine a stream where every byte of input is
                    // interpreted as an integer from 0-255, and then results in that many
                    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
                    // 1kb of data being output.  In this case, you could write a very small
                    // amount of input, and end up with a very large amount of output.  In
                    // such a pathological inflating mechanism, there'd be no way to tell
                    // the system to stop doing the transform.  A single 4MB write could
                    // cause the system to run out of memory.
                    //
                    // However, even in such a pathological case, only a single written chunk
                    // would be consumed, and then the rest would wait (un-transformed) until
                    // the results of the previous transformed chunk were consumed.

                    "use strict";

                    module.exports = Transform;

                    var Duplex = require("./_stream_duplex");

                    /*<replacement>*/
                    var util = require("core-util-is");
                    util.inherits = require("inherits");
                    /*</replacement>*/

                    util.inherits(Transform, Duplex);

                    function TransformState(stream) {
                        this.afterTransform = function(er, data) {
                            return afterTransform(stream, er, data);
                        };

                        this.needTransform = false;
                        this.transforming = false;
                        this.writecb = null;
                        this.writechunk = null;
                        this.writeencoding = null;
                    }

                    function afterTransform(stream, er, data) {
                        var ts = stream._transformState;
                        ts.transforming = false;

                        var cb = ts.writecb;

                        if (!cb)
                            return stream.emit(
                                "error",
                                new Error("no writecb in Transform class")
                            );

                        ts.writechunk = null;
                        ts.writecb = null;

                        if (data !== null && data !== undefined)
                            stream.push(data);

                        cb(er);

                        var rs = stream._readableState;
                        rs.reading = false;
                        if (rs.needReadable || rs.length < rs.highWaterMark) {
                            stream._read(rs.highWaterMark);
                        }
                    }

                    function Transform(options) {
                        if (!(this instanceof Transform))
                            return new Transform(options);

                        Duplex.call(this, options);

                        this._transformState = new TransformState(this);

                        var stream = this;

                        // start out asking for a readable event once data is transformed.
                        this._readableState.needReadable = true;

                        // we have implemented the _read method, and done the other things
                        // that Readable wants before the first _read call, so unset the
                        // sync guard flag.
                        this._readableState.sync = false;

                        if (options) {
                            if (typeof options.transform === "function")
                                this._transform = options.transform;

                            if (typeof options.flush === "function")
                                this._flush = options.flush;
                        }

                        // When the writable side finishes, then flush out anything remaining.
                        this.once("prefinish", function() {
                            if (typeof this._flush === "function")
                                this._flush(function(er, data) {
                                    done(stream, er, data);
                                });
                            else done(stream);
                        });
                    }

                    Transform.prototype.push = function(chunk, encoding) {
                        this._transformState.needTransform = false;
                        return Duplex.prototype.push.call(
                            this,
                            chunk,
                            encoding
                        );
                    };

                    // This is the part where you do stuff!
                    // override this function in implementation classes.
                    // 'chunk' is an input chunk.
                    //
                    // Call `push(newChunk)` to pass along transformed output
                    // to the readable side.  You may call 'push' zero or more times.
                    //
                    // Call `cb(err)` when you are done with this chunk.  If you pass
                    // an error, then that'll put the hurt on the whole operation.  If you
                    // never call cb(), then you'll never get another chunk.
                    Transform.prototype._transform = function(
                        chunk,
                        encoding,
                        cb
                    ) {
                        throw new Error("_transform() is not implemented");
                    };

                    Transform.prototype._write = function(chunk, encoding, cb) {
                        var ts = this._transformState;
                        ts.writecb = cb;
                        ts.writechunk = chunk;
                        ts.writeencoding = encoding;
                        if (!ts.transforming) {
                            var rs = this._readableState;
                            if (
                                ts.needTransform ||
                                rs.needReadable ||
                                rs.length < rs.highWaterMark
                            )
                                this._read(rs.highWaterMark);
                        }
                    };

                    // Doesn't matter what the args are here.
                    // _transform does all the work.
                    // That we got here means that the readable side wants more data.
                    Transform.prototype._read = function(n) {
                        var ts = this._transformState;

                        if (
                            ts.writechunk !== null &&
                            ts.writecb &&
                            !ts.transforming
                        ) {
                            ts.transforming = true;
                            this._transform(
                                ts.writechunk,
                                ts.writeencoding,
                                ts.afterTransform
                            );
                        } else {
                            // mark that we need a transform, so that any data that comes in
                            // will get processed, now that we've asked for it.
                            ts.needTransform = true;
                        }
                    };

                    function done(stream, er, data) {
                        if (er) return stream.emit("error", er);

                        if (data !== null && data !== undefined)
                            stream.push(data);

                        // if there's nothing in the write buffer, then that means
                        // that nothing more will ever be provided
                        var ws = stream._writableState;
                        var ts = stream._transformState;

                        if (ws.length)
                            throw new Error(
                                "Calling transform done when ws.length != 0"
                            );

                        if (ts.transforming)
                            throw new Error(
                                "Calling transform done when still transforming"
                            );

                        return stream.push(null);
                    }
                },
                {
                    "./_stream_duplex":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js",
                    "core-util-is":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_writable.js": [
                function(require, module, exports) {
                    (function(process) {
                        // A bit simpler than readable streams.
                        // Implement an async ._write(chunk, encoding, cb), and it'll handle all
                        // the drain event emission and buffering.

                        "use strict";

                        module.exports = Writable;

                        /*<replacement>*/
                        var processNextTick = require("process-nextick-args");
                        /*</replacement>*/

                        /*<replacement>*/
                        var asyncWrite =
                            !process.browser &&
                            ["v0.10", "v0.9."].indexOf(
                                process.version.slice(0, 5)
                            ) > -1
                                ? setImmediate
                                : processNextTick;
                        /*</replacement>*/

                        /*<replacement>*/
                        var Duplex;
                        /*</replacement>*/

                        Writable.WritableState = WritableState;

                        /*<replacement>*/
                        var util = require("core-util-is");
                        util.inherits = require("inherits");
                        /*</replacement>*/

                        /*<replacement>*/
                        var internalUtil = {
                            deprecate: require("util-deprecate")
                        };
                        /*</replacement>*/

                        /*<replacement>*/
                        var Stream = require("./internal/streams/stream");
                        /*</replacement>*/

                        var Buffer = require("buffer").Buffer;
                        /*<replacement>*/
                        var bufferShim = require("buffer-shims");
                        /*</replacement>*/

                        util.inherits(Writable, Stream);

                        function nop() {}

                        function WriteReq(chunk, encoding, cb) {
                            this.chunk = chunk;
                            this.encoding = encoding;
                            this.callback = cb;
                            this.next = null;
                        }

                        function WritableState(options, stream) {
                            Duplex = Duplex || require("./_stream_duplex");

                            options = options || {};

                            // object stream flag to indicate whether or not this stream
                            // contains buffers or objects.
                            this.objectMode = !!options.objectMode;

                            if (stream instanceof Duplex)
                                this.objectMode =
                                    this.objectMode ||
                                    !!options.writableObjectMode;

                            // the point at which write() starts returning false
                            // Note: 0 is a valid value, means that we always return false if
                            // the entire buffer is not flushed immediately on write()
                            var hwm = options.highWaterMark;
                            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                            this.highWaterMark =
                                hwm || hwm === 0 ? hwm : defaultHwm;

                            // cast to ints.
                            this.highWaterMark = ~~this.highWaterMark;

                            // drain event flag.
                            this.needDrain = false;
                            // at the start of calling end()
                            this.ending = false;
                            // when end() has been called, and returned
                            this.ended = false;
                            // when 'finish' is emitted
                            this.finished = false;

                            // should we decode strings into buffers before passing to _write?
                            // this is here so that some node-core streams can optimize string
                            // handling at a lower level.
                            var noDecode = options.decodeStrings === false;
                            this.decodeStrings = !noDecode;

                            // Crypto is kind of old and crusty.  Historically, its default string
                            // encoding is 'binary' so we have to make this configurable.
                            // Everything else in the universe uses 'utf8', though.
                            this.defaultEncoding =
                                options.defaultEncoding || "utf8";

                            // not an actual buffer we keep track of, but a measurement
                            // of how much we're waiting to get pushed to some underlying
                            // socket or file.
                            this.length = 0;

                            // a flag to see when we're in the middle of a write.
                            this.writing = false;

                            // when true all writes will be buffered until .uncork() call
                            this.corked = 0;

                            // a flag to be able to tell if the onwrite cb is called immediately,
                            // or on a later tick.  We set this to true at first, because any
                            // actions that shouldn't happen until "later" should generally also
                            // not happen before the first write call.
                            this.sync = true;

                            // a flag to know if we're processing previously buffered items, which
                            // may call the _write() callback in the same tick, so that we don't
                            // end up in an overlapped onwrite situation.
                            this.bufferProcessing = false;

                            // the callback that's passed to _write(chunk,cb)
                            this.onwrite = function(er) {
                                onwrite(stream, er);
                            };

                            // the callback that the user supplies to write(chunk,encoding,cb)
                            this.writecb = null;

                            // the amount that is being written when _write is called.
                            this.writelen = 0;

                            this.bufferedRequest = null;
                            this.lastBufferedRequest = null;

                            // number of pending user-supplied write callbacks
                            // this must be 0 before 'finish' can be emitted
                            this.pendingcb = 0;

                            // emit prefinish if the only thing we're waiting for is _write cbs
                            // This is relevant for synchronous Transform streams
                            this.prefinished = false;

                            // True if the error was already emitted and should not be thrown again
                            this.errorEmitted = false;

                            // count buffered requests
                            this.bufferedRequestCount = 0;

                            // allocate the first CorkedRequest, there is always
                            // one allocated and free to use, and we maintain at most two
                            this.corkedRequestsFree = new CorkedRequest(this);
                        }

                        WritableState.prototype.getBuffer = function getBuffer() {
                            var current = this.bufferedRequest;
                            var out = [];
                            while (current) {
                                out.push(current);
                                current = current.next;
                            }
                            return out;
                        };

                        (function() {
                            try {
                                Object.defineProperty(
                                    WritableState.prototype,
                                    "buffer",
                                    {
                                        get: internalUtil.deprecate(function() {
                                            return this.getBuffer();
                                        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                                            "instead.")
                                    }
                                );
                            } catch (_) {}
                        })();

                        // Test _writableState for inheritance to account for Duplex streams,
                        // whose prototype chain only points to Readable.
                        var realHasInstance;
                        if (
                            typeof Symbol === "function" &&
                            Symbol.hasInstance &&
                            typeof Function.prototype[Symbol.hasInstance] ===
                                "function"
                        ) {
                            realHasInstance =
                                Function.prototype[Symbol.hasInstance];
                            Object.defineProperty(
                                Writable,
                                Symbol.hasInstance,
                                {
                                    value: function(object) {
                                        if (realHasInstance.call(this, object))
                                            return true;

                                        return (
                                            object &&
                                            object._writableState instanceof
                                                WritableState
                                        );
                                    }
                                }
                            );
                        } else {
                            realHasInstance = function(object) {
                                return object instanceof this;
                            };
                        }

                        function Writable(options) {
                            Duplex = Duplex || require("./_stream_duplex");

                            // Writable ctor is applied to Duplexes, too.
                            // `realHasInstance` is necessary because using plain `instanceof`
                            // would return false, as no `_writableState` property is attached.

                            // Trying to use the custom `instanceof` for Writable here will also break the
                            // Node.js LazyTransform implementation, which has a non-trivial getter for
                            // `_writableState` that would lead to infinite recursion.
                            if (
                                !realHasInstance.call(Writable, this) &&
                                !(this instanceof Duplex)
                            ) {
                                return new Writable(options);
                            }

                            this._writableState = new WritableState(
                                options,
                                this
                            );

                            // legacy.
                            this.writable = true;

                            if (options) {
                                if (typeof options.write === "function")
                                    this._write = options.write;

                                if (typeof options.writev === "function")
                                    this._writev = options.writev;
                            }

                            Stream.call(this);
                        }

                        // Otherwise people can pipe Writable streams, which is just wrong.
                        Writable.prototype.pipe = function() {
                            this.emit(
                                "error",
                                new Error("Cannot pipe, not readable")
                            );
                        };

                        function writeAfterEnd(stream, cb) {
                            var er = new Error("write after end");
                            // TODO: defer error events consistently everywhere, not just the cb
                            stream.emit("error", er);
                            processNextTick(cb, er);
                        }

                        // Checks that a user-supplied chunk is valid, especially for the particular
                        // mode the stream is in. Currently this means that `null` is never accepted
                        // and undefined/non-string values are only allowed in object mode.
                        function validChunk(stream, state, chunk, cb) {
                            var valid = true;
                            var er = false;

                            if (chunk === null) {
                                er = new TypeError(
                                    "May not write null values to stream"
                                );
                            } else if (
                                typeof chunk !== "string" &&
                                chunk !== undefined &&
                                !state.objectMode
                            ) {
                                er = new TypeError(
                                    "Invalid non-string/buffer chunk"
                                );
                            }
                            if (er) {
                                stream.emit("error", er);
                                processNextTick(cb, er);
                                valid = false;
                            }
                            return valid;
                        }

                        Writable.prototype.write = function(
                            chunk,
                            encoding,
                            cb
                        ) {
                            var state = this._writableState;
                            var ret = false;
                            var isBuf = Buffer.isBuffer(chunk);

                            if (typeof encoding === "function") {
                                cb = encoding;
                                encoding = null;
                            }

                            if (isBuf) encoding = "buffer";
                            else if (!encoding)
                                encoding = state.defaultEncoding;

                            if (typeof cb !== "function") cb = nop;

                            if (state.ended) writeAfterEnd(this, cb);
                            else if (
                                isBuf ||
                                validChunk(this, state, chunk, cb)
                            ) {
                                state.pendingcb++;
                                ret = writeOrBuffer(
                                    this,
                                    state,
                                    isBuf,
                                    chunk,
                                    encoding,
                                    cb
                                );
                            }

                            return ret;
                        };

                        Writable.prototype.cork = function() {
                            var state = this._writableState;

                            state.corked++;
                        };

                        Writable.prototype.uncork = function() {
                            var state = this._writableState;

                            if (state.corked) {
                                state.corked--;

                                if (
                                    !state.writing &&
                                    !state.corked &&
                                    !state.finished &&
                                    !state.bufferProcessing &&
                                    state.bufferedRequest
                                )
                                    clearBuffer(this, state);
                            }
                        };

                        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
                            encoding
                        ) {
                            // node::ParseEncoding() requires lower case.
                            if (typeof encoding === "string")
                                encoding = encoding.toLowerCase();
                            if (
                                !(
                                    [
                                        "hex",
                                        "utf8",
                                        "utf-8",
                                        "ascii",
                                        "binary",
                                        "base64",
                                        "ucs2",
                                        "ucs-2",
                                        "utf16le",
                                        "utf-16le",
                                        "raw"
                                    ].indexOf((encoding + "").toLowerCase()) >
                                    -1
                                )
                            )
                                throw new TypeError(
                                    "Unknown encoding: " + encoding
                                );
                            this._writableState.defaultEncoding = encoding;
                            return this;
                        };

                        function decodeChunk(state, chunk, encoding) {
                            if (
                                !state.objectMode &&
                                state.decodeStrings !== false &&
                                typeof chunk === "string"
                            ) {
                                chunk = bufferShim.from(chunk, encoding);
                            }
                            return chunk;
                        }

                        // if we're already writing something, then just put this
                        // in the queue, and wait our turn.  Otherwise, call _write
                        // If we return false, then we need a drain event, so set that flag.
                        function writeOrBuffer(
                            stream,
                            state,
                            isBuf,
                            chunk,
                            encoding,
                            cb
                        ) {
                            if (!isBuf) {
                                chunk = decodeChunk(state, chunk, encoding);
                                if (Buffer.isBuffer(chunk)) encoding = "buffer";
                            }
                            var len = state.objectMode ? 1 : chunk.length;

                            state.length += len;

                            var ret = state.length < state.highWaterMark;
                            // we must ensure that previous needDrain will not be reset to false.
                            if (!ret) state.needDrain = true;

                            if (state.writing || state.corked) {
                                var last = state.lastBufferedRequest;
                                state.lastBufferedRequest = new WriteReq(
                                    chunk,
                                    encoding,
                                    cb
                                );
                                if (last) {
                                    last.next = state.lastBufferedRequest;
                                } else {
                                    state.bufferedRequest =
                                        state.lastBufferedRequest;
                                }
                                state.bufferedRequestCount += 1;
                            } else {
                                doWrite(
                                    stream,
                                    state,
                                    false,
                                    len,
                                    chunk,
                                    encoding,
                                    cb
                                );
                            }

                            return ret;
                        }

                        function doWrite(
                            stream,
                            state,
                            writev,
                            len,
                            chunk,
                            encoding,
                            cb
                        ) {
                            state.writelen = len;
                            state.writecb = cb;
                            state.writing = true;
                            state.sync = true;
                            if (writev) stream._writev(chunk, state.onwrite);
                            else stream._write(chunk, encoding, state.onwrite);
                            state.sync = false;
                        }

                        function onwriteError(stream, state, sync, er, cb) {
                            --state.pendingcb;
                            if (sync) processNextTick(cb, er);
                            else cb(er);

                            stream._writableState.errorEmitted = true;
                            stream.emit("error", er);
                        }

                        function onwriteStateUpdate(state) {
                            state.writing = false;
                            state.writecb = null;
                            state.length -= state.writelen;
                            state.writelen = 0;
                        }

                        function onwrite(stream, er) {
                            var state = stream._writableState;
                            var sync = state.sync;
                            var cb = state.writecb;

                            onwriteStateUpdate(state);

                            if (er) onwriteError(stream, state, sync, er, cb);
                            else {
                                // Check if we're actually ready to finish, but don't emit yet
                                var finished = needFinish(state);

                                if (
                                    !finished &&
                                    !state.corked &&
                                    !state.bufferProcessing &&
                                    state.bufferedRequest
                                ) {
                                    clearBuffer(stream, state);
                                }

                                if (sync) {
                                    /*<replacement>*/
                                    asyncWrite(
                                        afterWrite,
                                        stream,
                                        state,
                                        finished,
                                        cb
                                    );
                                    /*</replacement>*/
                                } else {
                                    afterWrite(stream, state, finished, cb);
                                }
                            }
                        }

                        function afterWrite(stream, state, finished, cb) {
                            if (!finished) onwriteDrain(stream, state);
                            state.pendingcb--;
                            cb();
                            finishMaybe(stream, state);
                        }

                        // Must force callback to be called on nextTick, so that we don't
                        // emit 'drain' before the write() consumer gets the 'false' return
                        // value, and has a chance to attach a 'drain' listener.
                        function onwriteDrain(stream, state) {
                            if (state.length === 0 && state.needDrain) {
                                state.needDrain = false;
                                stream.emit("drain");
                            }
                        }

                        // if there's something in the buffer waiting, then process it
                        function clearBuffer(stream, state) {
                            state.bufferProcessing = true;
                            var entry = state.bufferedRequest;

                            if (stream._writev && entry && entry.next) {
                                // Fast case, write everything using _writev()
                                var l = state.bufferedRequestCount;
                                var buffer = new Array(l);
                                var holder = state.corkedRequestsFree;
                                holder.entry = entry;

                                var count = 0;
                                while (entry) {
                                    buffer[count] = entry;
                                    entry = entry.next;
                                    count += 1;
                                }

                                doWrite(
                                    stream,
                                    state,
                                    true,
                                    state.length,
                                    buffer,
                                    "",
                                    holder.finish
                                );

                                // doWrite is almost always async, defer these to save a bit of time
                                // as the hot path ends with doWrite
                                state.pendingcb++;
                                state.lastBufferedRequest = null;
                                if (holder.next) {
                                    state.corkedRequestsFree = holder.next;
                                    holder.next = null;
                                } else {
                                    state.corkedRequestsFree = new CorkedRequest(
                                        state
                                    );
                                }
                            } else {
                                // Slow case, write chunks one-by-one
                                while (entry) {
                                    var chunk = entry.chunk;
                                    var encoding = entry.encoding;
                                    var cb = entry.callback;
                                    var len = state.objectMode
                                        ? 1
                                        : chunk.length;

                                    doWrite(
                                        stream,
                                        state,
                                        false,
                                        len,
                                        chunk,
                                        encoding,
                                        cb
                                    );
                                    entry = entry.next;
                                    // if we didn't call the onwrite immediately, then
                                    // it means that we need to wait until it does.
                                    // also, that means that the chunk and cb are currently
                                    // being processed, so move the buffer counter past them.
                                    if (state.writing) {
                                        break;
                                    }
                                }

                                if (entry === null)
                                    state.lastBufferedRequest = null;
                            }

                            state.bufferedRequestCount = 0;
                            state.bufferedRequest = entry;
                            state.bufferProcessing = false;
                        }

                        Writable.prototype._write = function(
                            chunk,
                            encoding,
                            cb
                        ) {
                            cb(new Error("_write() is not implemented"));
                        };

                        Writable.prototype._writev = null;

                        Writable.prototype.end = function(chunk, encoding, cb) {
                            var state = this._writableState;

                            if (typeof chunk === "function") {
                                cb = chunk;
                                chunk = null;
                                encoding = null;
                            } else if (typeof encoding === "function") {
                                cb = encoding;
                                encoding = null;
                            }

                            if (chunk !== null && chunk !== undefined)
                                this.write(chunk, encoding);

                            // .end() fully uncorks
                            if (state.corked) {
                                state.corked = 1;
                                this.uncork();
                            }

                            // ignore unnecessary end() calls.
                            if (!state.ending && !state.finished)
                                endWritable(this, state, cb);
                        };

                        function needFinish(state) {
                            return (
                                state.ending &&
                                state.length === 0 &&
                                state.bufferedRequest === null &&
                                !state.finished &&
                                !state.writing
                            );
                        }

                        function prefinish(stream, state) {
                            if (!state.prefinished) {
                                state.prefinished = true;
                                stream.emit("prefinish");
                            }
                        }

                        function finishMaybe(stream, state) {
                            var need = needFinish(state);
                            if (need) {
                                if (state.pendingcb === 0) {
                                    prefinish(stream, state);
                                    state.finished = true;
                                    stream.emit("finish");
                                } else {
                                    prefinish(stream, state);
                                }
                            }
                            return need;
                        }

                        function endWritable(stream, state, cb) {
                            state.ending = true;
                            finishMaybe(stream, state);
                            if (cb) {
                                if (state.finished) processNextTick(cb);
                                else stream.once("finish", cb);
                            }
                            state.ended = true;
                            stream.writable = false;
                        }

                        // It seems a linked list but it is not
                        // there will be only 2 of these for each stream
                        function CorkedRequest(state) {
                            var _this = this;

                            this.next = null;
                            this.entry = null;
                            this.finish = function(err) {
                                var entry = _this.entry;
                                _this.entry = null;
                                while (entry) {
                                    var cb = entry.callback;
                                    state.pendingcb--;
                                    cb(err);
                                    entry = entry.next;
                                }
                                if (state.corkedRequestsFree) {
                                    state.corkedRequestsFree.next = _this;
                                } else {
                                    state.corkedRequestsFree = _this;
                                }
                            };
                        }
                    }.call(this, require("_process")));
                },
                {
                    "./_stream_duplex":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js",
                    "./internal/streams/stream":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/internal/streams/stream-browser.js",
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "buffer-shims":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer-shims/index.js",
                    "core-util-is":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/core-util-is/lib/util.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "process-nextick-args":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process-nextick-args/index.js",
                    "util-deprecate":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util-deprecate/browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/internal/streams/BufferList.js": [
                function(require, module, exports) {
                    "use strict";

                    var Buffer = require("buffer").Buffer;
                    /*<replacement>*/
                    var bufferShim = require("buffer-shims");
                    /*</replacement>*/

                    module.exports = BufferList;

                    function BufferList() {
                        this.head = null;
                        this.tail = null;
                        this.length = 0;
                    }

                    BufferList.prototype.push = function(v) {
                        var entry = {data: v, next: null};
                        if (this.length > 0) this.tail.next = entry;
                        else this.head = entry;
                        this.tail = entry;
                        ++this.length;
                    };

                    BufferList.prototype.unshift = function(v) {
                        var entry = {data: v, next: this.head};
                        if (this.length === 0) this.tail = entry;
                        this.head = entry;
                        ++this.length;
                    };

                    BufferList.prototype.shift = function() {
                        if (this.length === 0) return;
                        var ret = this.head.data;
                        if (this.length === 1) this.head = this.tail = null;
                        else this.head = this.head.next;
                        --this.length;
                        return ret;
                    };

                    BufferList.prototype.clear = function() {
                        this.head = this.tail = null;
                        this.length = 0;
                    };

                    BufferList.prototype.join = function(s) {
                        if (this.length === 0) return "";
                        var p = this.head;
                        var ret = "" + p.data;
                        while ((p = p.next)) {
                            ret += s + p.data;
                        }
                        return ret;
                    };

                    BufferList.prototype.concat = function(n) {
                        if (this.length === 0) return bufferShim.alloc(0);
                        if (this.length === 1) return this.head.data;
                        var ret = bufferShim.allocUnsafe(n >>> 0);
                        var p = this.head;
                        var i = 0;
                        while (p) {
                            p.data.copy(ret, i);
                            i += p.data.length;
                            p = p.next;
                        }
                        return ret;
                    };
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "buffer-shims":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer-shims/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/internal/streams/stream-browser.js": [
                function(require, module, exports) {
                    module.exports = require("events").EventEmitter;
                },
                {
                    events:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/events/events.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/passthrough.js": [
                function(require, module, exports) {
                    module.exports = require("./readable").PassThrough;
                },
                {
                    "./readable":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/readable-browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/readable-browser.js": [
                function(require, module, exports) {
                    exports = module.exports = require("./lib/_stream_readable.js");
                    exports.Stream = exports;
                    exports.Readable = exports;
                    exports.Writable = require("./lib/_stream_writable.js");
                    exports.Duplex = require("./lib/_stream_duplex.js");
                    exports.Transform = require("./lib/_stream_transform.js");
                    exports.PassThrough = require("./lib/_stream_passthrough.js");
                },
                {
                    "./lib/_stream_duplex.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_duplex.js",
                    "./lib/_stream_passthrough.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_passthrough.js",
                    "./lib/_stream_readable.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_readable.js",
                    "./lib/_stream_transform.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_transform.js",
                    "./lib/_stream_writable.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_writable.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/transform.js": [
                function(require, module, exports) {
                    module.exports = require("./readable").Transform;
                },
                {
                    "./readable":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/readable-browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/writable-browser.js": [
                function(require, module, exports) {
                    module.exports = require("./lib/_stream_writable.js");
                },
                {
                    "./lib/_stream_writable.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/lib/_stream_writable.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/ripemd160/index.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        "use strict";
                        var inherits = require("inherits");
                        var HashBase = require("hash-base");

                        function RIPEMD160() {
                            HashBase.call(this, 64);

                            // state
                            this._a = 0x67452301;
                            this._b = 0xefcdab89;
                            this._c = 0x98badcfe;
                            this._d = 0x10325476;
                            this._e = 0xc3d2e1f0;
                        }

                        inherits(RIPEMD160, HashBase);

                        RIPEMD160.prototype._update = function() {
                            var m = new Array(16);
                            for (var i = 0; i < 16; ++i)
                                m[i] = this._block.readInt32LE(i * 4);

                            var al = this._a;
                            var bl = this._b;
                            var cl = this._c;
                            var dl = this._d;
                            var el = this._e;

                            // Mj = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
                            // K = 0x00000000
                            // Sj = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
                            al = fn1(al, bl, cl, dl, el, m[0], 0x00000000, 11);
                            cl = rotl(cl, 10);
                            el = fn1(el, al, bl, cl, dl, m[1], 0x00000000, 14);
                            bl = rotl(bl, 10);
                            dl = fn1(dl, el, al, bl, cl, m[2], 0x00000000, 15);
                            al = rotl(al, 10);
                            cl = fn1(cl, dl, el, al, bl, m[3], 0x00000000, 12);
                            el = rotl(el, 10);
                            bl = fn1(bl, cl, dl, el, al, m[4], 0x00000000, 5);
                            dl = rotl(dl, 10);
                            al = fn1(al, bl, cl, dl, el, m[5], 0x00000000, 8);
                            cl = rotl(cl, 10);
                            el = fn1(el, al, bl, cl, dl, m[6], 0x00000000, 7);
                            bl = rotl(bl, 10);
                            dl = fn1(dl, el, al, bl, cl, m[7], 0x00000000, 9);
                            al = rotl(al, 10);
                            cl = fn1(cl, dl, el, al, bl, m[8], 0x00000000, 11);
                            el = rotl(el, 10);
                            bl = fn1(bl, cl, dl, el, al, m[9], 0x00000000, 13);
                            dl = rotl(dl, 10);
                            al = fn1(al, bl, cl, dl, el, m[10], 0x00000000, 14);
                            cl = rotl(cl, 10);
                            el = fn1(el, al, bl, cl, dl, m[11], 0x00000000, 15);
                            bl = rotl(bl, 10);
                            dl = fn1(dl, el, al, bl, cl, m[12], 0x00000000, 6);
                            al = rotl(al, 10);
                            cl = fn1(cl, dl, el, al, bl, m[13], 0x00000000, 7);
                            el = rotl(el, 10);
                            bl = fn1(bl, cl, dl, el, al, m[14], 0x00000000, 9);
                            dl = rotl(dl, 10);
                            al = fn1(al, bl, cl, dl, el, m[15], 0x00000000, 8);
                            cl = rotl(cl, 10);

                            // Mj = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
                            // K = 0x5a827999
                            // Sj = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
                            el = fn2(el, al, bl, cl, dl, m[7], 0x5a827999, 7);
                            bl = rotl(bl, 10);
                            dl = fn2(dl, el, al, bl, cl, m[4], 0x5a827999, 6);
                            al = rotl(al, 10);
                            cl = fn2(cl, dl, el, al, bl, m[13], 0x5a827999, 8);
                            el = rotl(el, 10);
                            bl = fn2(bl, cl, dl, el, al, m[1], 0x5a827999, 13);
                            dl = rotl(dl, 10);
                            al = fn2(al, bl, cl, dl, el, m[10], 0x5a827999, 11);
                            cl = rotl(cl, 10);
                            el = fn2(el, al, bl, cl, dl, m[6], 0x5a827999, 9);
                            bl = rotl(bl, 10);
                            dl = fn2(dl, el, al, bl, cl, m[15], 0x5a827999, 7);
                            al = rotl(al, 10);
                            cl = fn2(cl, dl, el, al, bl, m[3], 0x5a827999, 15);
                            el = rotl(el, 10);
                            bl = fn2(bl, cl, dl, el, al, m[12], 0x5a827999, 7);
                            dl = rotl(dl, 10);
                            al = fn2(al, bl, cl, dl, el, m[0], 0x5a827999, 12);
                            cl = rotl(cl, 10);
                            el = fn2(el, al, bl, cl, dl, m[9], 0x5a827999, 15);
                            bl = rotl(bl, 10);
                            dl = fn2(dl, el, al, bl, cl, m[5], 0x5a827999, 9);
                            al = rotl(al, 10);
                            cl = fn2(cl, dl, el, al, bl, m[2], 0x5a827999, 11);
                            el = rotl(el, 10);
                            bl = fn2(bl, cl, dl, el, al, m[14], 0x5a827999, 7);
                            dl = rotl(dl, 10);
                            al = fn2(al, bl, cl, dl, el, m[11], 0x5a827999, 13);
                            cl = rotl(cl, 10);
                            el = fn2(el, al, bl, cl, dl, m[8], 0x5a827999, 12);
                            bl = rotl(bl, 10);

                            // Mj = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
                            // K = 0x6ed9eba1
                            // Sj = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
                            dl = fn3(dl, el, al, bl, cl, m[3], 0x6ed9eba1, 11);
                            al = rotl(al, 10);
                            cl = fn3(cl, dl, el, al, bl, m[10], 0x6ed9eba1, 13);
                            el = rotl(el, 10);
                            bl = fn3(bl, cl, dl, el, al, m[14], 0x6ed9eba1, 6);
                            dl = rotl(dl, 10);
                            al = fn3(al, bl, cl, dl, el, m[4], 0x6ed9eba1, 7);
                            cl = rotl(cl, 10);
                            el = fn3(el, al, bl, cl, dl, m[9], 0x6ed9eba1, 14);
                            bl = rotl(bl, 10);
                            dl = fn3(dl, el, al, bl, cl, m[15], 0x6ed9eba1, 9);
                            al = rotl(al, 10);
                            cl = fn3(cl, dl, el, al, bl, m[8], 0x6ed9eba1, 13);
                            el = rotl(el, 10);
                            bl = fn3(bl, cl, dl, el, al, m[1], 0x6ed9eba1, 15);
                            dl = rotl(dl, 10);
                            al = fn3(al, bl, cl, dl, el, m[2], 0x6ed9eba1, 14);
                            cl = rotl(cl, 10);
                            el = fn3(el, al, bl, cl, dl, m[7], 0x6ed9eba1, 8);
                            bl = rotl(bl, 10);
                            dl = fn3(dl, el, al, bl, cl, m[0], 0x6ed9eba1, 13);
                            al = rotl(al, 10);
                            cl = fn3(cl, dl, el, al, bl, m[6], 0x6ed9eba1, 6);
                            el = rotl(el, 10);
                            bl = fn3(bl, cl, dl, el, al, m[13], 0x6ed9eba1, 5);
                            dl = rotl(dl, 10);
                            al = fn3(al, bl, cl, dl, el, m[11], 0x6ed9eba1, 12);
                            cl = rotl(cl, 10);
                            el = fn3(el, al, bl, cl, dl, m[5], 0x6ed9eba1, 7);
                            bl = rotl(bl, 10);
                            dl = fn3(dl, el, al, bl, cl, m[12], 0x6ed9eba1, 5);
                            al = rotl(al, 10);

                            // Mj = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
                            // K = 0x8f1bbcdc
                            // Sj = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
                            cl = fn4(cl, dl, el, al, bl, m[1], 0x8f1bbcdc, 11);
                            el = rotl(el, 10);
                            bl = fn4(bl, cl, dl, el, al, m[9], 0x8f1bbcdc, 12);
                            dl = rotl(dl, 10);
                            al = fn4(al, bl, cl, dl, el, m[11], 0x8f1bbcdc, 14);
                            cl = rotl(cl, 10);
                            el = fn4(el, al, bl, cl, dl, m[10], 0x8f1bbcdc, 15);
                            bl = rotl(bl, 10);
                            dl = fn4(dl, el, al, bl, cl, m[0], 0x8f1bbcdc, 14);
                            al = rotl(al, 10);
                            cl = fn4(cl, dl, el, al, bl, m[8], 0x8f1bbcdc, 15);
                            el = rotl(el, 10);
                            bl = fn4(bl, cl, dl, el, al, m[12], 0x8f1bbcdc, 9);
                            dl = rotl(dl, 10);
                            al = fn4(al, bl, cl, dl, el, m[4], 0x8f1bbcdc, 8);
                            cl = rotl(cl, 10);
                            el = fn4(el, al, bl, cl, dl, m[13], 0x8f1bbcdc, 9);
                            bl = rotl(bl, 10);
                            dl = fn4(dl, el, al, bl, cl, m[3], 0x8f1bbcdc, 14);
                            al = rotl(al, 10);
                            cl = fn4(cl, dl, el, al, bl, m[7], 0x8f1bbcdc, 5);
                            el = rotl(el, 10);
                            bl = fn4(bl, cl, dl, el, al, m[15], 0x8f1bbcdc, 6);
                            dl = rotl(dl, 10);
                            al = fn4(al, bl, cl, dl, el, m[14], 0x8f1bbcdc, 8);
                            cl = rotl(cl, 10);
                            el = fn4(el, al, bl, cl, dl, m[5], 0x8f1bbcdc, 6);
                            bl = rotl(bl, 10);
                            dl = fn4(dl, el, al, bl, cl, m[6], 0x8f1bbcdc, 5);
                            al = rotl(al, 10);
                            cl = fn4(cl, dl, el, al, bl, m[2], 0x8f1bbcdc, 12);
                            el = rotl(el, 10);

                            // Mj = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
                            // K = 0xa953fd4e
                            // Sj = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
                            bl = fn5(bl, cl, dl, el, al, m[4], 0xa953fd4e, 9);
                            dl = rotl(dl, 10);
                            al = fn5(al, bl, cl, dl, el, m[0], 0xa953fd4e, 15);
                            cl = rotl(cl, 10);
                            el = fn5(el, al, bl, cl, dl, m[5], 0xa953fd4e, 5);
                            bl = rotl(bl, 10);
                            dl = fn5(dl, el, al, bl, cl, m[9], 0xa953fd4e, 11);
                            al = rotl(al, 10);
                            cl = fn5(cl, dl, el, al, bl, m[7], 0xa953fd4e, 6);
                            el = rotl(el, 10);
                            bl = fn5(bl, cl, dl, el, al, m[12], 0xa953fd4e, 8);
                            dl = rotl(dl, 10);
                            al = fn5(al, bl, cl, dl, el, m[2], 0xa953fd4e, 13);
                            cl = rotl(cl, 10);
                            el = fn5(el, al, bl, cl, dl, m[10], 0xa953fd4e, 12);
                            bl = rotl(bl, 10);
                            dl = fn5(dl, el, al, bl, cl, m[14], 0xa953fd4e, 5);
                            al = rotl(al, 10);
                            cl = fn5(cl, dl, el, al, bl, m[1], 0xa953fd4e, 12);
                            el = rotl(el, 10);
                            bl = fn5(bl, cl, dl, el, al, m[3], 0xa953fd4e, 13);
                            dl = rotl(dl, 10);
                            al = fn5(al, bl, cl, dl, el, m[8], 0xa953fd4e, 14);
                            cl = rotl(cl, 10);
                            el = fn5(el, al, bl, cl, dl, m[11], 0xa953fd4e, 11);
                            bl = rotl(bl, 10);
                            dl = fn5(dl, el, al, bl, cl, m[6], 0xa953fd4e, 8);
                            al = rotl(al, 10);
                            cl = fn5(cl, dl, el, al, bl, m[15], 0xa953fd4e, 5);
                            el = rotl(el, 10);
                            bl = fn5(bl, cl, dl, el, al, m[13], 0xa953fd4e, 6);
                            dl = rotl(dl, 10);

                            var ar = this._a;
                            var br = this._b;
                            var cr = this._c;
                            var dr = this._d;
                            var er = this._e;

                            // M'j = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
                            // K' = 0x50a28be6
                            // S'j = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
                            ar = fn5(ar, br, cr, dr, er, m[5], 0x50a28be6, 8);
                            cr = rotl(cr, 10);
                            er = fn5(er, ar, br, cr, dr, m[14], 0x50a28be6, 9);
                            br = rotl(br, 10);
                            dr = fn5(dr, er, ar, br, cr, m[7], 0x50a28be6, 9);
                            ar = rotl(ar, 10);
                            cr = fn5(cr, dr, er, ar, br, m[0], 0x50a28be6, 11);
                            er = rotl(er, 10);
                            br = fn5(br, cr, dr, er, ar, m[9], 0x50a28be6, 13);
                            dr = rotl(dr, 10);
                            ar = fn5(ar, br, cr, dr, er, m[2], 0x50a28be6, 15);
                            cr = rotl(cr, 10);
                            er = fn5(er, ar, br, cr, dr, m[11], 0x50a28be6, 15);
                            br = rotl(br, 10);
                            dr = fn5(dr, er, ar, br, cr, m[4], 0x50a28be6, 5);
                            ar = rotl(ar, 10);
                            cr = fn5(cr, dr, er, ar, br, m[13], 0x50a28be6, 7);
                            er = rotl(er, 10);
                            br = fn5(br, cr, dr, er, ar, m[6], 0x50a28be6, 7);
                            dr = rotl(dr, 10);
                            ar = fn5(ar, br, cr, dr, er, m[15], 0x50a28be6, 8);
                            cr = rotl(cr, 10);
                            er = fn5(er, ar, br, cr, dr, m[8], 0x50a28be6, 11);
                            br = rotl(br, 10);
                            dr = fn5(dr, er, ar, br, cr, m[1], 0x50a28be6, 14);
                            ar = rotl(ar, 10);
                            cr = fn5(cr, dr, er, ar, br, m[10], 0x50a28be6, 14);
                            er = rotl(er, 10);
                            br = fn5(br, cr, dr, er, ar, m[3], 0x50a28be6, 12);
                            dr = rotl(dr, 10);
                            ar = fn5(ar, br, cr, dr, er, m[12], 0x50a28be6, 6);
                            cr = rotl(cr, 10);

                            // M'j = 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
                            // K' = 0x5c4dd124
                            // S'j = 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
                            er = fn4(er, ar, br, cr, dr, m[6], 0x5c4dd124, 9);
                            br = rotl(br, 10);
                            dr = fn4(dr, er, ar, br, cr, m[11], 0x5c4dd124, 13);
                            ar = rotl(ar, 10);
                            cr = fn4(cr, dr, er, ar, br, m[3], 0x5c4dd124, 15);
                            er = rotl(er, 10);
                            br = fn4(br, cr, dr, er, ar, m[7], 0x5c4dd124, 7);
                            dr = rotl(dr, 10);
                            ar = fn4(ar, br, cr, dr, er, m[0], 0x5c4dd124, 12);
                            cr = rotl(cr, 10);
                            er = fn4(er, ar, br, cr, dr, m[13], 0x5c4dd124, 8);
                            br = rotl(br, 10);
                            dr = fn4(dr, er, ar, br, cr, m[5], 0x5c4dd124, 9);
                            ar = rotl(ar, 10);
                            cr = fn4(cr, dr, er, ar, br, m[10], 0x5c4dd124, 11);
                            er = rotl(er, 10);
                            br = fn4(br, cr, dr, er, ar, m[14], 0x5c4dd124, 7);
                            dr = rotl(dr, 10);
                            ar = fn4(ar, br, cr, dr, er, m[15], 0x5c4dd124, 7);
                            cr = rotl(cr, 10);
                            er = fn4(er, ar, br, cr, dr, m[8], 0x5c4dd124, 12);
                            br = rotl(br, 10);
                            dr = fn4(dr, er, ar, br, cr, m[12], 0x5c4dd124, 7);
                            ar = rotl(ar, 10);
                            cr = fn4(cr, dr, er, ar, br, m[4], 0x5c4dd124, 6);
                            er = rotl(er, 10);
                            br = fn4(br, cr, dr, er, ar, m[9], 0x5c4dd124, 15);
                            dr = rotl(dr, 10);
                            ar = fn4(ar, br, cr, dr, er, m[1], 0x5c4dd124, 13);
                            cr = rotl(cr, 10);
                            er = fn4(er, ar, br, cr, dr, m[2], 0x5c4dd124, 11);
                            br = rotl(br, 10);

                            // M'j = 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
                            // K' = 0x6d703ef3
                            // S'j = 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
                            dr = fn3(dr, er, ar, br, cr, m[15], 0x6d703ef3, 9);
                            ar = rotl(ar, 10);
                            cr = fn3(cr, dr, er, ar, br, m[5], 0x6d703ef3, 7);
                            er = rotl(er, 10);
                            br = fn3(br, cr, dr, er, ar, m[1], 0x6d703ef3, 15);
                            dr = rotl(dr, 10);
                            ar = fn3(ar, br, cr, dr, er, m[3], 0x6d703ef3, 11);
                            cr = rotl(cr, 10);
                            er = fn3(er, ar, br, cr, dr, m[7], 0x6d703ef3, 8);
                            br = rotl(br, 10);
                            dr = fn3(dr, er, ar, br, cr, m[14], 0x6d703ef3, 6);
                            ar = rotl(ar, 10);
                            cr = fn3(cr, dr, er, ar, br, m[6], 0x6d703ef3, 6);
                            er = rotl(er, 10);
                            br = fn3(br, cr, dr, er, ar, m[9], 0x6d703ef3, 14);
                            dr = rotl(dr, 10);
                            ar = fn3(ar, br, cr, dr, er, m[11], 0x6d703ef3, 12);
                            cr = rotl(cr, 10);
                            er = fn3(er, ar, br, cr, dr, m[8], 0x6d703ef3, 13);
                            br = rotl(br, 10);
                            dr = fn3(dr, er, ar, br, cr, m[12], 0x6d703ef3, 5);
                            ar = rotl(ar, 10);
                            cr = fn3(cr, dr, er, ar, br, m[2], 0x6d703ef3, 14);
                            er = rotl(er, 10);
                            br = fn3(br, cr, dr, er, ar, m[10], 0x6d703ef3, 13);
                            dr = rotl(dr, 10);
                            ar = fn3(ar, br, cr, dr, er, m[0], 0x6d703ef3, 13);
                            cr = rotl(cr, 10);
                            er = fn3(er, ar, br, cr, dr, m[4], 0x6d703ef3, 7);
                            br = rotl(br, 10);
                            dr = fn3(dr, er, ar, br, cr, m[13], 0x6d703ef3, 5);
                            ar = rotl(ar, 10);

                            // M'j = 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
                            // K' = 0x7a6d76e9
                            // S'j = 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
                            cr = fn2(cr, dr, er, ar, br, m[8], 0x7a6d76e9, 15);
                            er = rotl(er, 10);
                            br = fn2(br, cr, dr, er, ar, m[6], 0x7a6d76e9, 5);
                            dr = rotl(dr, 10);
                            ar = fn2(ar, br, cr, dr, er, m[4], 0x7a6d76e9, 8);
                            cr = rotl(cr, 10);
                            er = fn2(er, ar, br, cr, dr, m[1], 0x7a6d76e9, 11);
                            br = rotl(br, 10);
                            dr = fn2(dr, er, ar, br, cr, m[3], 0x7a6d76e9, 14);
                            ar = rotl(ar, 10);
                            cr = fn2(cr, dr, er, ar, br, m[11], 0x7a6d76e9, 14);
                            er = rotl(er, 10);
                            br = fn2(br, cr, dr, er, ar, m[15], 0x7a6d76e9, 6);
                            dr = rotl(dr, 10);
                            ar = fn2(ar, br, cr, dr, er, m[0], 0x7a6d76e9, 14);
                            cr = rotl(cr, 10);
                            er = fn2(er, ar, br, cr, dr, m[5], 0x7a6d76e9, 6);
                            br = rotl(br, 10);
                            dr = fn2(dr, er, ar, br, cr, m[12], 0x7a6d76e9, 9);
                            ar = rotl(ar, 10);
                            cr = fn2(cr, dr, er, ar, br, m[2], 0x7a6d76e9, 12);
                            er = rotl(er, 10);
                            br = fn2(br, cr, dr, er, ar, m[13], 0x7a6d76e9, 9);
                            dr = rotl(dr, 10);
                            ar = fn2(ar, br, cr, dr, er, m[9], 0x7a6d76e9, 12);
                            cr = rotl(cr, 10);
                            er = fn2(er, ar, br, cr, dr, m[7], 0x7a6d76e9, 5);
                            br = rotl(br, 10);
                            dr = fn2(dr, er, ar, br, cr, m[10], 0x7a6d76e9, 15);
                            ar = rotl(ar, 10);
                            cr = fn2(cr, dr, er, ar, br, m[14], 0x7a6d76e9, 8);
                            er = rotl(er, 10);

                            // M'j = 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
                            // K' = 0x00000000
                            // S'j = 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
                            br = fn1(br, cr, dr, er, ar, m[12], 0x00000000, 8);
                            dr = rotl(dr, 10);
                            ar = fn1(ar, br, cr, dr, er, m[15], 0x00000000, 5);
                            cr = rotl(cr, 10);
                            er = fn1(er, ar, br, cr, dr, m[10], 0x00000000, 12);
                            br = rotl(br, 10);
                            dr = fn1(dr, er, ar, br, cr, m[4], 0x00000000, 9);
                            ar = rotl(ar, 10);
                            cr = fn1(cr, dr, er, ar, br, m[1], 0x00000000, 12);
                            er = rotl(er, 10);
                            br = fn1(br, cr, dr, er, ar, m[5], 0x00000000, 5);
                            dr = rotl(dr, 10);
                            ar = fn1(ar, br, cr, dr, er, m[8], 0x00000000, 14);
                            cr = rotl(cr, 10);
                            er = fn1(er, ar, br, cr, dr, m[7], 0x00000000, 6);
                            br = rotl(br, 10);
                            dr = fn1(dr, er, ar, br, cr, m[6], 0x00000000, 8);
                            ar = rotl(ar, 10);
                            cr = fn1(cr, dr, er, ar, br, m[2], 0x00000000, 13);
                            er = rotl(er, 10);
                            br = fn1(br, cr, dr, er, ar, m[13], 0x00000000, 6);
                            dr = rotl(dr, 10);
                            ar = fn1(ar, br, cr, dr, er, m[14], 0x00000000, 5);
                            cr = rotl(cr, 10);
                            er = fn1(er, ar, br, cr, dr, m[0], 0x00000000, 15);
                            br = rotl(br, 10);
                            dr = fn1(dr, er, ar, br, cr, m[3], 0x00000000, 13);
                            ar = rotl(ar, 10);
                            cr = fn1(cr, dr, er, ar, br, m[9], 0x00000000, 11);
                            er = rotl(er, 10);
                            br = fn1(br, cr, dr, er, ar, m[11], 0x00000000, 11);
                            dr = rotl(dr, 10);

                            // change state
                            var t = (this._b + cl + dr) | 0;
                            this._b = (this._c + dl + er) | 0;
                            this._c = (this._d + el + ar) | 0;
                            this._d = (this._e + al + br) | 0;
                            this._e = (this._a + bl + cr) | 0;
                            this._a = t;
                        };

                        RIPEMD160.prototype._digest = function() {
                            // create padding and handle blocks
                            this._block[this._blockOffset++] = 0x80;
                            if (this._blockOffset > 56) {
                                this._block.fill(0, this._blockOffset, 64);
                                this._update();
                                this._blockOffset = 0;
                            }

                            this._block.fill(0, this._blockOffset, 56);
                            this._block.writeUInt32LE(this._length[0], 56);
                            this._block.writeUInt32LE(this._length[1], 60);
                            this._update();

                            // produce result
                            var buffer = new Buffer(20);
                            buffer.writeInt32LE(this._a, 0);
                            buffer.writeInt32LE(this._b, 4);
                            buffer.writeInt32LE(this._c, 8);
                            buffer.writeInt32LE(this._d, 12);
                            buffer.writeInt32LE(this._e, 16);
                            return buffer;
                        };

                        function rotl(x, n) {
                            return (x << n) | (x >>> (32 - n));
                        }

                        function fn1(a, b, c, d, e, m, k, s) {
                            return (
                                (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
                            );
                        }

                        function fn2(a, b, c, d, e, m, k, s) {
                            return (
                                (rotl(
                                    (a + ((b & c) | (~b & d)) + m + k) | 0,
                                    s
                                ) +
                                    e) |
                                0
                            );
                        }

                        function fn3(a, b, c, d, e, m, k, s) {
                            return (
                                (rotl((a + ((b | ~c) ^ d) + m + k) | 0, s) +
                                    e) |
                                0
                            );
                        }

                        function fn4(a, b, c, d, e, m, k, s) {
                            return (
                                (rotl(
                                    (a + ((b & d) | (c & ~d)) + m + k) | 0,
                                    s
                                ) +
                                    e) |
                                0
                            );
                        }

                        function fn5(a, b, c, d, e, m, k, s) {
                            return (
                                (rotl((a + (b ^ (c | ~d)) + m + k) | 0, s) +
                                    e) |
                                0
                            );
                        }

                        module.exports = RIPEMD160;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "hash-base":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/hash-base/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/safe-buffer/browser.js": [
                function(require, module, exports) {
                    module.exports = require("buffer");
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/secure-random/lib/secure-random.js": [
                function(require, module, exports) {
                    (function(process, Buffer) {
                        !(function(globals) {
                            "use strict";

                            //*** UMD BEGIN
                            if (typeof define !== "undefined" && define.amd) {
                                //require.js / AMD
                                define([], function() {
                                    return secureRandom;
                                });
                            } else if (
                                typeof module !== "undefined" &&
                                module.exports
                            ) {
                                //CommonJS
                                module.exports = secureRandom;
                            } else {
                                //script / browser
                                globals.secureRandom = secureRandom;
                            }
                            //*** UMD END

                            //options.type is the only valid option
                            function secureRandom(count, options) {
                                options = options || {type: "Array"};
                                //we check for process.pid to prevent browserify from tricking us
                                if (
                                    typeof process != "undefined" &&
                                    typeof process.pid == "number"
                                ) {
                                    return nodeRandom(count, options);
                                } else {
                                    var crypto =
                                        window.crypto || window.msCrypto;
                                    if (!crypto)
                                        throw new Error(
                                            "Your browser does not support window.crypto."
                                        );
                                    return browserRandom(count, options);
                                }
                            }

                            function nodeRandom(count, options) {
                                var crypto = require("crypto");
                                var buf = crypto.randomBytes(count);

                                switch (options.type) {
                                    case "Array":
                                        return [].slice.call(buf);
                                    case "Buffer":
                                        return buf;
                                    case "Uint8Array":
                                        var arr = new Uint8Array(count);
                                        for (var i = 0; i < count; ++i) {
                                            arr[i] = buf.readUInt8(i);
                                        }
                                        return arr;
                                    default:
                                        throw new Error(
                                            options.type + " is unsupported."
                                        );
                                }
                            }

                            function browserRandom(count, options) {
                                var nativeArr = new Uint8Array(count);
                                var crypto = window.crypto || window.msCrypto;
                                crypto.getRandomValues(nativeArr);

                                switch (options.type) {
                                    case "Array":
                                        return [].slice.call(nativeArr);
                                    case "Buffer":
                                        try {
                                            var b = new Buffer(1);
                                        } catch (e) {
                                            throw new Error(
                                                "Buffer not supported in this environment. Use Node.js or Browserify for browser support."
                                            );
                                        }
                                        return new Buffer(nativeArr);
                                    case "Uint8Array":
                                        return nativeArr;
                                    default:
                                        throw new Error(
                                            options.type + " is unsupported."
                                        );
                                }
                            }

                            secureRandom.randomArray = function(byteCount) {
                                return secureRandom(byteCount, {type: "Array"});
                            };

                            secureRandom.randomUint8Array = function(
                                byteCount
                            ) {
                                return secureRandom(byteCount, {
                                    type: "Uint8Array"
                                });
                            };

                            secureRandom.randomBuffer = function(byteCount) {
                                return secureRandom(byteCount, {
                                    type: "Buffer"
                                });
                            };
                        })(this);
                    }.call(
                        this,
                        require("_process"),
                        require("buffer").Buffer
                    ));
                },
                {
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    crypto:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/browser-resolve/empty.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        // prototype class for hash functions
                        function Hash(blockSize, finalSize) {
                            this._block = new Buffer(blockSize);
                            this._finalSize = finalSize;
                            this._blockSize = blockSize;
                            this._len = 0;
                            this._s = 0;
                        }

                        Hash.prototype.update = function(data, enc) {
                            if (typeof data === "string") {
                                enc = enc || "utf8";
                                data = new Buffer(data, enc);
                            }

                            var l = (this._len += data.length);
                            var s = this._s || 0;
                            var f = 0;
                            var buffer = this._block;

                            while (s < l) {
                                var t = Math.min(
                                    data.length,
                                    f + this._blockSize - s % this._blockSize
                                );
                                var ch = t - f;

                                for (var i = 0; i < ch; i++) {
                                    buffer[s % this._blockSize + i] =
                                        data[i + f];
                                }

                                s += ch;
                                f += ch;

                                if (s % this._blockSize === 0) {
                                    this._update(buffer);
                                }
                            }
                            this._s = s;

                            return this;
                        };

                        Hash.prototype.digest = function(enc) {
                            // Suppose the length of the message M, in bits, is l
                            var l = this._len * 8;

                            // Append the bit 1 to the end of the message
                            this._block[this._len % this._blockSize] = 0x80;

                            // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
                            this._block.fill(
                                0,
                                this._len % this._blockSize + 1
                            );

                            if (
                                l % (this._blockSize * 8) >=
                                this._finalSize * 8
                            ) {
                                this._update(this._block);
                                this._block.fill(0);
                            }

                            // to this append the block which is equal to the number l written in binary
                            // TODO: handle case where l is > Math.pow(2, 29)
                            this._block.writeInt32BE(l, this._blockSize - 4);

                            var hash =
                                this._update(this._block) || this._hash();

                            return enc ? hash.toString(enc) : hash;
                        };

                        Hash.prototype._update = function() {
                            throw new Error(
                                "_update must be implemented by subclass"
                            );
                        };

                        module.exports = Hash;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/index.js": [
                function(require, module, exports) {
                    var exports = (module.exports = function SHA(algorithm) {
                        algorithm = algorithm.toLowerCase();

                        var Algorithm = exports[algorithm];
                        if (!Algorithm)
                            throw new Error(
                                algorithm +
                                    " is not supported (we accept pull requests)"
                            );

                        return new Algorithm();
                    });

                    exports.sha = require("./sha");
                    exports.sha1 = require("./sha1");
                    exports.sha224 = require("./sha224");
                    exports.sha256 = require("./sha256");
                    exports.sha384 = require("./sha384");
                    exports.sha512 = require("./sha512");
                },
                {
                    "./sha":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha.js",
                    "./sha1":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha1.js",
                    "./sha224":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha224.js",
                    "./sha256":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha256.js",
                    "./sha384":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha384.js",
                    "./sha512":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha512.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

                        var inherits = require("inherits");
                        var Hash = require("./hash");

                        var K = [
                            0x5a827999,
                            0x6ed9eba1,
                            0x8f1bbcdc | 0,
                            0xca62c1d6 | 0
                        ];

                        var W = new Array(80);

                        function Sha() {
                            this.init();
                            this._w = W;

                            Hash.call(this, 64, 56);
                        }

                        inherits(Sha, Hash);

                        Sha.prototype.init = function() {
                            this._a = 0x67452301;
                            this._b = 0xefcdab89;
                            this._c = 0x98badcfe;
                            this._d = 0x10325476;
                            this._e = 0xc3d2e1f0;

                            return this;
                        };

                        function rotl5(num) {
                            return (num << 5) | (num >>> 27);
                        }

                        function rotl30(num) {
                            return (num << 30) | (num >>> 2);
                        }

                        function ft(s, b, c, d) {
                            if (s === 0) return (b & c) | (~b & d);
                            if (s === 2) return (b & c) | (b & d) | (c & d);
                            return b ^ c ^ d;
                        }

                        Sha.prototype._update = function(M) {
                            var W = this._w;

                            var a = this._a | 0;
                            var b = this._b | 0;
                            var c = this._c | 0;
                            var d = this._d | 0;
                            var e = this._e | 0;

                            for (var i = 0; i < 16; ++i)
                                W[i] = M.readInt32BE(i * 4);
                            for (; i < 80; ++i)
                                W[i] =
                                    W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

                            for (var j = 0; j < 80; ++j) {
                                var s = ~~(j / 20);
                                var t =
                                    (rotl5(a) +
                                        ft(s, b, c, d) +
                                        e +
                                        W[j] +
                                        K[s]) |
                                    0;

                                e = d;
                                d = c;
                                c = rotl30(b);
                                b = a;
                                a = t;
                            }

                            this._a = (a + this._a) | 0;
                            this._b = (b + this._b) | 0;
                            this._c = (c + this._c) | 0;
                            this._d = (d + this._d) | 0;
                            this._e = (e + this._e) | 0;
                        };

                        Sha.prototype._hash = function() {
                            var H = new Buffer(20);

                            H.writeInt32BE(this._a | 0, 0);
                            H.writeInt32BE(this._b | 0, 4);
                            H.writeInt32BE(this._c | 0, 8);
                            H.writeInt32BE(this._d | 0, 12);
                            H.writeInt32BE(this._e | 0, 16);

                            return H;
                        };

                        module.exports = Sha;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha1.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

                        var inherits = require("inherits");
                        var Hash = require("./hash");

                        var K = [
                            0x5a827999,
                            0x6ed9eba1,
                            0x8f1bbcdc | 0,
                            0xca62c1d6 | 0
                        ];

                        var W = new Array(80);

                        function Sha1() {
                            this.init();
                            this._w = W;

                            Hash.call(this, 64, 56);
                        }

                        inherits(Sha1, Hash);

                        Sha1.prototype.init = function() {
                            this._a = 0x67452301;
                            this._b = 0xefcdab89;
                            this._c = 0x98badcfe;
                            this._d = 0x10325476;
                            this._e = 0xc3d2e1f0;

                            return this;
                        };

                        function rotl1(num) {
                            return (num << 1) | (num >>> 31);
                        }

                        function rotl5(num) {
                            return (num << 5) | (num >>> 27);
                        }

                        function rotl30(num) {
                            return (num << 30) | (num >>> 2);
                        }

                        function ft(s, b, c, d) {
                            if (s === 0) return (b & c) | (~b & d);
                            if (s === 2) return (b & c) | (b & d) | (c & d);
                            return b ^ c ^ d;
                        }

                        Sha1.prototype._update = function(M) {
                            var W = this._w;

                            var a = this._a | 0;
                            var b = this._b | 0;
                            var c = this._c | 0;
                            var d = this._d | 0;
                            var e = this._e | 0;

                            for (var i = 0; i < 16; ++i)
                                W[i] = M.readInt32BE(i * 4);
                            for (; i < 80; ++i)
                                W[i] = rotl1(
                                    W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]
                                );

                            for (var j = 0; j < 80; ++j) {
                                var s = ~~(j / 20);
                                var t =
                                    (rotl5(a) +
                                        ft(s, b, c, d) +
                                        e +
                                        W[j] +
                                        K[s]) |
                                    0;

                                e = d;
                                d = c;
                                c = rotl30(b);
                                b = a;
                                a = t;
                            }

                            this._a = (a + this._a) | 0;
                            this._b = (b + this._b) | 0;
                            this._c = (c + this._c) | 0;
                            this._d = (d + this._d) | 0;
                            this._e = (e + this._e) | 0;
                        };

                        Sha1.prototype._hash = function() {
                            var H = new Buffer(20);

                            H.writeInt32BE(this._a | 0, 0);
                            H.writeInt32BE(this._b | 0, 4);
                            H.writeInt32BE(this._c | 0, 8);
                            H.writeInt32BE(this._d | 0, 12);
                            H.writeInt32BE(this._e | 0, 16);

                            return H;
                        };

                        module.exports = Sha1;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha224.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        /**
                         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
                         * in FIPS 180-2
                         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
                         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                         *
                         */

                        var inherits = require("inherits");
                        var Sha256 = require("./sha256");
                        var Hash = require("./hash");

                        var W = new Array(64);

                        function Sha224() {
                            this.init();

                            this._w = W; // new Array(64)

                            Hash.call(this, 64, 56);
                        }

                        inherits(Sha224, Sha256);

                        Sha224.prototype.init = function() {
                            this._a = 0xc1059ed8;
                            this._b = 0x367cd507;
                            this._c = 0x3070dd17;
                            this._d = 0xf70e5939;
                            this._e = 0xffc00b31;
                            this._f = 0x68581511;
                            this._g = 0x64f98fa7;
                            this._h = 0xbefa4fa4;

                            return this;
                        };

                        Sha224.prototype._hash = function() {
                            var H = new Buffer(28);

                            H.writeInt32BE(this._a, 0);
                            H.writeInt32BE(this._b, 4);
                            H.writeInt32BE(this._c, 8);
                            H.writeInt32BE(this._d, 12);
                            H.writeInt32BE(this._e, 16);
                            H.writeInt32BE(this._f, 20);
                            H.writeInt32BE(this._g, 24);

                            return H;
                        };

                        module.exports = Sha224;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    "./sha256":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha256.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha256.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        /**
                         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
                         * in FIPS 180-2
                         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
                         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
                         *
                         */

                        var inherits = require("inherits");
                        var Hash = require("./hash");

                        var K = [
                            0x428a2f98,
                            0x71374491,
                            0xb5c0fbcf,
                            0xe9b5dba5,
                            0x3956c25b,
                            0x59f111f1,
                            0x923f82a4,
                            0xab1c5ed5,
                            0xd807aa98,
                            0x12835b01,
                            0x243185be,
                            0x550c7dc3,
                            0x72be5d74,
                            0x80deb1fe,
                            0x9bdc06a7,
                            0xc19bf174,
                            0xe49b69c1,
                            0xefbe4786,
                            0x0fc19dc6,
                            0x240ca1cc,
                            0x2de92c6f,
                            0x4a7484aa,
                            0x5cb0a9dc,
                            0x76f988da,
                            0x983e5152,
                            0xa831c66d,
                            0xb00327c8,
                            0xbf597fc7,
                            0xc6e00bf3,
                            0xd5a79147,
                            0x06ca6351,
                            0x14292967,
                            0x27b70a85,
                            0x2e1b2138,
                            0x4d2c6dfc,
                            0x53380d13,
                            0x650a7354,
                            0x766a0abb,
                            0x81c2c92e,
                            0x92722c85,
                            0xa2bfe8a1,
                            0xa81a664b,
                            0xc24b8b70,
                            0xc76c51a3,
                            0xd192e819,
                            0xd6990624,
                            0xf40e3585,
                            0x106aa070,
                            0x19a4c116,
                            0x1e376c08,
                            0x2748774c,
                            0x34b0bcb5,
                            0x391c0cb3,
                            0x4ed8aa4a,
                            0x5b9cca4f,
                            0x682e6ff3,
                            0x748f82ee,
                            0x78a5636f,
                            0x84c87814,
                            0x8cc70208,
                            0x90befffa,
                            0xa4506ceb,
                            0xbef9a3f7,
                            0xc67178f2
                        ];

                        var W = new Array(64);

                        function Sha256() {
                            this.init();

                            this._w = W; // new Array(64)

                            Hash.call(this, 64, 56);
                        }

                        inherits(Sha256, Hash);

                        Sha256.prototype.init = function() {
                            this._a = 0x6a09e667;
                            this._b = 0xbb67ae85;
                            this._c = 0x3c6ef372;
                            this._d = 0xa54ff53a;
                            this._e = 0x510e527f;
                            this._f = 0x9b05688c;
                            this._g = 0x1f83d9ab;
                            this._h = 0x5be0cd19;

                            return this;
                        };

                        function ch(x, y, z) {
                            return z ^ (x & (y ^ z));
                        }

                        function maj(x, y, z) {
                            return (x & y) | (z & (x | y));
                        }

                        function sigma0(x) {
                            return (
                                ((x >>> 2) | (x << 30)) ^
                                ((x >>> 13) | (x << 19)) ^
                                ((x >>> 22) | (x << 10))
                            );
                        }

                        function sigma1(x) {
                            return (
                                ((x >>> 6) | (x << 26)) ^
                                ((x >>> 11) | (x << 21)) ^
                                ((x >>> 25) | (x << 7))
                            );
                        }

                        function gamma0(x) {
                            return (
                                ((x >>> 7) | (x << 25)) ^
                                ((x >>> 18) | (x << 14)) ^
                                (x >>> 3)
                            );
                        }

                        function gamma1(x) {
                            return (
                                ((x >>> 17) | (x << 15)) ^
                                ((x >>> 19) | (x << 13)) ^
                                (x >>> 10)
                            );
                        }

                        Sha256.prototype._update = function(M) {
                            var W = this._w;

                            var a = this._a | 0;
                            var b = this._b | 0;
                            var c = this._c | 0;
                            var d = this._d | 0;
                            var e = this._e | 0;
                            var f = this._f | 0;
                            var g = this._g | 0;
                            var h = this._h | 0;

                            for (var i = 0; i < 16; ++i)
                                W[i] = M.readInt32BE(i * 4);
                            for (; i < 64; ++i)
                                W[i] =
                                    (gamma1(W[i - 2]) +
                                        W[i - 7] +
                                        gamma0(W[i - 15]) +
                                        W[i - 16]) |
                                    0;

                            for (var j = 0; j < 64; ++j) {
                                var T1 =
                                    (h +
                                        sigma1(e) +
                                        ch(e, f, g) +
                                        K[j] +
                                        W[j]) |
                                    0;
                                var T2 = (sigma0(a) + maj(a, b, c)) | 0;

                                h = g;
                                g = f;
                                f = e;
                                e = (d + T1) | 0;
                                d = c;
                                c = b;
                                b = a;
                                a = (T1 + T2) | 0;
                            }

                            this._a = (a + this._a) | 0;
                            this._b = (b + this._b) | 0;
                            this._c = (c + this._c) | 0;
                            this._d = (d + this._d) | 0;
                            this._e = (e + this._e) | 0;
                            this._f = (f + this._f) | 0;
                            this._g = (g + this._g) | 0;
                            this._h = (h + this._h) | 0;
                        };

                        Sha256.prototype._hash = function() {
                            var H = new Buffer(32);

                            H.writeInt32BE(this._a, 0);
                            H.writeInt32BE(this._b, 4);
                            H.writeInt32BE(this._c, 8);
                            H.writeInt32BE(this._d, 12);
                            H.writeInt32BE(this._e, 16);
                            H.writeInt32BE(this._f, 20);
                            H.writeInt32BE(this._g, 24);
                            H.writeInt32BE(this._h, 28);

                            return H;
                        };

                        module.exports = Sha256;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha384.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        var inherits = require("inherits");
                        var SHA512 = require("./sha512");
                        var Hash = require("./hash");

                        var W = new Array(160);

                        function Sha384() {
                            this.init();
                            this._w = W;

                            Hash.call(this, 128, 112);
                        }

                        inherits(Sha384, SHA512);

                        Sha384.prototype.init = function() {
                            this._ah = 0xcbbb9d5d;
                            this._bh = 0x629a292a;
                            this._ch = 0x9159015a;
                            this._dh = 0x152fecd8;
                            this._eh = 0x67332667;
                            this._fh = 0x8eb44a87;
                            this._gh = 0xdb0c2e0d;
                            this._hh = 0x47b5481d;

                            this._al = 0xc1059ed8;
                            this._bl = 0x367cd507;
                            this._cl = 0x3070dd17;
                            this._dl = 0xf70e5939;
                            this._el = 0xffc00b31;
                            this._fl = 0x68581511;
                            this._gl = 0x64f98fa7;
                            this._hl = 0xbefa4fa4;

                            return this;
                        };

                        Sha384.prototype._hash = function() {
                            var H = new Buffer(48);

                            function writeInt64BE(h, l, offset) {
                                H.writeInt32BE(h, offset);
                                H.writeInt32BE(l, offset + 4);
                            }

                            writeInt64BE(this._ah, this._al, 0);
                            writeInt64BE(this._bh, this._bl, 8);
                            writeInt64BE(this._ch, this._cl, 16);
                            writeInt64BE(this._dh, this._dl, 24);
                            writeInt64BE(this._eh, this._el, 32);
                            writeInt64BE(this._fh, this._fl, 40);

                            return H;
                        };

                        module.exports = Sha384;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    "./sha512":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha512.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/sha512.js": [
                function(require, module, exports) {
                    (function(Buffer) {
                        var inherits = require("inherits");
                        var Hash = require("./hash");

                        var K = [
                            0x428a2f98,
                            0xd728ae22,
                            0x71374491,
                            0x23ef65cd,
                            0xb5c0fbcf,
                            0xec4d3b2f,
                            0xe9b5dba5,
                            0x8189dbbc,
                            0x3956c25b,
                            0xf348b538,
                            0x59f111f1,
                            0xb605d019,
                            0x923f82a4,
                            0xaf194f9b,
                            0xab1c5ed5,
                            0xda6d8118,
                            0xd807aa98,
                            0xa3030242,
                            0x12835b01,
                            0x45706fbe,
                            0x243185be,
                            0x4ee4b28c,
                            0x550c7dc3,
                            0xd5ffb4e2,
                            0x72be5d74,
                            0xf27b896f,
                            0x80deb1fe,
                            0x3b1696b1,
                            0x9bdc06a7,
                            0x25c71235,
                            0xc19bf174,
                            0xcf692694,
                            0xe49b69c1,
                            0x9ef14ad2,
                            0xefbe4786,
                            0x384f25e3,
                            0x0fc19dc6,
                            0x8b8cd5b5,
                            0x240ca1cc,
                            0x77ac9c65,
                            0x2de92c6f,
                            0x592b0275,
                            0x4a7484aa,
                            0x6ea6e483,
                            0x5cb0a9dc,
                            0xbd41fbd4,
                            0x76f988da,
                            0x831153b5,
                            0x983e5152,
                            0xee66dfab,
                            0xa831c66d,
                            0x2db43210,
                            0xb00327c8,
                            0x98fb213f,
                            0xbf597fc7,
                            0xbeef0ee4,
                            0xc6e00bf3,
                            0x3da88fc2,
                            0xd5a79147,
                            0x930aa725,
                            0x06ca6351,
                            0xe003826f,
                            0x14292967,
                            0x0a0e6e70,
                            0x27b70a85,
                            0x46d22ffc,
                            0x2e1b2138,
                            0x5c26c926,
                            0x4d2c6dfc,
                            0x5ac42aed,
                            0x53380d13,
                            0x9d95b3df,
                            0x650a7354,
                            0x8baf63de,
                            0x766a0abb,
                            0x3c77b2a8,
                            0x81c2c92e,
                            0x47edaee6,
                            0x92722c85,
                            0x1482353b,
                            0xa2bfe8a1,
                            0x4cf10364,
                            0xa81a664b,
                            0xbc423001,
                            0xc24b8b70,
                            0xd0f89791,
                            0xc76c51a3,
                            0x0654be30,
                            0xd192e819,
                            0xd6ef5218,
                            0xd6990624,
                            0x5565a910,
                            0xf40e3585,
                            0x5771202a,
                            0x106aa070,
                            0x32bbd1b8,
                            0x19a4c116,
                            0xb8d2d0c8,
                            0x1e376c08,
                            0x5141ab53,
                            0x2748774c,
                            0xdf8eeb99,
                            0x34b0bcb5,
                            0xe19b48a8,
                            0x391c0cb3,
                            0xc5c95a63,
                            0x4ed8aa4a,
                            0xe3418acb,
                            0x5b9cca4f,
                            0x7763e373,
                            0x682e6ff3,
                            0xd6b2b8a3,
                            0x748f82ee,
                            0x5defb2fc,
                            0x78a5636f,
                            0x43172f60,
                            0x84c87814,
                            0xa1f0ab72,
                            0x8cc70208,
                            0x1a6439ec,
                            0x90befffa,
                            0x23631e28,
                            0xa4506ceb,
                            0xde82bde9,
                            0xbef9a3f7,
                            0xb2c67915,
                            0xc67178f2,
                            0xe372532b,
                            0xca273ece,
                            0xea26619c,
                            0xd186b8c7,
                            0x21c0c207,
                            0xeada7dd6,
                            0xcde0eb1e,
                            0xf57d4f7f,
                            0xee6ed178,
                            0x06f067aa,
                            0x72176fba,
                            0x0a637dc5,
                            0xa2c898a6,
                            0x113f9804,
                            0xbef90dae,
                            0x1b710b35,
                            0x131c471b,
                            0x28db77f5,
                            0x23047d84,
                            0x32caab7b,
                            0x40c72493,
                            0x3c9ebe0a,
                            0x15c9bebc,
                            0x431d67c4,
                            0x9c100d4c,
                            0x4cc5d4be,
                            0xcb3e42b6,
                            0x597f299c,
                            0xfc657e2a,
                            0x5fcb6fab,
                            0x3ad6faec,
                            0x6c44198c,
                            0x4a475817
                        ];

                        var W = new Array(160);

                        function Sha512() {
                            this.init();
                            this._w = W;

                            Hash.call(this, 128, 112);
                        }

                        inherits(Sha512, Hash);

                        Sha512.prototype.init = function() {
                            this._ah = 0x6a09e667;
                            this._bh = 0xbb67ae85;
                            this._ch = 0x3c6ef372;
                            this._dh = 0xa54ff53a;
                            this._eh = 0x510e527f;
                            this._fh = 0x9b05688c;
                            this._gh = 0x1f83d9ab;
                            this._hh = 0x5be0cd19;

                            this._al = 0xf3bcc908;
                            this._bl = 0x84caa73b;
                            this._cl = 0xfe94f82b;
                            this._dl = 0x5f1d36f1;
                            this._el = 0xade682d1;
                            this._fl = 0x2b3e6c1f;
                            this._gl = 0xfb41bd6b;
                            this._hl = 0x137e2179;

                            return this;
                        };

                        function Ch(x, y, z) {
                            return z ^ (x & (y ^ z));
                        }

                        function maj(x, y, z) {
                            return (x & y) | (z & (x | y));
                        }

                        function sigma0(x, xl) {
                            return (
                                ((x >>> 28) | (xl << 4)) ^
                                ((xl >>> 2) | (x << 30)) ^
                                ((xl >>> 7) | (x << 25))
                            );
                        }

                        function sigma1(x, xl) {
                            return (
                                ((x >>> 14) | (xl << 18)) ^
                                ((x >>> 18) | (xl << 14)) ^
                                ((xl >>> 9) | (x << 23))
                            );
                        }

                        function Gamma0(x, xl) {
                            return (
                                ((x >>> 1) | (xl << 31)) ^
                                ((x >>> 8) | (xl << 24)) ^
                                (x >>> 7)
                            );
                        }

                        function Gamma0l(x, xl) {
                            return (
                                ((x >>> 1) | (xl << 31)) ^
                                ((x >>> 8) | (xl << 24)) ^
                                ((x >>> 7) | (xl << 25))
                            );
                        }

                        function Gamma1(x, xl) {
                            return (
                                ((x >>> 19) | (xl << 13)) ^
                                ((xl >>> 29) | (x << 3)) ^
                                (x >>> 6)
                            );
                        }

                        function Gamma1l(x, xl) {
                            return (
                                ((x >>> 19) | (xl << 13)) ^
                                ((xl >>> 29) | (x << 3)) ^
                                ((x >>> 6) | (xl << 26))
                            );
                        }

                        function getCarry(a, b) {
                            return a >>> 0 < b >>> 0 ? 1 : 0;
                        }

                        Sha512.prototype._update = function(M) {
                            var W = this._w;

                            var ah = this._ah | 0;
                            var bh = this._bh | 0;
                            var ch = this._ch | 0;
                            var dh = this._dh | 0;
                            var eh = this._eh | 0;
                            var fh = this._fh | 0;
                            var gh = this._gh | 0;
                            var hh = this._hh | 0;

                            var al = this._al | 0;
                            var bl = this._bl | 0;
                            var cl = this._cl | 0;
                            var dl = this._dl | 0;
                            var el = this._el | 0;
                            var fl = this._fl | 0;
                            var gl = this._gl | 0;
                            var hl = this._hl | 0;

                            for (var i = 0; i < 32; i += 2) {
                                W[i] = M.readInt32BE(i * 4);
                                W[i + 1] = M.readInt32BE(i * 4 + 4);
                            }
                            for (; i < 160; i += 2) {
                                var xh = W[i - 15 * 2];
                                var xl = W[i - 15 * 2 + 1];
                                var gamma0 = Gamma0(xh, xl);
                                var gamma0l = Gamma0l(xl, xh);

                                xh = W[i - 2 * 2];
                                xl = W[i - 2 * 2 + 1];
                                var gamma1 = Gamma1(xh, xl);
                                var gamma1l = Gamma1l(xl, xh);

                                // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                                var Wi7h = W[i - 7 * 2];
                                var Wi7l = W[i - 7 * 2 + 1];

                                var Wi16h = W[i - 16 * 2];
                                var Wi16l = W[i - 16 * 2 + 1];

                                var Wil = (gamma0l + Wi7l) | 0;
                                var Wih =
                                    (gamma0 + Wi7h + getCarry(Wil, gamma0l)) |
                                    0;
                                Wil = (Wil + gamma1l) | 0;
                                Wih =
                                    (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
                                Wil = (Wil + Wi16l) | 0;
                                Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

                                W[i] = Wih;
                                W[i + 1] = Wil;
                            }

                            for (var j = 0; j < 160; j += 2) {
                                Wih = W[j];
                                Wil = W[j + 1];

                                var majh = maj(ah, bh, ch);
                                var majl = maj(al, bl, cl);

                                var sigma0h = sigma0(ah, al);
                                var sigma0l = sigma0(al, ah);
                                var sigma1h = sigma1(eh, el);
                                var sigma1l = sigma1(el, eh);

                                // t1 = h + sigma1 + ch + K[j] + W[j]
                                var Kih = K[j];
                                var Kil = K[j + 1];

                                var chh = Ch(eh, fh, gh);
                                var chl = Ch(el, fl, gl);

                                var t1l = (hl + sigma1l) | 0;
                                var t1h =
                                    (hh + sigma1h + getCarry(t1l, hl)) | 0;
                                t1l = (t1l + chl) | 0;
                                t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
                                t1l = (t1l + Kil) | 0;
                                t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
                                t1l = (t1l + Wil) | 0;
                                t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

                                // t2 = sigma0 + maj
                                var t2l = (sigma0l + majl) | 0;
                                var t2h =
                                    (sigma0h + majh + getCarry(t2l, sigma0l)) |
                                    0;

                                hh = gh;
                                hl = gl;
                                gh = fh;
                                gl = fl;
                                fh = eh;
                                fl = el;
                                el = (dl + t1l) | 0;
                                eh = (dh + t1h + getCarry(el, dl)) | 0;
                                dh = ch;
                                dl = cl;
                                ch = bh;
                                cl = bl;
                                bh = ah;
                                bl = al;
                                al = (t1l + t2l) | 0;
                                ah = (t1h + t2h + getCarry(al, t1l)) | 0;
                            }

                            this._al = (this._al + al) | 0;
                            this._bl = (this._bl + bl) | 0;
                            this._cl = (this._cl + cl) | 0;
                            this._dl = (this._dl + dl) | 0;
                            this._el = (this._el + el) | 0;
                            this._fl = (this._fl + fl) | 0;
                            this._gl = (this._gl + gl) | 0;
                            this._hl = (this._hl + hl) | 0;

                            this._ah =
                                (this._ah + ah + getCarry(this._al, al)) | 0;
                            this._bh =
                                (this._bh + bh + getCarry(this._bl, bl)) | 0;
                            this._ch =
                                (this._ch + ch + getCarry(this._cl, cl)) | 0;
                            this._dh =
                                (this._dh + dh + getCarry(this._dl, dl)) | 0;
                            this._eh =
                                (this._eh + eh + getCarry(this._el, el)) | 0;
                            this._fh =
                                (this._fh + fh + getCarry(this._fl, fl)) | 0;
                            this._gh =
                                (this._gh + gh + getCarry(this._gl, gl)) | 0;
                            this._hh =
                                (this._hh + hh + getCarry(this._hl, hl)) | 0;
                        };

                        Sha512.prototype._hash = function() {
                            var H = new Buffer(64);

                            function writeInt64BE(h, l, offset) {
                                H.writeInt32BE(h, offset);
                                H.writeInt32BE(l, offset + 4);
                            }

                            writeInt64BE(this._ah, this._al, 0);
                            writeInt64BE(this._bh, this._bl, 8);
                            writeInt64BE(this._ch, this._cl, 16);
                            writeInt64BE(this._dh, this._dl, 24);
                            writeInt64BE(this._eh, this._el, 32);
                            writeInt64BE(this._fh, this._fl, 40);
                            writeInt64BE(this._gh, this._gl, 48);
                            writeInt64BE(this._hh, this._hl, 56);

                            return H;
                        };

                        module.exports = Sha512;
                    }.call(this, require("buffer").Buffer));
                },
                {
                    "./hash":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/sha.js/hash.js",
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/stream-browserify/index.js": [
                function(require, module, exports) {
                    // Copyright Joyent, Inc. and other Node contributors.
                    //
                    // Permission is hereby granted, free of charge, to any person obtaining a
                    // copy of this software and associated documentation files (the
                    // "Software"), to deal in the Software without restriction, including
                    // without limitation the rights to use, copy, modify, merge, publish,
                    // distribute, sublicense, and/or sell copies of the Software, and to permit
                    // persons to whom the Software is furnished to do so, subject to the
                    // following conditions:
                    //
                    // The above copyright notice and this permission notice shall be included
                    // in all copies or substantial portions of the Software.
                    //
                    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                    // USE OR OTHER DEALINGS IN THE SOFTWARE.

                    module.exports = Stream;

                    var EE = require("events").EventEmitter;
                    var inherits = require("inherits");

                    inherits(Stream, EE);
                    Stream.Readable = require("readable-stream/readable.js");
                    Stream.Writable = require("readable-stream/writable.js");
                    Stream.Duplex = require("readable-stream/duplex.js");
                    Stream.Transform = require("readable-stream/transform.js");
                    Stream.PassThrough = require("readable-stream/passthrough.js");

                    // Backwards-compat with node 0.4.x
                    Stream.Stream = Stream;

                    // old-style streams.  Note that the pipe method (the only relevant
                    // part of this class) is overridden in the Readable class.

                    function Stream() {
                        EE.call(this);
                    }

                    Stream.prototype.pipe = function(dest, options) {
                        var source = this;

                        function ondata(chunk) {
                            if (dest.writable) {
                                if (
                                    false === dest.write(chunk) &&
                                    source.pause
                                ) {
                                    source.pause();
                                }
                            }
                        }

                        source.on("data", ondata);

                        function ondrain() {
                            if (source.readable && source.resume) {
                                source.resume();
                            }
                        }

                        dest.on("drain", ondrain);

                        // If the 'end' option is not supplied, dest.end() will be called when
                        // source gets the 'end' or 'close' events.  Only dest.end() once.
                        if (
                            !dest._isStdio &&
                            (!options || options.end !== false)
                        ) {
                            source.on("end", onend);
                            source.on("close", onclose);
                        }

                        var didOnEnd = false;
                        function onend() {
                            if (didOnEnd) return;
                            didOnEnd = true;

                            dest.end();
                        }

                        function onclose() {
                            if (didOnEnd) return;
                            didOnEnd = true;

                            if (typeof dest.destroy === "function")
                                dest.destroy();
                        }

                        // don't leave dangling pipes when there are errors.
                        function onerror(er) {
                            cleanup();
                            if (EE.listenerCount(this, "error") === 0) {
                                throw er; // Unhandled stream error in pipe.
                            }
                        }

                        source.on("error", onerror);
                        dest.on("error", onerror);

                        // remove all the event listeners that were added.
                        function cleanup() {
                            source.removeListener("data", ondata);
                            dest.removeListener("drain", ondrain);

                            source.removeListener("end", onend);
                            source.removeListener("close", onclose);

                            source.removeListener("error", onerror);
                            dest.removeListener("error", onerror);

                            source.removeListener("end", cleanup);
                            source.removeListener("close", cleanup);

                            dest.removeListener("close", cleanup);
                        }

                        source.on("end", cleanup);
                        source.on("close", cleanup);

                        dest.on("close", cleanup);

                        dest.emit("pipe", source);

                        // Allow for unix-like usage: A.pipe(B).pipe(C)
                        return dest;
                    };
                },
                {
                    events:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/events/events.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js",
                    "readable-stream/duplex.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/duplex-browser.js",
                    "readable-stream/passthrough.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/passthrough.js",
                    "readable-stream/readable.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/readable-browser.js",
                    "readable-stream/transform.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/transform.js",
                    "readable-stream/writable.js":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/readable-stream/writable-browser.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/string_decoder/lib/string_decoder.js": [
                function(require, module, exports) {
                    "use strict";

                    var Buffer = require("buffer").Buffer;
                    var bufferShim = require("buffer-shims");

                    var isEncoding =
                        Buffer.isEncoding ||
                        function(encoding) {
                            encoding = "" + encoding;
                            switch (encoding && encoding.toLowerCase()) {
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                case "raw":
                                    return true;
                                default:
                                    return false;
                            }
                        };

                    function _normalizeEncoding(enc) {
                        if (!enc) return "utf8";
                        var retried;
                        while (true) {
                            switch (enc) {
                                case "utf8":
                                case "utf-8":
                                    return "utf8";
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return "utf16le";
                                case "latin1":
                                case "binary":
                                    return "latin1";
                                case "base64":
                                case "ascii":
                                case "hex":
                                    return enc;
                                default:
                                    if (retried) return; // undefined
                                    enc = ("" + enc).toLowerCase();
                                    retried = true;
                            }
                        }
                    }

                    // Do not cache `Buffer.isEncoding` when checking encoding names as some
                    // modules monkey-patch it to support additional encodings
                    function normalizeEncoding(enc) {
                        var nenc = _normalizeEncoding(enc);
                        if (
                            typeof nenc !== "string" &&
                            (Buffer.isEncoding === isEncoding ||
                                !isEncoding(enc))
                        )
                            throw new Error("Unknown encoding: " + enc);
                        return nenc || enc;
                    }

                    // StringDecoder provides an interface for efficiently splitting a series of
                    // buffers into a series of JS strings without breaking apart multi-byte
                    // characters.
                    exports.StringDecoder = StringDecoder;
                    function StringDecoder(encoding) {
                        this.encoding = normalizeEncoding(encoding);
                        var nb;
                        switch (this.encoding) {
                            case "utf16le":
                                this.text = utf16Text;
                                this.end = utf16End;
                                nb = 4;
                                break;
                            case "utf8":
                                this.fillLast = utf8FillLast;
                                nb = 4;
                                break;
                            case "base64":
                                this.text = base64Text;
                                this.end = base64End;
                                nb = 3;
                                break;
                            default:
                                this.write = simpleWrite;
                                this.end = simpleEnd;
                                return;
                        }
                        this.lastNeed = 0;
                        this.lastTotal = 0;
                        this.lastChar = bufferShim.allocUnsafe(nb);
                    }

                    StringDecoder.prototype.write = function(buf) {
                        if (buf.length === 0) return "";
                        var r;
                        var i;
                        if (this.lastNeed) {
                            r = this.fillLast(buf);
                            if (r === undefined) return "";
                            i = this.lastNeed;
                            this.lastNeed = 0;
                        } else {
                            i = 0;
                        }
                        if (i < buf.length)
                            return r
                                ? r + this.text(buf, i)
                                : this.text(buf, i);
                        return r || "";
                    };

                    StringDecoder.prototype.end = utf8End;

                    // Returns only complete characters in a Buffer
                    StringDecoder.prototype.text = utf8Text;

                    // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
                    StringDecoder.prototype.fillLast = function(buf) {
                        if (this.lastNeed <= buf.length) {
                            buf.copy(
                                this.lastChar,
                                this.lastTotal - this.lastNeed,
                                0,
                                this.lastNeed
                            );
                            return this.lastChar.toString(
                                this.encoding,
                                0,
                                this.lastTotal
                            );
                        }
                        buf.copy(
                            this.lastChar,
                            this.lastTotal - this.lastNeed,
                            0,
                            buf.length
                        );
                        this.lastNeed -= buf.length;
                    };

                    // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
                    // continuation byte.
                    function utf8CheckByte(byte) {
                        if (byte <= 0x7f) return 0;
                        else if (byte >> 5 === 0x06) return 2;
                        else if (byte >> 4 === 0x0e) return 3;
                        else if (byte >> 3 === 0x1e) return 4;
                        return -1;
                    }

                    // Checks at most 3 bytes at the end of a Buffer in order to detect an
                    // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
                    // needed to complete the UTF-8 character (if applicable) are returned.
                    function utf8CheckIncomplete(self, buf, i) {
                        var j = buf.length - 1;
                        if (j < i) return 0;
                        var nb = utf8CheckByte(buf[j]);
                        if (nb >= 0) {
                            if (nb > 0) self.lastNeed = nb - 1;
                            return nb;
                        }
                        if (--j < i) return 0;
                        nb = utf8CheckByte(buf[j]);
                        if (nb >= 0) {
                            if (nb > 0) self.lastNeed = nb - 2;
                            return nb;
                        }
                        if (--j < i) return 0;
                        nb = utf8CheckByte(buf[j]);
                        if (nb >= 0) {
                            if (nb > 0) {
                                if (nb === 2) nb = 0;
                                else self.lastNeed = nb - 3;
                            }
                            return nb;
                        }
                        return 0;
                    }

                    // Validates as many continuation bytes for a multi-byte UTF-8 character as
                    // needed or are available. If we see a non-continuation byte where we expect
                    // one, we "replace" the validated continuation bytes we've seen so far with
                    // UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
                    // behavior. The continuation byte check is included three times in the case
                    // where all of the continuation bytes for a character exist in the same buffer.
                    // It is also done this way as a slight performance increase instead of using a
                    // loop.
                    function utf8CheckExtraBytes(self, buf, p) {
                        if ((buf[0] & 0xc0) !== 0x80) {
                            self.lastNeed = 0;
                            return "\ufffd".repeat(p);
                        }
                        if (self.lastNeed > 1 && buf.length > 1) {
                            if ((buf[1] & 0xc0) !== 0x80) {
                                self.lastNeed = 1;
                                return "\ufffd".repeat(p + 1);
                            }
                            if (self.lastNeed > 2 && buf.length > 2) {
                                if ((buf[2] & 0xc0) !== 0x80) {
                                    self.lastNeed = 2;
                                    return "\ufffd".repeat(p + 2);
                                }
                            }
                        }
                    }

                    // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
                    function utf8FillLast(buf) {
                        var p = this.lastTotal - this.lastNeed;
                        var r = utf8CheckExtraBytes(this, buf, p);
                        if (r !== undefined) return r;
                        if (this.lastNeed <= buf.length) {
                            buf.copy(this.lastChar, p, 0, this.lastNeed);
                            return this.lastChar.toString(
                                this.encoding,
                                0,
                                this.lastTotal
                            );
                        }
                        buf.copy(this.lastChar, p, 0, buf.length);
                        this.lastNeed -= buf.length;
                    }

                    // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
                    // partial character, the character's bytes are buffered until the required
                    // number of bytes are available.
                    function utf8Text(buf, i) {
                        var total = utf8CheckIncomplete(this, buf, i);
                        if (!this.lastNeed) return buf.toString("utf8", i);
                        this.lastTotal = total;
                        var end = buf.length - (total - this.lastNeed);
                        buf.copy(this.lastChar, 0, end);
                        return buf.toString("utf8", i, end);
                    }

                    // For UTF-8, a replacement character for each buffered byte of a (partial)
                    // character needs to be added to the output.
                    function utf8End(buf) {
                        var r = buf && buf.length ? this.write(buf) : "";
                        if (this.lastNeed)
                            return (
                                r +
                                "\ufffd".repeat(this.lastTotal - this.lastNeed)
                            );
                        return r;
                    }

                    // UTF-16LE typically needs two bytes per character, but even if we have an even
                    // number of bytes available, we need to check if we end on a leading/high
                    // surrogate. In that case, we need to wait for the next two bytes in order to
                    // decode the last character properly.
                    function utf16Text(buf, i) {
                        if ((buf.length - i) % 2 === 0) {
                            var r = buf.toString("utf16le", i);
                            if (r) {
                                var c = r.charCodeAt(r.length - 1);
                                if (c >= 0xd800 && c <= 0xdbff) {
                                    this.lastNeed = 2;
                                    this.lastTotal = 4;
                                    this.lastChar[0] = buf[buf.length - 2];
                                    this.lastChar[1] = buf[buf.length - 1];
                                    return r.slice(0, -1);
                                }
                            }
                            return r;
                        }
                        this.lastNeed = 1;
                        this.lastTotal = 2;
                        this.lastChar[0] = buf[buf.length - 1];
                        return buf.toString("utf16le", i, buf.length - 1);
                    }

                    // For UTF-16LE we do not explicitly append special replacement characters if we
                    // end on a partial character, we simply let v8 handle that.
                    function utf16End(buf) {
                        var r = buf && buf.length ? this.write(buf) : "";
                        if (this.lastNeed) {
                            var end = this.lastTotal - this.lastNeed;
                            return (
                                r + this.lastChar.toString("utf16le", 0, end)
                            );
                        }
                        return r;
                    }

                    function base64Text(buf, i) {
                        var n = (buf.length - i) % 3;
                        if (n === 0) return buf.toString("base64", i);
                        this.lastNeed = 3 - n;
                        this.lastTotal = 3;
                        if (n === 1) {
                            this.lastChar[0] = buf[buf.length - 1];
                        } else {
                            this.lastChar[0] = buf[buf.length - 2];
                            this.lastChar[1] = buf[buf.length - 1];
                        }
                        return buf.toString("base64", i, buf.length - n);
                    }

                    function base64End(buf) {
                        var r = buf && buf.length ? this.write(buf) : "";
                        if (this.lastNeed)
                            return (
                                r +
                                this.lastChar.toString(
                                    "base64",
                                    0,
                                    3 - this.lastNeed
                                )
                            );
                        return r;
                    }

                    // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
                    function simpleWrite(buf) {
                        return buf.toString(this.encoding);
                    }

                    function simpleEnd(buf) {
                        return buf && buf.length ? this.write(buf) : "";
                    }
                },
                {
                    buffer:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer/index.js",
                    "buffer-shims":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/buffer-shims/index.js"
                }
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util-deprecate/browser.js": [
                function(require, module, exports) {
                    (function(global) {
                        /**
                         * Module exports.
                         */

                        module.exports = deprecate;

                        /**
                         * Mark that a method should not be used.
                         * Returns a modified function which warns once by default.
                         *
                         * If `localStorage.noDeprecation = true` is set, then it is a no-op.
                         *
                         * If `localStorage.throwDeprecation = true` is set, then deprecated functions
                         * will throw an Error when invoked.
                         *
                         * If `localStorage.traceDeprecation = true` is set, then deprecated functions
                         * will invoke `console.trace()` instead of `console.error()`.
                         *
                         * @param {Function} fn - the function to deprecate
                         * @param {String} msg - the string to print to the console when `fn` is invoked
                         * @returns {Function} a new "deprecated" version of `fn`
                         * @api public
                         */

                        function deprecate(fn, msg) {
                            if (config("noDeprecation")) {
                                return fn;
                            }

                            var warned = false;
                            function deprecated() {
                                if (!warned) {
                                    if (config("throwDeprecation")) {
                                        throw new Error(msg);
                                    } else if (config("traceDeprecation")) {
                                        console.trace(msg);
                                    } else {
                                        console.warn(msg);
                                    }
                                    warned = true;
                                }
                                return fn.apply(this, arguments);
                            }

                            return deprecated;
                        }

                        /**
                         * Checks `localStorage` for boolean values for the given `name`.
                         *
                         * @param {String} name
                         * @returns {Boolean}
                         * @api private
                         */

                        function config(name) {
                            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
                            try {
                                if (!global.localStorage) return false;
                            } catch (_) {
                                return false;
                            }
                            var val = global.localStorage[name];
                            if (null == val) return false;
                            return String(val).toLowerCase() === "true";
                        }
                    }.call(
                        this,
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/node_modules/inherits/inherits_browser.js": [
                function(require, module, exports) {
                    arguments[4][
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/inherits/inherits_browser.js"
                    ][0].apply(exports, arguments);
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/support/isBufferBrowser.js": [
                function(require, module, exports) {
                    module.exports = function isBuffer(arg) {
                        return (
                            arg &&
                            typeof arg === "object" &&
                            typeof arg.copy === "function" &&
                            typeof arg.fill === "function" &&
                            typeof arg.readUInt8 === "function"
                        );
                    };
                },
                {}
            ],
            "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/util.js": [
                function(require, module, exports) {
                    (function(process, global) {
                        // Copyright Joyent, Inc. and other Node contributors.
                        //
                        // Permission is hereby granted, free of charge, to any person obtaining a
                        // copy of this software and associated documentation files (the
                        // "Software"), to deal in the Software without restriction, including
                        // without limitation the rights to use, copy, modify, merge, publish,
                        // distribute, sublicense, and/or sell copies of the Software, and to permit
                        // persons to whom the Software is furnished to do so, subject to the
                        // following conditions:
                        //
                        // The above copyright notice and this permission notice shall be included
                        // in all copies or substantial portions of the Software.
                        //
                        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                        // USE OR OTHER DEALINGS IN THE SOFTWARE.

                        var formatRegExp = /%[sdj%]/g;
                        exports.format = function(f) {
                            if (!isString(f)) {
                                var objects = [];
                                for (var i = 0; i < arguments.length; i++) {
                                    objects.push(inspect(arguments[i]));
                                }
                                return objects.join(" ");
                            }

                            var i = 1;
                            var args = arguments;
                            var len = args.length;
                            var str = String(f).replace(formatRegExp, function(
                                x
                            ) {
                                if (x === "%%") return "%";
                                if (i >= len) return x;
                                switch (x) {
                                    case "%s":
                                        return String(args[i++]);
                                    case "%d":
                                        return Number(args[i++]);
                                    case "%j":
                                        try {
                                            return JSON.stringify(args[i++]);
                                        } catch (_) {
                                            return "[Circular]";
                                        }
                                    default:
                                        return x;
                                }
                            });
                            for (var x = args[i]; i < len; x = args[++i]) {
                                if (isNull(x) || !isObject(x)) {
                                    str += " " + x;
                                } else {
                                    str += " " + inspect(x);
                                }
                            }
                            return str;
                        };

                        // Mark that a method should not be used.
                        // Returns a modified function which warns once by default.
                        // If --no-deprecation is set, then it is a no-op.
                        exports.deprecate = function(fn, msg) {
                            // Allow for deprecating things in the process of starting up.
                            if (isUndefined(global.process)) {
                                return function() {
                                    return exports
                                        .deprecate(fn, msg)
                                        .apply(this, arguments);
                                };
                            }

                            if (process.noDeprecation === true) {
                                return fn;
                            }

                            var warned = false;
                            function deprecated() {
                                if (!warned) {
                                    if (process.throwDeprecation) {
                                        throw new Error(msg);
                                    } else if (process.traceDeprecation) {
                                        console.trace(msg);
                                    } else {
                                        console.error(msg);
                                    }
                                    warned = true;
                                }
                                return fn.apply(this, arguments);
                            }

                            return deprecated;
                        };

                        var debugs = {};
                        var debugEnviron;
                        exports.debuglog = function(set) {
                            if (isUndefined(debugEnviron))
                                debugEnviron = process.env.NODE_DEBUG || "";
                            set = set.toUpperCase();
                            if (!debugs[set]) {
                                if (
                                    new RegExp("\\b" + set + "\\b", "i").test(
                                        debugEnviron
                                    )
                                ) {
                                    var pid = process.pid;
                                    debugs[set] = function() {
                                        var msg = exports.format.apply(
                                            exports,
                                            arguments
                                        );
                                        console.error(
                                            "%s %d: %s",
                                            set,
                                            pid,
                                            msg
                                        );
                                    };
                                } else {
                                    debugs[set] = function() {};
                                }
                            }
                            return debugs[set];
                        };

                        /**
                         * Echos the value of a value. Trys to print the value out
                         * in the best way possible given the different types.
                         *
                         * @param {Object} obj The object to print out.
                         * @param {Object} opts Optional options object that alters the output.
                         */
                        /* legacy: obj, showHidden, depth, colors*/
                        function inspect(obj, opts) {
                            // default options
                            var ctx = {
                                seen: [],
                                stylize: stylizeNoColor
                            };
                            // legacy...
                            if (arguments.length >= 3) ctx.depth = arguments[2];
                            if (arguments.length >= 4)
                                ctx.colors = arguments[3];
                            if (isBoolean(opts)) {
                                // legacy...
                                ctx.showHidden = opts;
                            } else if (opts) {
                                // got an "options" object
                                exports._extend(ctx, opts);
                            }
                            // set default options
                            if (isUndefined(ctx.showHidden))
                                ctx.showHidden = false;
                            if (isUndefined(ctx.depth)) ctx.depth = 2;
                            if (isUndefined(ctx.colors)) ctx.colors = false;
                            if (isUndefined(ctx.customInspect))
                                ctx.customInspect = true;
                            if (ctx.colors) ctx.stylize = stylizeWithColor;
                            return formatValue(ctx, obj, ctx.depth);
                        }
                        exports.inspect = inspect;

                        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                        inspect.colors = {
                            bold: [1, 22],
                            italic: [3, 23],
                            underline: [4, 24],
                            inverse: [7, 27],
                            white: [37, 39],
                            grey: [90, 39],
                            black: [30, 39],
                            blue: [34, 39],
                            cyan: [36, 39],
                            green: [32, 39],
                            magenta: [35, 39],
                            red: [31, 39],
                            yellow: [33, 39]
                        };

                        // Don't use 'blue' not visible on cmd.exe
                        inspect.styles = {
                            special: "cyan",
                            number: "yellow",
                            boolean: "yellow",
                            undefined: "grey",
                            null: "bold",
                            string: "green",
                            date: "magenta",
                            // "name": intentionally not styling
                            regexp: "red"
                        };

                        function stylizeWithColor(str, styleType) {
                            var style = inspect.styles[styleType];

                            if (style) {
                                return (
                                    "\u001b[" +
                                    inspect.colors[style][0] +
                                    "m" +
                                    str +
                                    "\u001b[" +
                                    inspect.colors[style][1] +
                                    "m"
                                );
                            } else {
                                return str;
                            }
                        }

                        function stylizeNoColor(str, styleType) {
                            return str;
                        }

                        function arrayToHash(array) {
                            var hash = {};

                            array.forEach(function(val, idx) {
                                hash[val] = true;
                            });

                            return hash;
                        }

                        function formatValue(ctx, value, recurseTimes) {
                            // Provide a hook for user-specified inspect functions.
                            // Check that value is an object with an inspect function on it
                            if (
                                ctx.customInspect &&
                                value &&
                                isFunction(value.inspect) &&
                                // Filter out the util module, it's inspect function is special
                                value.inspect !== exports.inspect &&
                                // Also filter out any prototype objects using the circular check.
                                !(
                                    value.constructor &&
                                    value.constructor.prototype === value
                                )
                            ) {
                                var ret = value.inspect(recurseTimes, ctx);
                                if (!isString(ret)) {
                                    ret = formatValue(ctx, ret, recurseTimes);
                                }
                                return ret;
                            }

                            // Primitive types cannot have properties
                            var primitive = formatPrimitive(ctx, value);
                            if (primitive) {
                                return primitive;
                            }

                            // Look up the keys of the object.
                            var keys = Object.keys(value);
                            var visibleKeys = arrayToHash(keys);

                            if (ctx.showHidden) {
                                keys = Object.getOwnPropertyNames(value);
                            }

                            // IE doesn't make error fields non-enumerable
                            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                            if (
                                isError(value) &&
                                (keys.indexOf("message") >= 0 ||
                                    keys.indexOf("description") >= 0)
                            ) {
                                return formatError(value);
                            }

                            // Some type of object without properties can be shortcutted.
                            if (keys.length === 0) {
                                if (isFunction(value)) {
                                    var name = value.name
                                        ? ": " + value.name
                                        : "";
                                    return ctx.stylize(
                                        "[Function" + name + "]",
                                        "special"
                                    );
                                }
                                if (isRegExp(value)) {
                                    return ctx.stylize(
                                        RegExp.prototype.toString.call(value),
                                        "regexp"
                                    );
                                }
                                if (isDate(value)) {
                                    return ctx.stylize(
                                        Date.prototype.toString.call(value),
                                        "date"
                                    );
                                }
                                if (isError(value)) {
                                    return formatError(value);
                                }
                            }

                            var base = "",
                                array = false,
                                braces = ["{", "}"];

                            // Make Array say that they are Array
                            if (isArray(value)) {
                                array = true;
                                braces = ["[", "]"];
                            }

                            // Make functions say that they are functions
                            if (isFunction(value)) {
                                var n = value.name ? ": " + value.name : "";
                                base = " [Function" + n + "]";
                            }

                            // Make RegExps say that they are RegExps
                            if (isRegExp(value)) {
                                base =
                                    " " + RegExp.prototype.toString.call(value);
                            }

                            // Make dates with properties first say the date
                            if (isDate(value)) {
                                base =
                                    " " +
                                    Date.prototype.toUTCString.call(value);
                            }

                            // Make error with message first say the error
                            if (isError(value)) {
                                base = " " + formatError(value);
                            }

                            if (
                                keys.length === 0 &&
                                (!array || value.length == 0)
                            ) {
                                return braces[0] + base + braces[1];
                            }

                            if (recurseTimes < 0) {
                                if (isRegExp(value)) {
                                    return ctx.stylize(
                                        RegExp.prototype.toString.call(value),
                                        "regexp"
                                    );
                                } else {
                                    return ctx.stylize("[Object]", "special");
                                }
                            }

                            ctx.seen.push(value);

                            var output;
                            if (array) {
                                output = formatArray(
                                    ctx,
                                    value,
                                    recurseTimes,
                                    visibleKeys,
                                    keys
                                );
                            } else {
                                output = keys.map(function(key) {
                                    return formatProperty(
                                        ctx,
                                        value,
                                        recurseTimes,
                                        visibleKeys,
                                        key,
                                        array
                                    );
                                });
                            }

                            ctx.seen.pop();

                            return reduceToSingleString(output, base, braces);
                        }

                        function formatPrimitive(ctx, value) {
                            if (isUndefined(value))
                                return ctx.stylize("undefined", "undefined");
                            if (isString(value)) {
                                var simple =
                                    "'" +
                                    JSON.stringify(value)
                                        .replace(/^"|"$/g, "")
                                        .replace(/'/g, "\\'")
                                        .replace(/\\"/g, '"') +
                                    "'";
                                return ctx.stylize(simple, "string");
                            }
                            if (isNumber(value))
                                return ctx.stylize("" + value, "number");
                            if (isBoolean(value))
                                return ctx.stylize("" + value, "boolean");
                            // For some reason typeof null is "object", so special case here.
                            if (isNull(value))
                                return ctx.stylize("null", "null");
                        }

                        function formatError(value) {
                            return (
                                "[" + Error.prototype.toString.call(value) + "]"
                            );
                        }

                        function formatArray(
                            ctx,
                            value,
                            recurseTimes,
                            visibleKeys,
                            keys
                        ) {
                            var output = [];
                            for (var i = 0, l = value.length; i < l; ++i) {
                                if (hasOwnProperty(value, String(i))) {
                                    output.push(
                                        formatProperty(
                                            ctx,
                                            value,
                                            recurseTimes,
                                            visibleKeys,
                                            String(i),
                                            true
                                        )
                                    );
                                } else {
                                    output.push("");
                                }
                            }
                            keys.forEach(function(key) {
                                if (!key.match(/^\d+$/)) {
                                    output.push(
                                        formatProperty(
                                            ctx,
                                            value,
                                            recurseTimes,
                                            visibleKeys,
                                            key,
                                            true
                                        )
                                    );
                                }
                            });
                            return output;
                        }

                        function formatProperty(
                            ctx,
                            value,
                            recurseTimes,
                            visibleKeys,
                            key,
                            array
                        ) {
                            var name, str, desc;
                            desc = Object.getOwnPropertyDescriptor(
                                value,
                                key
                            ) || {value: value[key]};
                            if (desc.get) {
                                if (desc.set) {
                                    str = ctx.stylize(
                                        "[Getter/Setter]",
                                        "special"
                                    );
                                } else {
                                    str = ctx.stylize("[Getter]", "special");
                                }
                            } else {
                                if (desc.set) {
                                    str = ctx.stylize("[Setter]", "special");
                                }
                            }
                            if (!hasOwnProperty(visibleKeys, key)) {
                                name = "[" + key + "]";
                            }
                            if (!str) {
                                if (ctx.seen.indexOf(desc.value) < 0) {
                                    if (isNull(recurseTimes)) {
                                        str = formatValue(
                                            ctx,
                                            desc.value,
                                            null
                                        );
                                    } else {
                                        str = formatValue(
                                            ctx,
                                            desc.value,
                                            recurseTimes - 1
                                        );
                                    }
                                    if (str.indexOf("\n") > -1) {
                                        if (array) {
                                            str = str
                                                .split("\n")
                                                .map(function(line) {
                                                    return "  " + line;
                                                })
                                                .join("\n")
                                                .substr(2);
                                        } else {
                                            str =
                                                "\n" +
                                                str
                                                    .split("\n")
                                                    .map(function(line) {
                                                        return "   " + line;
                                                    })
                                                    .join("\n");
                                        }
                                    }
                                } else {
                                    str = ctx.stylize("[Circular]", "special");
                                }
                            }
                            if (isUndefined(name)) {
                                if (array && key.match(/^\d+$/)) {
                                    return str;
                                }
                                name = JSON.stringify("" + key);
                                if (
                                    name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
                                ) {
                                    name = name.substr(1, name.length - 2);
                                    name = ctx.stylize(name, "name");
                                } else {
                                    name = name
                                        .replace(/'/g, "\\'")
                                        .replace(/\\"/g, '"')
                                        .replace(/(^"|"$)/g, "'");
                                    name = ctx.stylize(name, "string");
                                }
                            }

                            return name + ": " + str;
                        }

                        function reduceToSingleString(output, base, braces) {
                            var numLinesEst = 0;
                            var length = output.reduce(function(prev, cur) {
                                numLinesEst++;
                                if (cur.indexOf("\n") >= 0) numLinesEst++;
                                return (
                                    prev +
                                    cur.replace(/\u001b\[\d\d?m/g, "").length +
                                    1
                                );
                            }, 0);

                            if (length > 60) {
                                return (
                                    braces[0] +
                                    (base === "" ? "" : base + "\n ") +
                                    " " +
                                    output.join(",\n  ") +
                                    " " +
                                    braces[1]
                                );
                            }

                            return (
                                braces[0] +
                                base +
                                " " +
                                output.join(", ") +
                                " " +
                                braces[1]
                            );
                        }

                        // NOTE: These type checking functions intentionally don't use `instanceof`
                        // because it is fragile and can be easily faked with `Object.create()`.
                        function isArray(ar) {
                            return Array.isArray(ar);
                        }
                        exports.isArray = isArray;

                        function isBoolean(arg) {
                            return typeof arg === "boolean";
                        }
                        exports.isBoolean = isBoolean;

                        function isNull(arg) {
                            return arg === null;
                        }
                        exports.isNull = isNull;

                        function isNullOrUndefined(arg) {
                            return arg == null;
                        }
                        exports.isNullOrUndefined = isNullOrUndefined;

                        function isNumber(arg) {
                            return typeof arg === "number";
                        }
                        exports.isNumber = isNumber;

                        function isString(arg) {
                            return typeof arg === "string";
                        }
                        exports.isString = isString;

                        function isSymbol(arg) {
                            return typeof arg === "symbol";
                        }
                        exports.isSymbol = isSymbol;

                        function isUndefined(arg) {
                            return arg === void 0;
                        }
                        exports.isUndefined = isUndefined;

                        function isRegExp(re) {
                            return (
                                isObject(re) &&
                                objectToString(re) === "[object RegExp]"
                            );
                        }
                        exports.isRegExp = isRegExp;

                        function isObject(arg) {
                            return typeof arg === "object" && arg !== null;
                        }
                        exports.isObject = isObject;

                        function isDate(d) {
                            return (
                                isObject(d) &&
                                objectToString(d) === "[object Date]"
                            );
                        }
                        exports.isDate = isDate;

                        function isError(e) {
                            return (
                                isObject(e) &&
                                (objectToString(e) === "[object Error]" ||
                                    e instanceof Error)
                            );
                        }
                        exports.isError = isError;

                        function isFunction(arg) {
                            return typeof arg === "function";
                        }
                        exports.isFunction = isFunction;

                        function isPrimitive(arg) {
                            return (
                                arg === null ||
                                typeof arg === "boolean" ||
                                typeof arg === "number" ||
                                typeof arg === "string" ||
                                typeof arg === "symbol" || // ES6 symbol
                                typeof arg === "undefined"
                            );
                        }
                        exports.isPrimitive = isPrimitive;

                        exports.isBuffer = require("./support/isBuffer");

                        function objectToString(o) {
                            return Object.prototype.toString.call(o);
                        }

                        function pad(n) {
                            return n < 10
                                ? "0" + n.toString(10)
                                : n.toString(10);
                        }

                        var months = [
                            "Jan",
                            "Feb",
                            "Mar",
                            "Apr",
                            "May",
                            "Jun",
                            "Jul",
                            "Aug",
                            "Sep",
                            "Oct",
                            "Nov",
                            "Dec"
                        ];

                        // 26 Feb 16:19:34
                        function timestamp() {
                            var d = new Date();
                            var time = [
                                pad(d.getHours()),
                                pad(d.getMinutes()),
                                pad(d.getSeconds())
                            ].join(":");
                            return [
                                d.getDate(),
                                months[d.getMonth()],
                                time
                            ].join(" ");
                        }

                        // log is just a thin wrapper to console.log that prepends a timestamp
                        exports.log = function() {
                            console.log(
                                "%s - %s",
                                timestamp(),
                                exports.format.apply(exports, arguments)
                            );
                        };

                        /**
                         * Inherit the prototype methods from one constructor into another.
                         *
                         * The Function.prototype.inherits from lang.js rewritten as a standalone
                         * function (not on Function.prototype). NOTE: If this file is to be loaded
                         * during bootstrapping this function needs to be rewritten using some native
                         * functions as prototype setup using normal JavaScript does not work as
                         * expected during bootstrapping (see mirror.js in r114903).
                         *
                         * @param {function} ctor Constructor function which needs to inherit the
                         *     prototype.
                         * @param {function} superCtor Constructor function to inherit prototype from.
                         */
                        exports.inherits = require("inherits");

                        exports._extend = function(origin, add) {
                            // Don't do anything if add isn't an object
                            if (!add || !isObject(add)) return origin;

                            var keys = Object.keys(add);
                            var i = keys.length;
                            while (i--) {
                                origin[keys[i]] = add[keys[i]];
                            }
                            return origin;
                        };

                        function hasOwnProperty(obj, prop) {
                            return Object.prototype.hasOwnProperty.call(
                                obj,
                                prop
                            );
                        }
                    }.call(
                        this,
                        require("_process"),
                        typeof global !== "undefined"
                            ? global
                            : typeof self !== "undefined"
                                ? self
                                : typeof window !== "undefined"
                                    ? window
                                    : {}
                    ));
                },
                {
                    "./support/isBuffer":
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/support/isBufferBrowser.js",
                    _process:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/process/browser.js",
                    inherits:
                        "/home/sigve/Dev/Bitshares/bitsharesjs/node_modules/util/node_modules/inherits/inherits_browser.js"
                }
            ]
        },
        {},
        ["/home/sigve/Dev/Bitshares/bitsharesjs/dist/browser.js"]
    )("/home/sigve/Dev/Bitshares/bitsharesjs/dist/browser.js");
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2Jyb3dzZXIuanMiLCJkaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanMiLCJkaXN0L2NoYWluL3NyYy9DaGFpblR5cGVzLmpzIiwiZGlzdC9jaGFpbi9zcmMvT2JqZWN0SWQuanMiLCJkaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXIuanMiLCJkaXN0L2NoYWluL3NyYy9zdGF0ZS5qcyIsImRpc3QvZWNjL2luZGV4LmpzIiwiZGlzdC9lY2Mvc3JjL0JyYWluS2V5LmpzIiwiZGlzdC9lY2Mvc3JjL0tleVV0aWxzLmpzIiwiZGlzdC9lY2Mvc3JjL1ByaXZhdGVLZXkuanMiLCJkaXN0L2VjYy9zcmMvUHVibGljS2V5LmpzIiwiZGlzdC9lY2Mvc3JjL2FkZHJlc3MuanMiLCJkaXN0L2VjYy9zcmMvYWVzLmpzIiwiZGlzdC9lY2Mvc3JjL2VjZHNhLmpzIiwiZGlzdC9lY2Mvc3JjL2Vjc2lnbmF0dXJlLmpzIiwiZGlzdC9lY2Mvc3JjL2VuZm9yY2VfdHlwZXMuanMiLCJkaXN0L2VjYy9zcmMvaGFzaC5qcyIsImRpc3QvZWNjL3NyYy9zaWduYXR1cmUuanMiLCJkaXN0L3NlcmlhbGl6ZXIvaW5kZXguanMiLCJkaXN0L3NlcmlhbGl6ZXIvc3JjL0Zhc3RQYXJzZXIuanMiLCJkaXN0L3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uLmpzIiwiZGlzdC9zZXJpYWxpemVyL3NyYy9lcnJvcl93aXRoX2NhdXNlLmpzIiwiZGlzdC9zZXJpYWxpemVyL3NyYy9vcGVyYXRpb25zLmpzIiwiZGlzdC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzIiwiZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qcyIsImRpc3Qvc2VyaWFsaXplci9zcmMvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpZ2kvbGliL2JpZ2kuanMiLCJub2RlX21vZHVsZXMvYmlnaS9saWIvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9iaWdpL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaWdpL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9iaXRzaGFyZXNqcy13cy9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0c2hhcmVzanMtd3MvY2pzL3NyYy9BcGlJbnN0YW5jZXMuanMiLCJub2RlX21vZHVsZXMvYml0c2hhcmVzanMtd3MvY2pzL3NyYy9DaGFpbkNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9iaXRzaGFyZXNqcy13cy9janMvc3JjL0NoYWluV2ViU29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL2JpdHNoYXJlc2pzLXdzL2Nqcy9zcmMvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYml0c2hhcmVzanMtd3MvY2pzL3NyYy9HcmFwaGVuZUFwaS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItc2hpbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J5dGVidWZmZXIvZGlzdC9ieXRlYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2xlZ2FjeS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvYWVzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWhleC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZXZwa2RmLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9lY3VydmUvbGliL2N1cnZlLmpzIiwibm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmVzLmpzb24iLCJub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lY3VydmUvbGliL25hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvcG9pbnQuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvbmcvZGlzdC9sb25nLmpzIiwibm9kZV9tb2R1bGVzL21kNS5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZDUuanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmlwZW1kMTYwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2VjdXJlLXJhbmRvbS9saWIvc2VjdXJlLXJhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNweUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2w0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3IrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbHFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6ckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuU0E7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcml2YXRlS2V5OiByZXF1aXJlKFwiLi9lY2Mvc3JjL1ByaXZhdGVLZXlcIiksXG4gICAgUHVibGljS2V5OiByZXF1aXJlKFwiLi9lY2Mvc3JjL1B1YmxpY0tleVwiKSxcbiAgICBTaWduYXR1cmU6IHJlcXVpcmUoXCIuL2VjYy9zcmMvc2lnbmF0dXJlXCIpLFxuICAgIGtleTogcmVxdWlyZShcIi4vZWNjL3NyYy9LZXlVdGlsc1wiKSxcbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXI6IHJlcXVpcmUoXCIuL2NoYWluL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXJcIiksXG4gICAgTG9naW46IHJlcXVpcmUoXCIuL2NoYWluL3NyYy9BY2NvdW50TG9naW5cIiksXG4gICAgYml0c2hhcmVzX3dzOiByZXF1aXJlKFwiYml0c2hhcmVzanMtd3NcIilcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUHJpdmF0ZUtleSA9IHJlcXVpcmUoXCIuLi8uLi9lY2Mvc3JjL1ByaXZhdGVLZXlcIik7XG5cbnZhciBfUHJpdmF0ZUtleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcml2YXRlS2V5KTtcblxudmFyIF9LZXlVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi9lY2Mvc3JjL0tleVV0aWxzXCIpO1xuXG52YXIgX0tleVV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0tleVV0aWxzKTtcblxudmFyIF9zdGF0ZSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX2tleUNhY2hlUHJpdiA9IHt9O1xudmFyIF9rZXlDYWNoZVB1YiA9IHt9O1xuXG52YXIgQWNjb3VudExvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjY291bnRMb2dpbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY291bnRMb2dpbik7XG5cbiAgICAgICAgdmFyIHN0YXRlID0geyBsb2dnZWRJbjogZmFsc2UsIHJvbGVzOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiLCBcIm1lbW9cIl0gfTtcbiAgICAgICAgdGhpcy5nZXQgPSAoMCwgX3N0YXRlLmdldCkoc3RhdGUpO1xuICAgICAgICB0aGlzLnNldCA9ICgwLCBfc3RhdGUuc2V0KShzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5zdWJzID0ge307XG4gICAgfVxuXG4gICAgQWNjb3VudExvZ2luLnByb3RvdHlwZS5hZGRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBhZGRTdWJzY3JpcHRpb24oY2IpIHtcbiAgICAgICAgdGhpcy5zdWJzW2NiXSA9IGNiO1xuICAgIH07XG5cbiAgICBBY2NvdW50TG9naW4ucHJvdG90eXBlLnNldFJvbGVzID0gZnVuY3Rpb24gc2V0Um9sZXMocm9sZXMpIHtcbiAgICAgICAgdGhpcy5zZXQoXCJyb2xlc1wiLCByb2xlcyk7XG4gICAgfTtcblxuICAgIEFjY291bnRMb2dpbi5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gZ2VuZXJhdGVLZXlzKGFjY291bnROYW1lLCBwYXNzd29yZCwgcm9sZXMsIHByZWZpeCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbmFtZSBvciBwYXNzd29yZCByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3N3b3JkIG11c3QgaGF2ZSBhdCBsZWFzdCAxMiBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaXZLZXlzID0ge307XG4gICAgICAgIHZhciBwdWJLZXlzID0ge307XG5cbiAgICAgICAgKHJvbGVzIHx8IHRoaXMuZ2V0KFwicm9sZXNcIikpLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgICAgIHZhciBzZWVkID0gYWNjb3VudE5hbWUgKyByb2xlICsgcGFzc3dvcmQ7XG4gICAgICAgICAgICB2YXIgcGtleSA9IF9rZXlDYWNoZVByaXZbc2VlZF0gPyBfa2V5Q2FjaGVQcml2W3NlZWRdIDogX1ByaXZhdGVLZXkyLmRlZmF1bHQuZnJvbVNlZWQoX0tleVV0aWxzMi5kZWZhdWx0Lm5vcm1hbGl6ZV9icmFpbktleShzZWVkKSk7XG4gICAgICAgICAgICBfa2V5Q2FjaGVQcml2W3NlZWRdID0gcGtleTtcblxuICAgICAgICAgICAgcHJpdktleXNbcm9sZV0gPSBwa2V5O1xuICAgICAgICAgICAgcHViS2V5c1tyb2xlXSA9IF9rZXlDYWNoZVB1YltzZWVkXSA/IF9rZXlDYWNoZVB1YltzZWVkXSA6IHBrZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZyhwcmVmaXgpO1xuXG4gICAgICAgICAgICBfa2V5Q2FjaGVQdWJbc2VlZF0gPSBwdWJLZXlzW3JvbGVdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBwcml2S2V5czogcHJpdktleXMsIHB1YktleXM6IHB1YktleXMgfTtcbiAgICB9O1xuXG4gICAgQWNjb3VudExvZ2luLnByb3RvdHlwZS5jaGVja0tleXMgPSBmdW5jdGlvbiBjaGVja0tleXMoX3JlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBhY2NvdW50TmFtZSA9IF9yZWYuYWNjb3VudE5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZCA9IF9yZWYucGFzc3dvcmQsXG4gICAgICAgICAgICBhdXRocyA9IF9yZWYuYXV0aHM7XG5cbiAgICAgICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGFzc3dvcmQgfHwgIWF1dGhzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGVja0tleXM6IE1pc3NpbmcgaW5wdXRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNLZXkgPSBmYWxzZTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChyb2xlKSB7XG4gICAgICAgICAgICB2YXIgX2dlbmVyYXRlS2V5cyA9IF90aGlzLmdlbmVyYXRlS2V5cyhhY2NvdW50TmFtZSwgcGFzc3dvcmQsIFtyb2xlXSksXG4gICAgICAgICAgICAgICAgcHJpdktleXMgPSBfZ2VuZXJhdGVLZXlzLnByaXZLZXlzLFxuICAgICAgICAgICAgICAgIHB1YktleXMgPSBfZ2VuZXJhdGVLZXlzLnB1YktleXM7XG5cbiAgICAgICAgICAgIGF1dGhzW3JvbGVdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IHB1YktleXNbcm9sZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0KHJvbGUsIHsgcHJpdjogcHJpdktleXNbcm9sZV0sIHB1YjogcHViS2V5c1tyb2xlXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciByb2xlIGluIGF1dGhzKSB7XG4gICAgICAgICAgICBfbG9vcChyb2xlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaGFzS2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldChcIm5hbWVcIiwgYWNjb3VudE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXQoXCJsb2dnZWRJblwiLCBoYXNLZXkpO1xuXG4gICAgICAgIHJldHVybiBoYXNLZXk7XG4gICAgfTtcblxuICAgIEFjY291bnRMb2dpbi5wcm90b3R5cGUuc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBteUtleXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc0tleSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZ2V0KFwicm9sZXNcIikuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgdmFyIG15S2V5ID0gX3RoaXMyLmdldChyb2xlKTtcbiAgICAgICAgICAgIGlmIChteUtleSkge1xuICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZGRpbmcgc2lnbmVyOlwiLCBteUtleS5wdWIpO1xuICAgICAgICAgICAgICAgIHRyLmFkZF9zaWduZXIobXlLZXkucHJpdiwgbXlLZXkucHViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBkbyBub3QgaGF2ZSBhbnkgcHJpdmF0ZSBrZXlzIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQWNjb3VudExvZ2luO1xufSgpO1xuXG52YXIgYWNjb3VudExvZ2luID0gbmV3IEFjY291bnRMb2dpbigpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhY2NvdW50TG9naW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIENoYWluVHlwZXMgPSB7fTtcblxuQ2hhaW5UeXBlcy5yZXNlcnZlZF9zcGFjZXMgPSB7XG4gICAgcmVsYXRpdmVfcHJvdG9jb2xfaWRzOiAwLFxuICAgIHByb3RvY29sX2lkczogMSxcbiAgICBpbXBsZW1lbnRhdGlvbl9pZHM6IDJcbn07XG5cbkNoYWluVHlwZXMub2JqZWN0X3R5cGUgPSB7XG4gICAgXCJudWxsXCI6IDAsXG4gICAgYmFzZTogMSxcbiAgICBhY2NvdW50OiAyLFxuICAgIGFzc2V0OiAzLFxuICAgIGZvcmNlX3NldHRsZW1lbnQ6IDQsXG4gICAgY29tbWl0dGVlX21lbWJlcjogNSxcbiAgICB3aXRuZXNzOiA2LFxuICAgIGxpbWl0X29yZGVyOiA3LFxuICAgIGNhbGxfb3JkZXI6IDgsXG4gICAgY3VzdG9tOiA5LFxuICAgIHByb3Bvc2FsOiAxMCxcbiAgICBvcGVyYXRpb25faGlzdG9yeTogMTEsXG4gICAgd2l0aGRyYXdfcGVybWlzc2lvbjogMTIsXG4gICAgdmVzdGluZ19iYWxhbmNlOiAxMyxcbiAgICB3b3JrZXI6IDE0LFxuICAgIGJhbGFuY2U6IDE1XG59O1xuXG5DaGFpblR5cGVzLmltcGxfb2JqZWN0X3R5cGUgPSB7XG4gICAgZ2xvYmFsX3Byb3BlcnR5OiAwLFxuICAgIGR5bmFtaWNfZ2xvYmFsX3Byb3BlcnR5OiAxLFxuICAgIGluZGV4X21ldGE6IDIsXG4gICAgYXNzZXRfZHluYW1pY19kYXRhOiAzLFxuICAgIGFzc2V0X2JpdGFzc2V0X2RhdGE6IDQsXG4gICAgYWNjb3VudF9iYWxhbmNlOiA1LFxuICAgIGFjY291bnRfc3RhdGlzdGljczogNixcbiAgICB0cmFuc2FjdGlvbjogNyxcbiAgICBibG9ja19zdW1tYXJ5OiA4LFxuICAgIGFjY291bnRfdHJhbnNhY3Rpb25faGlzdG9yeTogOSxcbiAgICBibGluZGVkX2JhbGFuY2U6IDEwLFxuICAgIGNoYWluX3Byb3BlcnR5OiAxMSxcbiAgICB3aXRuZXNzX3NjaGVkdWxlOiAxMixcbiAgICBidWRnZXRfcmVjb3JkOiAxM1xufTtcblxuQ2hhaW5UeXBlcy52b3RlX3R5cGUgPSB7XG4gICAgY29tbWl0dGVlOiAwLFxuICAgIHdpdG5lc3M6IDEsXG4gICAgd29ya2VyOiAyXG59O1xuXG5DaGFpblR5cGVzLm9wZXJhdGlvbnMgPSB7XG4gICAgdHJhbnNmZXI6IDAsXG4gICAgbGltaXRfb3JkZXJfY3JlYXRlOiAxLFxuICAgIGxpbWl0X29yZGVyX2NhbmNlbDogMixcbiAgICBjYWxsX29yZGVyX3VwZGF0ZTogMyxcbiAgICBmaWxsX29yZGVyOiA0LFxuICAgIGFjY291bnRfY3JlYXRlOiA1LFxuICAgIGFjY291bnRfdXBkYXRlOiA2LFxuICAgIGFjY291bnRfd2hpdGVsaXN0OiA3LFxuICAgIGFjY291bnRfdXBncmFkZTogOCxcbiAgICBhY2NvdW50X3RyYW5zZmVyOiA5LFxuICAgIGFzc2V0X2NyZWF0ZTogMTAsXG4gICAgYXNzZXRfdXBkYXRlOiAxMSxcbiAgICBhc3NldF91cGRhdGVfYml0YXNzZXQ6IDEyLFxuICAgIGFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2VyczogMTMsXG4gICAgYXNzZXRfaXNzdWU6IDE0LFxuICAgIGFzc2V0X3Jlc2VydmU6IDE1LFxuICAgIGFzc2V0X2Z1bmRfZmVlX3Bvb2w6IDE2LFxuICAgIGFzc2V0X3NldHRsZTogMTcsXG4gICAgYXNzZXRfZ2xvYmFsX3NldHRsZTogMTgsXG4gICAgYXNzZXRfcHVibGlzaF9mZWVkOiAxOSxcbiAgICB3aXRuZXNzX2NyZWF0ZTogMjAsXG4gICAgd2l0bmVzc191cGRhdGU6IDIxLFxuICAgIHByb3Bvc2FsX2NyZWF0ZTogMjIsXG4gICAgcHJvcG9zYWxfdXBkYXRlOiAyMyxcbiAgICBwcm9wb3NhbF9kZWxldGU6IDI0LFxuICAgIHdpdGhkcmF3X3Blcm1pc3Npb25fY3JlYXRlOiAyNSxcbiAgICB3aXRoZHJhd19wZXJtaXNzaW9uX3VwZGF0ZTogMjYsXG4gICAgd2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbTogMjcsXG4gICAgd2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGU6IDI4LFxuICAgIGNvbW1pdHRlZV9tZW1iZXJfY3JlYXRlOiAyOSxcbiAgICBjb21taXR0ZWVfbWVtYmVyX3VwZGF0ZTogMzAsXG4gICAgY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnM6IDMxLFxuICAgIHZlc3RpbmdfYmFsYW5jZV9jcmVhdGU6IDMyLFxuICAgIHZlc3RpbmdfYmFsYW5jZV93aXRoZHJhdzogMzMsXG4gICAgd29ya2VyX2NyZWF0ZTogMzQsXG4gICAgY3VzdG9tOiAzNSxcbiAgICBhc3NlcnQ6IDM2LFxuICAgIGJhbGFuY2VfY2xhaW06IDM3LFxuICAgIG92ZXJyaWRlX3RyYW5zZmVyOiAzOCxcbiAgICB0cmFuc2Zlcl90b19ibGluZDogMzksXG4gICAgYmxpbmRfdHJhbnNmZXI6IDQwLFxuICAgIHRyYW5zZmVyX2Zyb21fYmxpbmQ6IDQxLFxuICAgIGFzc2V0X3NldHRsZV9jYW5jZWw6IDQyLFxuICAgIGFzc2V0X2NsYWltX2ZlZXM6IDQzXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDaGFpblR5cGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYnl0ZWJ1ZmZlciA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKTtcblxudmFyIF9TZXJpYWxpemVyVmFsaWRhdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uJyk7XG5cbnZhciBfU2VyaWFsaXplclZhbGlkYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VyaWFsaXplclZhbGlkYXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgREJfTUFYX0lOU1RBTkNFX0lEID0gX2J5dGVidWZmZXIuTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KDIsIDQ4KSAtIDEpO1xuXG52YXIgT2JqZWN0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0SWQoc3BhY2UsIHR5cGUsIGluc3RhbmNlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RJZCk7XG5cbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHZhciBpbnN0YW5jZV9zdHJpbmcgPSB0aGlzLmluc3RhbmNlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBfT2JqZWN0SWQgPSB0aGlzLnNwYWNlICsgJy4nICsgdGhpcy50eXBlICsgJy4nICsgaW5zdGFuY2Vfc3RyaW5nO1xuICAgICAgICBpZiAoIV9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5pc19kaWdpdHMoaW5zdGFuY2Vfc3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3ICgnSW52YWxpZCBvYmplY3QgaWQgJyArIF9PYmplY3RJZCkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdElkLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zcGFjZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnR5cGUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0gX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfbWF0Y2goL14oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykkLywgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKHZhbHVlLCBcIk9iamVjdElkXCIpLCBcIk9iamVjdElkXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKHBhcnNlSW50KHBhcmFtc1sxXSksIHBhcnNlSW50KHBhcmFtc1syXSksIF9ieXRlYnVmZmVyLkxvbmcuZnJvbVN0cmluZyhwYXJhbXNbM10pKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0SWQuZnJvbUxvbmcgPSBmdW5jdGlvbiBmcm9tTG9uZyhsb25nKSB7XG4gICAgICAgIHZhciBzcGFjZSA9IGxvbmcuc2hpZnRSaWdodCg1NikudG9JbnQoKTtcbiAgICAgICAgdmFyIHR5cGUgPSBsb25nLnNoaWZ0UmlnaHQoNDgpLnRvSW50KCkgJiAweDAwZmY7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGxvbmcuYW5kKERCX01BWF9JTlNUQU5DRV9JRCk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoc3BhY2UsIHR5cGUsIGluc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0SWQuZnJvbUJ5dGVCdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tTG9uZyhiLnJlYWRVaW50NjQoKSk7XG4gICAgfTtcblxuICAgIE9iamVjdElkLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcoKSB7XG4gICAgICAgIHJldHVybiBfYnl0ZWJ1ZmZlci5Mb25nLmZyb21OdW1iZXIodGhpcy5zcGFjZSkuc2hpZnRMZWZ0KDU2KS5vcihfYnl0ZWJ1ZmZlci5Mb25nLmZyb21OdW1iZXIodGhpcy50eXBlKS5zaGlmdExlZnQoNDgpLm9yKHRoaXMuaW5zdGFuY2UpKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0SWQucHJvdG90eXBlLmFwcGVuZEJ5dGVCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIud3JpdGVVaW50NjQodGhpcy50b0xvbmcoKSk7XG4gICAgfTtcblxuICAgIE9iamVjdElkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFjZSArICcuJyArIHRoaXMudHlwZSArICcuJyArIHRoaXMuaW5zdGFuY2UudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9iamVjdElkO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBPYmplY3RJZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfZWNjID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKTtcblxudmFyIF9zZXJpYWxpemVyID0gcmVxdWlyZShcIi4uLy4uL3NlcmlhbGl6ZXJcIik7XG5cbnZhciBfYml0c2hhcmVzanNXcyA9IHJlcXVpcmUoXCJiaXRzaGFyZXNqcy13c1wiKTtcblxudmFyIF9DaGFpblR5cGVzID0gcmVxdWlyZShcIi4vQ2hhaW5UeXBlc1wiKTtcblxudmFyIF9DaGFpblR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoYWluVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgaGVhZF9ibG9ja190aW1lX3N0cmluZywgY29tbWl0dGVlX21pbl9yZXZpZXc7XG5cbnZhciBUcmFuc2FjdGlvbkJ1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25CdWlsZGVyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb25CdWlsZGVyKTtcblxuICAgICAgICB0aGlzLnJlZl9ibG9ja19udW0gPSAwO1xuICAgICAgICB0aGlzLnJlZl9ibG9ja19wcmVmaXggPSAwO1xuICAgICAgICB0aGlzLmV4cGlyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuXG4gICAgICAgIC8vIHNlbWktcHJpdmF0ZSBtZXRob2QgYmluZGluZ3NcbiAgICAgICAgdGhpcy5fYnJvYWRjYXN0ID0gX2Jyb2FkY2FzdC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBAYXJnIHtzdHJpbmd9IG5hbWUgLSBsaWtlIFwidHJhbnNmZXJcIlxuICAgICAgICBAYXJnIHtvYmplY3R9IG9wZXJhdGlvbiAtIEpTT04gbWF0Y2hjaGluZyB0aGUgb3BlcmF0aW9uJ3MgZm9ybWF0XG4gICAgKi9cblxuXG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRfdHlwZV9vcGVyYXRpb24gPSBmdW5jdGlvbiBhZGRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuYWRkX29wZXJhdGlvbih0aGlzLmdldF90eXBlX29wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgVGhpcyBkb2VzIGl0IGFsbDogc2V0IGZlZXMsIGZpbmFsaXplLCBzaWduLCBhbmQgYnJvYWRjYXN0IChpZiB3YW50ZWQpLlxuICAgICAgICAgQGFyZyB7Q29uZmlkZW50aWFsV2FsbGV0fSBjd2FsbGV0IC0gbXVzdCBiZSB1bmxvY2tlZCwgdXNlZCB0byBnYXRoZXIgc2lnbmluZyBrZXlzXG4gICAgICAgICBAYXJnIHthcnJheTxzdHJpbmc+fSBbc2lnbmVyX3B1YmtleXMgPSBudWxsXSAtIE9wdGlvbmFsIFtcIkdQSEFiYzlEZWYwLi4uXCIsIC4uLl0uICBUaGVzZSBhcmUgYWRkaXRpb25hbCBzaWduaW5nIGtleXMuICBTb21lIGJhbGFuY2UgY2xhaW1zIHJlcXVpcmUgcHJvcHJpdGFyeSBhZGRyZXNzIGZvcm1hdHMsIHRoZSB3aXRuZXNzIG5vZGUgY2FuJ3QgdGVsbCB1cyB3aGljaCBvbmVzIGFyZSBuZWVkZWQgc28gdGhleSBtdXN0IGJlIHBhc3NlZCBpbi4gIElmIHRoZSB3aXRuZXNzIG5vZGUgY2FuIGZpZ3VyZSBvdXQgYSBzaWduaW5nIGtleSAobW9zdGx5IGFsbCBvdGhlciB0cmFuc2FjdGlvbnMpLCBpdCBzaG91bGQgbm90IGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2Jyb2FkY2FzdCA9IGZhbHNlXVxuICAgICovXG5cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc190cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHByb2Nlc3NfdHJhbnNhY3Rpb24oY3dhbGxldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzaWduZXJfcHVia2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgdmFyIGJyb2FkY2FzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHdhbGxldF9vYmplY3QgPSBjd2FsbGV0LndhbGxldC53YWxsZXRfb2JqZWN0O1xuICAgICAgICBpZiAoX2JpdHNoYXJlc2pzV3MuQXBpcy5pbnN0YW5jZSgpLmNoYWluX2lkICE9PSB3YWxsZXRfb2JqZWN0LmdldChcImNoYWluX2lkXCIpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJNaXNtYXRjaGVkIGNoYWluX2lkOyBleHBlY3RpbmcgXCIgKyB3YWxsZXRfb2JqZWN0LmdldChcImNoYWluX2lkXCIpICsgXCIsIGJ1dCBnb3QgXCIgKyBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuY2hhaW5faWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldF9yZXF1aXJlZF9mZWVzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmVyX3B1YmtleXNfYWRkZWQgPSB7fTtcbiAgICAgICAgICAgIGlmIChzaWduZXJfcHVia2V5cykge1xuICAgICAgICAgICAgICAgIC8vIEJhbGFuY2UgY2xhaW1zIGFyZSBieSBhZGRyZXNzLCBvbmx5IHRoZSBwcml2YXRlXG4gICAgICAgICAgICAgICAgLy8ga2V5IGhvbGRlciBjYW4ga25vdyBhYm91dCB0aGVzZSBhZGRpdGlvbmFsXG4gICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsIGtleXMuXG4gICAgICAgICAgICAgICAgdmFyIHB1YmtleXMgPSBjd2FsbGV0LmdldFB1YmtleXNfaGF2aW5nX1ByaXZhdGVLZXkoc2lnbmVyX3B1YmtleXMpO1xuICAgICAgICAgICAgICAgIGlmICghcHVia2V5cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2lnbmluZyBrZXlcIik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBwdWJrZXlzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHVia2V5X3N0cmluZyA9IF9yZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gY3dhbGxldC5nZXRQcml2YXRlS2V5KHB1YmtleV9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRfc2lnbmVyKHByaXZhdGVfa2V5LCBwdWJrZXlfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyX3B1YmtleXNfYWRkZWRbcHVia2V5X3N0cmluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHB1YmtleXMgPSBfcmVmMi5wdWJrZXlzLFxuICAgICAgICAgICAgICAgICAgICBhZGR5cyA9IF9yZWYyLmFkZHlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIG15X3B1YmtleXMgPSBjd2FsbGV0LmdldFB1YmtleXNfaGF2aW5nX1ByaXZhdGVLZXkocHVia2V5cywgYWRkeXMpO1xuXG4gICAgICAgICAgICAgICAgLy97Ly9UZXN0aW5nIG9ubHksIGRvbid0IHNlbmQgQWxsIHB1YmxpYyBrZXlzIVxuICAgICAgICAgICAgICAgIC8vICAgIHZhciBwdWJrZXlzX2FsbCA9IFByaXZhdGVLZXlTdG9yZS5nZXRQdWJrZXlzKCkgLy8gQWxsIHB1YmxpYyBrZXlzXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy5nZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyhwdWJrZXlzX2FsbCkudGhlbiggcmVxdWlyZWRfcHVia2V5X3N0cmluZ3MgPT5cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJ2dldF9yZXF1aXJlZF9zaWduYXR1cmVzIGFsbFxcdCcscmVxdWlyZWRfcHVia2V5X3N0cmluZ3Muc29ydCgpLCBwdWJrZXlzX2FsbCkpXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy5nZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyhteV9wdWJrZXlzKS50aGVuKCByZXF1aXJlZF9wdWJrZXlfc3RyaW5ncyA9PlxuICAgICAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZygnZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgbm9ybWFsXFx0JyxyZXF1aXJlZF9wdWJrZXlfc3RyaW5ncy5zb3J0KCksIHB1YmtleXMpKVxuICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKG15X3B1YmtleXMpLnRoZW4oZnVuY3Rpb24gKHJlcXVpcmVkX3B1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHJlcXVpcmVkX3B1YmtleXMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wdWJrZXlfc3RyaW5nID0gX3JlZjM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJfcHVia2V5c19hZGRlZFtfcHVia2V5X3N0cmluZ10pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gY3dhbGxldC5nZXRQcml2YXRlS2V5KF9wdWJrZXlfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJpdmF0ZV9rZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgd2lsbCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQga2V5cyBmcm9tIG15X3B1YmtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNpZ25pbmcga2V5IGZvciBcIiArIF9wdWJrZXlfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZF9zaWduZXIocHJpdmF0ZV9rZXksIF9wdWJrZXlfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb2FkY2FzdCA/IF90aGlzLmJyb2FkY2FzdCgpIDogX3RoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKiBUeXBpY2FsbHkgdGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBqdXN0IHByaW9yIHRvIHNpZ25pbmcuICBPbmNlIGZpbmFsaXplZCB0aGlzIHRyYW5zYWN0aW9uIGNhbiBub3QgYmUgY2hhbmdlZC4gKi9cblxuXG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9vYmplY3RzXCIsIFtbXCIyLjEuMFwiXV0pLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICBoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nID0gclswXS50aW1lO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczIuZXhwaXJhdGlvbiA9PT0gMCkgX3RoaXMyLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5leHBpcmVfaW5fc2VjcztcbiAgICAgICAgICAgICAgICBfdGhpczIucmVmX2Jsb2NrX251bSA9IHJbMF0uaGVhZF9ibG9ja19udW1iZXIgJiAweGZmZmY7XG4gICAgICAgICAgICAgICAgX3RoaXMyLnJlZl9ibG9ja19wcmVmaXggPSBuZXcgQnVmZmVyKHJbMF0uaGVhZF9ibG9ja19pZCwgXCJoZXhcIikucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coXCJyZWZfYmxvY2tcIixAcmVmX2Jsb2NrX251bSxAcmVmX2Jsb2NrX3ByZWZpeCxyKVxuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gX3RoaXMyLm9wZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9wOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzFdW1wiZmluYWxpemVcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wWzFdLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMyLnRyX2J1ZmZlciA9IF9zZXJpYWxpemVyLm9wcy50cmFuc2FjdGlvbi50b0J1ZmZlcihfdGhpczIpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqIEByZXR1cm4ge3N0cmluZ30gaGV4IHRyYW5zYWN0aW9uIElEICovXG5cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2VjYy5oYXNoLnNoYTI1Nih0aGlzLnRyX2J1ZmZlcikudG9TdHJpbmcoXCJoZXhcIikuc3Vic3RyaW5nKDAsIDQwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIFR5cGljYWxseSBvbmUgd2lsbCB1c2Uge0BsaW5rIHRoaXMuYWRkX3R5cGVfb3BlcmF0aW9ufSBpbnN0ZWFkLlxuICAgICAgICBAYXJnIHthcnJheX0gb3BlcmF0aW9uIC0gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uXVxuICAgICovXG5cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkX29wZXJhdGlvbiA9IGZ1bmN0aW9uIGFkZF9vcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKG9wZXJhdGlvbiwgXCJvcGVyYXRpb25cIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYXJyYXkgW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uXVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0X3R5cGVfb3BlcmF0aW9uID0gZnVuY3Rpb24gZ2V0X3R5cGVfb3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShuYW1lLCBcIm5hbWVcIik7XG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShvcGVyYXRpb24sIFwib3BlcmF0aW9uXCIpO1xuICAgICAgICB2YXIgX3R5cGUgPSBfc2VyaWFsaXplci5vcHNbbmFtZV07XG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShfdHlwZSwgXCJVbmtub3duIG9wZXJhdGlvbiBcIiArIG5hbWUpO1xuICAgICAgICB2YXIgb3BlcmF0aW9uX2lkID0gX0NoYWluVHlwZXMyLmRlZmF1bHQub3BlcmF0aW9uc1tfdHlwZS5vcGVyYXRpb25fbmFtZV07XG4gICAgICAgIGlmIChvcGVyYXRpb25faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBvcGVyYXRpb246IFwiICsgX3R5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BlcmF0aW9uLmZlZSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmZlZSA9IHsgYW1vdW50OiAwLCBhc3NldF9pZDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSBcInByb3Bvc2FsX2NyZWF0ZVwiKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBQcm9wb3NhbHMgaW52b2x2aW5nIHRoZSBjb21taXR0ZWUgYWNjb3VudCByZXF1aXJlIGEgcmV2aWV3XG4gICAgICAgICAgICAqIHBlcmlvZCB0byBiZSBzZXQsIGxvb2sgZm9yIHRoZW0gaGVyZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciByZXF1aXJlc1JldmlldyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4dHJhUmV2aWV3ID0gMDtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5wcm9wb3NlZF9vcHMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgQ09NTUlUVEVfQUNDT1VOVCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3Aub3BbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiZnJvbVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiAvL2FjY291bnRfdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NldF9zZXR0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiYWNjb3VudFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gYXNzZXRfY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIGFzc2V0X3VwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBhc3NldF91cGRhdGVfYml0YXNzZXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogLy8gYXNzZXRfdXBkYXRlX2ZlZWRfcHJvZHVjZXJzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGFzc2V0X2lzc3VlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIGFzc2V0X2dsb2JhbF9zZXR0bGVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2V0X2NsYWltX2ZlZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiaXNzdWVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzZXRfcmVzZXJ2ZVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJwYXllclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2V0X2Z1bmRfZmVlX3Bvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiZnJvbV9hY2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBwcm9wb3NhbF9jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzogLy8gcHJvcG9zYWxfdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wb3NhbF9kZWxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IFwiZmVlX3BheWluZ19hY2NvdW50XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVzUmV2aWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUmV2aWV3ID0gNjAgKiA2MCAqIDI0ICogMTM7IC8vIE1ha2UgdGhlIHJldmlldyBwZXJpb2QgMiB3ZWVrcyB0b3RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb3Aub3BbMV0gJiYgb3Aub3BbMV1ba2V5XSA9PT0gQ09NTUlUVEVfQUNDT1VOVCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlc1JldmlldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lIHx8IChvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lID0gYmFzZV9leHBpcmF0aW9uX3NlYygpICsgX2JpdHNoYXJlc2pzV3MuQ2hhaW5Db25maWcuZXhwaXJlX2luX3NlY3NfcHJvcG9zYWwpO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVzUmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnJldmlld19wZXJpb2Rfc2Vjb25kcyA9IGV4dHJhUmV2aWV3ICsgTWF0aC5tYXgoY29tbWl0dGVlX21pbl9yZXZpZXcsIDI0ICogNjAgKiA2MCB8fCBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5yZXZpZXdfaW5fc2Vjc19jb21taXR0ZWUpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgKiBFeHBpcmF0aW9uIHRpbWUgbXVzdCBiZSBhdCBsZWFzdCBlcXVhbCB0b1xuICAgICAgICAgICAgICAgICogbm93ICsgcmV2aWV3X3BlcmlvZF9zZWNvbmRzLCBzbyB3ZSBhZGQgb25lIGhvdXIgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lICs9IDYwICogNjAgKyBleHRyYVJldmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uX2luc3RhbmNlID0gX3R5cGUuZnJvbU9iamVjdChvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm4gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uX2luc3RhbmNlXTtcbiAgICB9O1xuXG4gICAgLyogb3B0aW9uYWw6IGZldGNoIHRoZSBjdXJyZW50IGhlYWQgYmxvY2sgKi9cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUudXBkYXRlX2hlYWRfYmxvY2sgPSBmdW5jdGlvbiB1cGRhdGVfaGVhZF9ibG9jaygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9vYmplY3RzXCIsIFtbXCIyLjAuMFwiXV0pLCBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9vYmplY3RzXCIsIFtbXCIyLjEuMFwiXV0pXSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB2YXIgZyA9IHJlc1swXSxcbiAgICAgICAgICAgICAgICByID0gcmVzWzFdO1xuXG4gICAgICAgICAgICBoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nID0gclswXS50aW1lO1xuICAgICAgICAgICAgY29tbWl0dGVlX21pbl9yZXZpZXcgPSBnWzBdLnBhcmFtZXRlcnMuY29tbWl0dGVlX3Byb3Bvc2FsX3Jldmlld19wZXJpb2Q7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiogb3B0aW9uYWw6IHRoZXJlIGlzIGEgZGVhZnVsdCBleHBpcmF0aW9uICovXG5cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0X2V4cGlyZV9zZWNvbmRzID0gZnVuY3Rpb24gc2V0X2V4cGlyZV9zZWNvbmRzKHNlYykge1xuICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBzZWM7XG4gICAgfTtcblxuICAgIC8qIFdyYXBzIHRoaXMgdHJhbnNhY3Rpb24gaW4gYSBwcm9wb3NhbF9jcmVhdGUgdHJhbnNhY3Rpb24gKi9cblxuXG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyLnByb3RvdHlwZS5wcm9wb3NlID0gZnVuY3Rpb24gcHJvcG9zZShwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkIG9wZXJhdGlvbiBmaXJzdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucywgXCJwcm9wb3NhbF9jcmVhdGVfb3B0aW9uc1wiKTtcbiAgICAgICAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKHByb3Bvc2FsX2NyZWF0ZV9vcHRpb25zLmZlZV9wYXlpbmdfYWNjb3VudCwgXCJwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucy5mZWVfcGF5aW5nX2FjY291bnRcIik7XG5cbiAgICAgICAgdmFyIHByb3Bvc2VkX29wcyA9IHRoaXMub3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcDogb3AgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMgPSBbXTtcbiAgICAgICAgcHJvcG9zYWxfY3JlYXRlX29wdGlvbnMucHJvcG9zZWRfb3BzID0gcHJvcG9zZWRfb3BzO1xuICAgICAgICB0aGlzLmFkZF90eXBlX29wZXJhdGlvbihcInByb3Bvc2FsX2NyZWF0ZVwiLCBwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLmhhc19wcm9wb3NlZF9vcGVyYXRpb24gPSBmdW5jdGlvbiBoYXNfcHJvcG9zZWRfb3BlcmF0aW9uKCkge1xuICAgICAgICB2YXIgaGFzUHJvcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wZXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcInByb3Bvc2VkX29wc1wiIGluIHRoaXMub3BlcmF0aW9uc1tpXVsxXSkge1xuICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNQcm9wb3NlZDtcbiAgICB9O1xuXG4gICAgLyoqIG9wdGlvbmFsOiB0aGUgZmVlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgd2l0bmVzcyBub2RlICovXG5cblxuICAgIFRyYW5zYWN0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0X3JlcXVpcmVkX2ZlZXMgPSBmdW5jdGlvbiBzZXRfcmVxdWlyZWRfZmVlcyhhc3NldF9pZCwgcmVtb3ZlRHVwbGljYXRlcykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkIG9wZXJhdGlvbnMgZmlyc3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1Byb3Bvc2FsKG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BbMF0gPT09IDIyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHByb3Bvc2VkX29wcyA9IFtdO1xuICAgICAgICB2YXIgZmVlQXNzZXRzID0gW107XG4gICAgICAgIHZhciBwcm9wb3NhbEZlZUFzc2V0cyA9IFtdO1xuICAgICAgICB2YXIgcG90ZW50aWFsRHVwbGljYXRlcyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBnZXREdXBsaWNhdGVPcmlnaW5hbEluZGV4KG9wLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldE9wZXJhdGlvbktleShvcCk7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlID0gcG90ZW50aWFsRHVwbGljYXRlc1trZXldO1xuICAgICAgICAgICAgaWYgKCEhZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZS5vcmlnaW5hbCA9PT0gaW5kZXgpIHJldHVybiBpbmRleDtlbHNlIGlmIChkdXBsaWNhdGUuZHVwbGljYXRlcy5pbmRleE9mKGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZS5vcmlnaW5hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uS2V5KG9wKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZW1vRHVtbXkgPSBuZXcgQXJyYXkob3BbMV0ubWVtby5tZXNzYWdlLmxlbmd0aCArIDEpLmpvaW4oXCJhXCIpO1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvcFswXSArIFwiX1wiICsgb3BbMV0uYW1vdW50LmFzc2V0X2lkICsgXCJfXCIgKyBtZW1vRHVtbXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBvcDsgaSA8IHRoaXMub3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3AgPSB0aGlzLm9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgb3BPYmplY3QgPSBfc2VyaWFsaXplci5vcHMub3BlcmF0aW9uLnRvT2JqZWN0KG9wKTtcbiAgICAgICAgICAgIHZhciBpc0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHJlbW92ZUR1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0T3BlcmF0aW9uS2V5KG9wT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG90ZW50aWFsRHVwbGljYXRlc1trZXldKSBwb3RlbnRpYWxEdXBsaWNhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxEdXBsaWNhdGVzW2tleV0uZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICogSWYgdGhlIG9wZXJhdGlvbiBjcmVhdGVzIGEgcHJvcG9zYWwsIHdlIHNob3VsZCBjaGVjayB0aGUgZmVlIHBvb2xcbiAgICAgICAgICAgICogb2YgdGhlIHN1Z2dlc3RlZCBwcm9wb3NhbCBmZWUgYXNzZXRzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSBjcmVhdGluZ1xuICAgICAgICAgICAgKiBwcm9wb3NhbHMgdGhhdCB3aWxsIG1vc3QgbGlrZWx5IGZhaWwgZHVlIHRvIGVtcHR5IGZlZSBwb29sc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1Byb3Bvc2FsKG9wKSkge1xuICAgICAgICAgICAgICAgIG9wWzFdLnByb3Bvc2VkX29wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicHJvcG9zZWQgb3BcIiwgcHJvcC5vcFsxXS5mZWUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wb3NlZF9vcHMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Bvc2FsRmVlQXNzZXRzLmluZGV4T2YocHJvcC5vcFsxXS5mZWUuYXNzZXRfaWQpID09PSAtMSkgcHJvcG9zYWxGZWVBc3NldHMucHVzaChcIjEuMy5cIiArIHByb3Aub3BbMV0uZmVlLmFzc2V0X2lkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2gob3BPYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChmZWVBc3NldHMuaW5kZXhPZihvcGVyYXRpb25zW2ldWzFdLmZlZS5hc3NldF9pZCkgPT09IC0xKSBmZWVBc3NldHMucHVzaChvcGVyYXRpb25zW2ldWzFdLmZlZS5hc3NldF9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFzc2V0X2lkKSB7XG4gICAgICAgICAgICB2YXIgb3AxX2ZlZSA9IG9wZXJhdGlvbnNbMF1bMV0uZmVlO1xuICAgICAgICAgICAgaWYgKG9wMV9mZWUgJiYgb3AxX2ZlZS5hc3NldF9pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFzc2V0X2lkID0gb3AxX2ZlZS5hc3NldF9pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXRfaWQgPSBcIjEuMy4wXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChQcm9taXNlLmFsbChmZWVBc3NldHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9iaXRzaGFyZXNqc1dzLkFwaXMuaW5zdGFuY2UoKS5kYl9hcGkoKS5leGVjKFwiZ2V0X3JlcXVpcmVkX2ZlZXNcIiwgW29wZXJhdGlvbnMsIGlkXSk7XG4gICAgICAgIH0pKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZ2V0X3JlcXVpcmVkX2ZlZXMgQVBJIGVycm9yOiBcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgKiBBZGQgdGhlIHByb3Bvc2FsIGZlZSBhc3NldCBpZHMgdG8gZmVlQXNzZXRzIGhlcmUgdG8gZmV0Y2ggdGhlaXJcbiAgICAgICAgKiBkeW5hbWljIG9iamVjdHMgd2l0aG91dCBjYWxsaW5nIGdldF9yZXF1aXJlZF9mZWVzIHdpdGggdGhlbSBhcyB3ZWxsXG4gICAgICAgICovXG4gICAgICAgIGlmIChwcm9wb3NhbEZlZUFzc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByb3Bvc2FsRmVlQXNzZXRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZlZUFzc2V0cy5pbmRleE9mKGlkKSA9PT0gLTEpIGZlZUFzc2V0cy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZlZUFzc2V0cy5sZW5ndGggPiAxIHx8IGZlZUFzc2V0c1swXSAhPT0gXCIxLjMuMFwiKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBJZiB3ZSdyZSBwYXlpbmcgd2l0aCBhbnkgYXNzZXRzIG90aGVyIHRoYW4gQ09SRSwgd2UgbmVlZCB0byBmZXRjaFxuICAgICAgICAgICAgKiB0aGUgZHluYW1pYyBhc3NldCBvYmplY3QgYW5kIGNoZWNrIHRoZSBmZWUgcG9vbCBvZiB0aG9zZSBhc3NldHMuXG4gICAgICAgICAgICAqIFRoZSBkeW5hbWljIGFzc2V0IG9iamVjdCBpZCBpcyBlcXVhbCB0byB0aGUgYXNzZXQgaWQgYnV0IHdpdGhcbiAgICAgICAgICAgICogMi4zLnggaW5zdGVhZCBvZiAxLjMueFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBkeW5hbWljT2JqZWN0SWRzID0gZmVlQXNzZXRzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJlcGxhY2UoL14xXFwuLywgXCIyLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9yZXF1aXJlZF9mZWVzXCIsIFtvcGVyYXRpb25zLCBcIjEuMy4wXCJdKSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKF9iaXRzaGFyZXNqc1dzLkFwaXMuaW5zdGFuY2UoKS5kYl9hcGkoKS5leGVjKFwiZ2V0X29iamVjdHNcIiwgW2R5bmFtaWNPYmplY3RJZHNdKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIGFsbEZlZXMgYW5kIGNvcmVGZWVzIGFyZSBhcnJheXMgY29udGFpbmcgZmVlIGFtb3VudHMgZ3JvdXBlZCBieVxuICAgICAgICAgICAgKiBhc3NldCBhbmQgZm9yIGVhY2ggb3BlcmF0aW9uIGluIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYWxsRmVlcyA9IHJlc3VsdHNbMF0sXG4gICAgICAgICAgICAgICAgY29yZUZlZXMgPSByZXN1bHRzWzFdLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNPYmplY3RzID0gcmVzdWx0c1syXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIElmIG9uZSBvZiB0aGUgZGVzaXJlZCBmZWUgYXNzZXRzIGhhcyBhbiBpbnZhbGlkIGNvcmUgZXhjaGFuZ2UgcmF0ZVxuICAgICAgICAgICAgKiBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyB3aWxsIGZhaWwgYW5kIHRoZSByZXN1bHQgZm9yIGFsbCBhc3NldHNcbiAgICAgICAgICAgICogd2lsbCBiZSB1bmRlZmluZWQsIGlmIHNvIHdlIGp1c3QgZGVmYXVsdCB0byBjb3JlRmVlc1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgaWYgKGFsbEZlZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsbEZlZXMgPSBjb3JlRmVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIElmIHRoZSBvbmx5IGRlc2lyZWQgZmVlIGFzc2V0IGlzIENPUkUsIGNvcmVGZWVzIGFyZSBub3QgZmV0Y2hlZFxuICAgICAgICAgICAgKiBidXQgYXJlIGVxdWFsIHRvIGFsbEZlZXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWNvcmVGZWVzKSB7XG4gICAgICAgICAgICAgICAgY29yZUZlZXMgPSBhbGxGZWVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBDcmVhdGUgYSBtYXAgb2YgZmVlcyBhbmQgcHJvcG9zYWwgZmVlcyBieSBhc3NldCBpZCAqL1xuICAgICAgICAgICAgdmFyIGZlZXNCeUFzc2V0ID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWxGZWVzQnlBc3NldCA9IHt9O1xuICAgICAgICAgICAgYWxsRmVlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWVTZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRGZWVTZXQgPSBmZWVTZXQubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9wZXJhdGlvbiBpbmNsdWRlcyBhIHByb3Bvc2FsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbEZlZXNCeUFzc2V0W2ZbMV1bMF0uYXNzZXRfaWRdID0gZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QXNzZXRJZCA9IGZpbHRlcmVkRmVlU2V0WzBdLmFzc2V0X2lkO1xuXG4gICAgICAgICAgICAgICAgZmVlc0J5QXNzZXRbY3VycmVudEFzc2V0SWRdID0gZmlsdGVyZWRGZWVTZXQ7XG4gICAgICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgICAgIC8qIENyZWF0ZSBhIG1hcCBvZiBmZWUgcG9vbHMgYnkgYXNzZXQgaWQqL1xuICAgICAgICAgICAgdmFyIGZlZVBvb2xNYXAgPSAhIWR5bmFtaWNPYmplY3RzID8gZHluYW1pY09iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIG1hcFtvYmplY3QuaWQucmVwbGFjZSgvXjJcXC4vLCBcIjEuXCIpXSA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwge30pIDoge307XG5cbiAgICAgICAgICAgIHZhciBmZWVNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbEZlZU1hcCA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRmVlTWFwKG1hcCwgYXNzZXRfaWQsIG9wSW5kZXgsIGNvcmVfZmVlcykge1xuICAgICAgICAgICAgICAgIGlmICghbWFwW2Fzc2V0X2lkXSkgbWFwW2Fzc2V0X2lkXSA9IHsgdG90YWw6IDAsIG9wczogW10gfTtcbiAgICAgICAgICAgICAgICBpZiAobWFwW2Fzc2V0X2lkXS5wcm9wSWR4KSBtYXBbYXNzZXRfaWRdLnByb3BJZHgucHVzaChvcEluZGV4KTtlbHNlIG1hcFthc3NldF9pZF0ub3BzLnB1c2gob3BJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXRfaWQgIT09IFwiMS4zLjBcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXBbYXNzZXRfaWRdLnRvdGFsICs9IGNvcmVfZmVlcy5sZW5ndGggPyBjb3JlX2ZlZXNbb3BJbmRleF0uYW1vdW50IDogY29yZV9mZWVzLmFtb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wID0gb3BlcmF0aW9uc1tfaTNdO1xuICAgICAgICAgICAgICAgIHZhciBmZWVBc3NldElkID0gb3BbMV0uZmVlLmFzc2V0X2lkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvcG9zYWwob3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZU1hcCA9IHVwZGF0ZUZlZU1hcChmZWVNYXAsIGZlZUFzc2V0SWQsIF9pMywgY29yZUZlZXNbX2kzXVswXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3BbMV0ucHJvcG9zZWRfb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wRmVlQXNzZXQgPSBwcm9wLm9wWzFdLmZlZS5hc3NldF9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcG9zYWxGZWVNYXBbX2kzXSkgcHJvcG9zYWxGZWVNYXBbX2kzXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wb3NhbEZlZU1hcFtfaTNdW3Byb3BGZWVBc3NldF0pIHByb3Bvc2FsRmVlTWFwW19pM11bcHJvcEZlZUFzc2V0XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtfaTNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BJZHg6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbEZlZU1hcFtfaTNdID0gdXBkYXRlRmVlTWFwKHByb3Bvc2FsRmVlTWFwW19pM10sIHByb3BGZWVBc3NldCwgeSwgY29yZUZlZXNbX2kzXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZU1hcCA9IHVwZGF0ZUZlZU1hcChmZWVNYXAsIGZlZUFzc2V0SWQsIF9pMywgY29yZUZlZXNbX2kzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgb3BlcmF0aW9ucy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AoX2kzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogQ2hlY2sgZmVlIHBvb2wgYmFsYW5jZXMgZm9yIHJlZ3VsYXIgb3BzICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1Bvb2xCYWxhbmNlKG1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMobWFwKS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxfZmVlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihhc3NldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVlUG9vbCA9IGZlZVBvb2xNYXBbYXNzZXRdID8gcGFyc2VJbnQoZmVlUG9vbE1hcFthc3NldF0uZmVlX3Bvb2wsIDEwKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIC8qIEZlZSBwb29sIGJhbGFuY2UgaW5zdWZmaWNpZW50LCBkZWZhdWx0IHRvIGNvcmUqL1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwW2Fzc2V0XS50b3RhbCA+IGZlZVBvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFthc3NldF0ub3BzLmZvckVhY2goZnVuY3Rpb24gKG9wSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZUZlZXNbb3BJbmRleF0ubGVuZ3RoID09PSAyICYmIFwicHJvcElkeFwiIGluIG1hcFthc3NldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogUHJvcG9zYWwgb3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW2Fzc2V0XS5wcm9wSWR4LmZvckVhY2goZnVuY3Rpb24gKHByb3BfaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbF9mZWVzW3Byb3BfaWR4XSA9IGNvcmVGZWVzW29wSW5kZXhdWzFdW3Byb3BfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3JlRmVlc1tvcEluZGV4XS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxfZmVlc1tvcEluZGV4XSA9IGNvcmVGZWVzW29wSW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsX2ZlZXNbb3BJbmRleF0gPSBjb3JlRmVlc1tvcEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFVzZSB0aGUgZGVzaXJlZCBmZWUgYXNzZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFthc3NldF0ub3BzLmZvckVhY2goZnVuY3Rpb24gKG9wSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZUZlZXNbb3BJbmRleF0ubGVuZ3RoID09PSAyICYmIFwicHJvcElkeFwiIGluIG1hcFthc3NldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW2Fzc2V0XS5wcm9wSWR4LmZvckVhY2goZnVuY3Rpb24gKHByb3BfaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbF9mZWVzW3Byb3BfaWR4XSA9IHByb3Bvc2FsRmVlc0J5QXNzZXRbYXNzZXRdW3Byb3BfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxfZmVlc1tvcEluZGV4XSA9IGZlZXNCeUFzc2V0W2Fzc2V0XVtvcEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhc3NldCBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3AyKGFzc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsX2ZlZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaW5hbEZlZXMgPSBjaGVja1Bvb2xCYWxhbmNlKGZlZU1hcCk7XG5cbiAgICAgICAgICAgIHZhciBmaW5hbFByb3Bvc2FsRmVlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBwcm9wb3NhbEZlZU1hcCkge1xuICAgICAgICAgICAgICAgIGZpbmFsUHJvcG9zYWxGZWVzW19rZXldID0gY2hlY2tQb29sQmFsYW5jZShwcm9wb3NhbEZlZU1hcFtfa2V5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXRfZmVlID0gZnVuY3Rpb24gc2V0X2ZlZShvcGVyYXRpb24sIG9wSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdGlvbi5mZWUgfHwgb3BlcmF0aW9uLmZlZS5hbW91bnQgPT09IDAgfHwgb3BlcmF0aW9uLmZlZS5hbW91bnQudG9TdHJpbmcgJiYgb3BlcmF0aW9uLmZlZS5hbW91bnQudG9TdHJpbmcoKSA9PT0gXCIwXCIgLy8gTG9uZ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUR1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29wID0gX3NlcmlhbGl6ZXIub3BzLm9wZXJhdGlvbi50b09iamVjdChfdGhpczMub3BlcmF0aW9uc1tvcEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSBnZXREdXBsaWNhdGVPcmlnaW5hbEluZGV4KF9vcCwgb3BJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgZHVwbGljYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5mZWUgPSBmaW5hbEZlZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLmZlZSA9IGZpbmFsRmVlc1tvcEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5mZWUgPSBmaW5hbEZlZXNbb3BJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnByb3Bvc2VkX29wcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICogTG9vcCBvdmVyIHByb3Bvc2VkX29wcyBhbmQgYXNzaWduIGZlZSBhc3NldCBpZHMgYXNcbiAgICAgICAgICAgICAgICAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmZWUgcG9vbCBiYWxhbmNlIGNoZWNrLiBJZiB0aGUgYmFsYW5jZVxuICAgICAgICAgICAgICAgICAgICAqIGlzIHN1ZmZpY2llbnQgdGhlIGFzc2V0X2lkIGlzIGtlcHQsIGlmIG5vdCBpdCBkZWZhdWx0cyB0b1xuICAgICAgICAgICAgICAgICAgICAqIFwiMS4zLjBcIlxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG9wZXJhdGlvbi5wcm9wb3NlZF9vcHMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5wcm9wb3NlZF9vcHNbeV0ub3BbMV0uZmVlLmFzc2V0X2lkID0gZmluYWxQcm9wb3NhbEZlZXNbb3BJbmRleF1beV0uYXNzZXRfaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBXZSBhcHBseSB0aGUgZmluYWwgZmVlcyB0aGUgdGhlIG9wZXJhdGlvbnMgKi9cbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IF90aGlzMy5vcGVyYXRpb25zLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICBzZXRfZmVlKF90aGlzMy5vcGVyYXRpb25zW19pNF1bMV0sIF9pNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCcuLi4gZ2V0X3JlcXVpcmVkX2ZlZXMnLG9wZXJhdGlvbnMsYXNzZXRfaWQsZmxhdF9mZWVzKVxuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcyA9IGZ1bmN0aW9uIGdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpIHtcbiAgICAgICAgdmFyIHRyX29iamVjdCA9IF9zZXJpYWxpemVyLm9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbX2JpdHNoYXJlc2pzV3MuQXBpcy5pbnN0YW5jZSgpLmRiX2FwaSgpLmV4ZWMoXCJnZXRfcG90ZW50aWFsX3NpZ25hdHVyZXNcIiwgW3RyX29iamVjdF0pLCBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9wb3RlbnRpYWxfYWRkcmVzc19zaWduYXR1cmVzXCIsIFt0cl9vYmplY3RdKV0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHB1YmtleXM6IHJlc3VsdHNbMF0sIGFkZHlzOiByZXN1bHRzWzFdIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzID0gZnVuY3Rpb24gZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMoYXZhaWxhYmxlX2tleXMpIHtcbiAgICAgICAgaWYgKCFhdmFpbGFibGVfa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cl9vYmplY3QgPSBfc2VyaWFsaXplci5vcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0Jyx0cl9vYmplY3QpXG4gICAgICAgIHJldHVybiBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhcImdldF9yZXF1aXJlZF9zaWduYXR1cmVzXCIsIFt0cl9vYmplY3QsIGF2YWlsYWJsZV9rZXlzXSkudGhlbihmdW5jdGlvbiAocmVxdWlyZWRfcHVibGljX2tleXMpIHtcbiAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcycscmVxdWlyZWRfcHVibGljX2tleXMpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRfcHVibGljX2tleXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLmFkZF9zaWduZXIgPSBmdW5jdGlvbiBhZGRfc2lnbmVyKHByaXZhdGVfa2V5KSB7XG4gICAgICAgIHZhciBwdWJsaWNfa2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpO1xuXG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShwcml2YXRlX2tleS5kLCBcInJlcXVpcmVkIFByaXZhdGVLZXkgb2JqZWN0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBzaWduZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwdWJsaWNfa2V5LlEpIHtcbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBfZWNjLlB1YmxpY0tleS5mcm9tUHVibGljS2V5U3RyaW5nKHB1YmxpY19rZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICB2YXIgc3BIZXggPSBwcml2YXRlX2tleS50b0hleCgpO1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTUgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICAgIHZhciBfcmVmNDtcblxuICAgICAgICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICAgICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yM1tfaTUrK107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9pNSA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjQgPSBfaTUudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcCA9IF9yZWY0O1xuXG4gICAgICAgICAgICBpZiAoc3BbMF0udG9IZXgoKSA9PT0gc3BIZXgpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMucHVzaChbcHJpdmF0ZV9rZXksIHB1YmxpY19rZXldKTtcbiAgICB9O1xuXG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbigpIHtcbiAgICAgICAgdmFyIGNoYWluX2lkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkuY2hhaW5faWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgc2lnbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gd2FzIG5vdCBzaWduZWQuIERvIHlvdSBoYXZlIGEgcHJpdmF0ZSBrZXk/IFtub19zaWduZXJzXVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBlbmQgPyBpIDwgZW5kIDogaSA+IGVuZDsgMCA8IGVuZCA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgdmFyIF9zaWduZXJfcHJpdmF0ZV9rZXlzJCA9IHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5c1tpXSxcbiAgICAgICAgICAgICAgICBwcml2YXRlX2tleSA9IF9zaWduZXJfcHJpdmF0ZV9rZXlzJFswXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNfa2V5ID0gX3NpZ25lcl9wcml2YXRlX2tleXMkWzFdO1xuXG4gICAgICAgICAgICB2YXIgc2lnID0gX2VjYy5TaWduYXR1cmUuc2lnbkJ1ZmZlcihCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKGNoYWluX2lkLCBcImhleFwiKSwgdGhpcy50cl9idWZmZXJdKSwgcHJpdmF0ZV9rZXksIHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnLnRvQnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25lZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplci5vcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplci5vcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgIH07XG5cbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uIGJyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5fYnJvYWRjYXN0KHdhc19icm9hZGNhc3RfY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlcjtcbn0oKTtcblxudmFyIGJhc2VfZXhwaXJhdGlvbl9zZWMgPSBmdW5jdGlvbiBiYXNlX2V4cGlyYXRpb25fc2VjKCkge1xuICAgIHZhciBoZWFkX2Jsb2NrX3NlYyA9IE1hdGguY2VpbChnZXRIZWFkQmxvY2tEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgdmFyIG5vd19zZWMgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIC8vIFRoZSBoZWFkIGJsb2NrIHRpbWUgc2hvdWxkIGJlIHVwZGF0ZWQgZXZlcnkgMyBzZWNvbmRzLiAgSWYgaXQgaXNuJ3RcbiAgICAvLyB0aGVuIGhlbHAgdGhlIHRyYW5zYWN0aW9uIHRvIGV4cGlyZSAodXNlIGhlYWRfYmxvY2tfc2VjKVxuICAgIGlmIChub3dfc2VjIC0gaGVhZF9ibG9ja19zZWMgPiAzMCkge1xuICAgICAgICByZXR1cm4gaGVhZF9ibG9ja19zZWM7XG4gICAgfVxuICAgIC8vIElmIHRoZSB1c2VyJ3MgY2xvY2sgaXMgdmVyeSBmYXIgYmVoaW5kLCB1c2UgdGhlIGhlYWQgYmxvY2sgdGltZS5cbiAgICByZXR1cm4gTWF0aC5tYXgobm93X3NlYywgaGVhZF9ibG9ja19zZWMpO1xufTtcblxuZnVuY3Rpb24gX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIV90aGlzNS5zaWduZWQpIHtcbiAgICAgICAgICAgIF90aGlzNS5zaWduKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczUudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZmluYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM1LnNpZ25hdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgc2lnbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM1Lm9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBvcGVyYXRpb25zXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyX29iamVjdCA9IF9zZXJpYWxpemVyLm9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QoX3RoaXM1KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBicm9hZGNhc3RfdHJhbnNhY3Rpb25fd2l0aF9jYWxsYmFjayAhISEnKVxuICAgICAgICBfYml0c2hhcmVzanNXcy5BcGlzLmluc3RhbmNlKCkubmV0d29ya19hcGkoKS5leGVjKFwiYnJvYWRjYXN0X3RyYW5zYWN0aW9uX3dpdGhfY2FsbGJhY2tcIiwgW2Z1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcyk7XG4gICAgICAgIH0sIHRyX29iamVjdF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLi4uIGJyb2FkY2FzdCBzdWNjZXNzLCB3YWl0aW5nIGZvciBjYWxsYmFjaycpXG4gICAgICAgICAgICBpZiAod2FzX2Jyb2FkY2FzdF9jYWxsYmFjaykgd2FzX2Jyb2FkY2FzdF9jYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nIG1heSBiZSByZWR1bmRhbnQgZm9yIG5ldHdvcmsgZXJyb3JzLCBvdGhlciBlcnJvcnMgY291bGQgb2NjdXJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtZXNzYWdlICsgXCJcXG5cIiArIFwiYml0c2hhcmVzLWNyeXB0byBcIiArIFwiIGRpZ2VzdCBcIiArIF9lY2MuaGFzaC5zaGEyNTYoX3RoaXM1LnRyX2J1ZmZlcikudG9TdHJpbmcoXCJoZXhcIikgKyBcIiB0cmFuc2FjdGlvbiBcIiArIF90aGlzNS50cl9idWZmZXIudG9TdHJpbmcoXCJoZXhcIikgKyBcIiBcIiArIEpTT04uc3RyaW5naWZ5KHRyX29iamVjdCkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZEJsb2NrRGF0ZSgpIHtcbiAgICByZXR1cm4gdGltZVN0cmluZ1RvRGF0ZShoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gdGltZVN0cmluZ1RvRGF0ZSh0aW1lX3N0cmluZykge1xuICAgIGlmICghdGltZV9zdHJpbmcpIHJldHVybiBuZXcgRGF0ZShcIjE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKTtcbiAgICBpZiAoIS9aJC8udGVzdCh0aW1lX3N0cmluZykpXG4gICAgICAgIC8vZG9lcyBub3QgZW5kIGluIFpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b25vbWV4L2dyYXBoZW5lL2lzc3Vlcy8zNjhcbiAgICAgICAgdGltZV9zdHJpbmcgPSB0aW1lX3N0cmluZyArIFwiWlwiO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lX3N0cmluZyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uQnVpbGRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gc3RhdGVba2V5XSB8fCBcIlwiO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy5zZXQgPSBzZXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmtleSA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnJhaW5LZXkgPSBleHBvcnRzLlNpZ25hdHVyZSA9IGV4cG9ydHMuUHVibGljS2V5ID0gZXhwb3J0cy5Qcml2YXRlS2V5ID0gZXhwb3J0cy5BZXMgPSBleHBvcnRzLkFkZHJlc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfYWRkcmVzcyA9IHJlcXVpcmUoXCIuL3NyYy9hZGRyZXNzXCIpO1xuXG52YXIgX2FkZHJlc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkcmVzcyk7XG5cbnZhciBfYWVzID0gcmVxdWlyZShcIi4vc3JjL2Flc1wiKTtcblxudmFyIF9hZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWVzKTtcblxudmFyIF9Qcml2YXRlS2V5ID0gcmVxdWlyZShcIi4vc3JjL1ByaXZhdGVLZXlcIik7XG5cbnZhciBfUHJpdmF0ZUtleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcml2YXRlS2V5KTtcblxudmFyIF9QdWJsaWNLZXkgPSByZXF1aXJlKFwiLi9zcmMvUHVibGljS2V5XCIpO1xuXG52YXIgX1B1YmxpY0tleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QdWJsaWNLZXkpO1xuXG52YXIgX3NpZ25hdHVyZSA9IHJlcXVpcmUoXCIuL3NyYy9zaWduYXR1cmVcIik7XG5cbnZhciBfc2lnbmF0dXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NpZ25hdHVyZSk7XG5cbnZhciBfQnJhaW5LZXkgPSByZXF1aXJlKFwiLi9zcmMvQnJhaW5LZXlcIik7XG5cbnZhciBfQnJhaW5LZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQnJhaW5LZXkpO1xuXG52YXIgX2hhc2ggPSByZXF1aXJlKFwiLi9zcmMvaGFzaFwiKTtcblxudmFyIGhhc2ggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGFzaCk7XG5cbnZhciBfS2V5VXRpbHMgPSByZXF1aXJlKFwiLi9zcmMvS2V5VXRpbHNcIik7XG5cbnZhciBfS2V5VXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfS2V5VXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLkFkZHJlc3MgPSBfYWRkcmVzczIuZGVmYXVsdDtcbmV4cG9ydHMuQWVzID0gX2FlczIuZGVmYXVsdDtcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IF9Qcml2YXRlS2V5Mi5kZWZhdWx0O1xuZXhwb3J0cy5QdWJsaWNLZXkgPSBfUHVibGljS2V5Mi5kZWZhdWx0O1xuZXhwb3J0cy5TaWduYXR1cmUgPSBfc2lnbmF0dXJlMi5kZWZhdWx0O1xuZXhwb3J0cy5icmFpbktleSA9IF9CcmFpbktleTIuZGVmYXVsdDtcbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5leHBvcnRzLmtleSA9IF9LZXlVdGlsczIuZGVmYXVsdDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBub3JtYWxpemU7XG5mdW5jdGlvbiBub3JtYWxpemUoYnJhaW5LZXkpIHtcbiAgICBpZiAodHlwZW9mIGJyYWluS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGJyYWluS2V5XCIpO1xuICAgIH1cbiAgICBicmFpbktleSA9IGJyYWluS2V5LnRyaW0oKTtcbiAgICByZXR1cm4gYnJhaW5LZXkuc3BsaXQoL1tcXHRcXG5cXHZcXGZcXHIgXSsvKS5qb2luKCcgJyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vUHJpdmF0ZUtleScpO1xuXG52YXIgX1ByaXZhdGVLZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJpdmF0ZUtleSk7XG5cbnZhciBfUHVibGljS2V5ID0gcmVxdWlyZSgnLi9QdWJsaWNLZXknKTtcblxudmFyIF9QdWJsaWNLZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibGljS2V5KTtcblxudmFyIF9hZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG5cbnZhciBfYWRkcmVzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRyZXNzKTtcblxudmFyIF9hZXMgPSByZXF1aXJlKCcuL2FlcycpO1xuXG52YXIgX2FlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZXMpO1xuXG52YXIgX2hhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIF9zZWN1cmVSYW5kb20gPSByZXF1aXJlKCdzZWN1cmUtcmFuZG9tJyk7XG5cbnZhciBfc2VjdXJlUmFuZG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlY3VyZVJhbmRvbSk7XG5cbnZhciBfYml0c2hhcmVzanNXcyA9IHJlcXVpcmUoJ2JpdHNoYXJlc2pzLXdzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGhhc2ggZm9yIC4yNSBzZWNvbmRcblxuLy8gaW1wb3J0IGRpY3Rpb25hcnkgZnJvbSAnLi9kaWN0aW9uYXJ5X2VuJztcbnZhciBIQVNIX1BPV0VSX01JTExTID0gMjUwO1xuXG52YXIga2V5ID0ge1xuXG4gICAgLyoqIFVzZXMgMSBzZWNvbmQgb2YgaGFzaGluZyBwb3dlciB0byBjcmVhdGUgYSBrZXkvcGFzc3dvcmQgY2hlY2tzdW0uICBBblxuICAgIGltcGxlbWVudGF0aW9uIGNhbiByZS1jYWxsIHRoaXMgbWV0aG9kIHdpdGggdGhlIHNhbWUgcGFzc3dvcmQgdG8gcmUtbWF0Y2hcbiAgICB0aGUgc3RyZW5ndGggb2YgdGhlIENQVSAoZWl0aGVyIGFmdGVyIG1vdmluZyBmcm9tIGEgZGVza3RvcCB0byBhIG1vYmlsZSxcbiAgICBtb2JpbGUgdG8gZGVza3RvcCwgb3IgTiB5ZWFycyBmcm9tIG5vdyB3aGVuIENQVXMgYXJlIHByZXN1bWFibHkgc3Ryb25nZXIpLlxuICAgICBBIHNhbHQgaXMgdXNlZCBmb3IgYWxsIHRoZSBub3JtYWwgcmVhc29ucy4uLlxuICAgICBAcmV0dXJuIG9iamVjdCB7XG4gICAgICAgIGFlc19wcml2YXRlOiBBZXMsXG4gICAgICAgIGNoZWNrc3VtOiBcIntoYXNoX2l0ZXJhdGlvbl9jb3VudH0se3NhbHR9LHtjaGVja3N1bX1cIlxuICAgIH1cbiAgICAqL1xuICAgIGFlc19jaGVja3N1bTogZnVuY3Rpb24gYWVzX2NoZWNrc3VtKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBcInBhc3N3b3JkIHN0cmluZyByZXF1aXJlZFwiKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbHQgPSBfc2VjdXJlUmFuZG9tMi5kZWZhdWx0LnJhbmRvbUJ1ZmZlcig0KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIHNlY3JldCA9IHNhbHQgKyBwYXNzd29yZDtcbiAgICAgICAgLy8gaGFzaCBmb3IgLjEgc2Vjb25kXG4gICAgICAgIHZhciBzdGFydF90ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgc2VjcmV0ID0gKDAsIF9oYXNoLnNoYTI1Nikoc2VjcmV0KTtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja3N1bSA9ICgwLCBfaGFzaC5zaGEyNTYpKHNlY3JldCk7XG4gICAgICAgIHZhciBjaGVja3N1bV9zdHJpbmcgPSBbaXRlcmF0aW9ucywgc2FsdC50b1N0cmluZygnaGV4JyksIGNoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignLCcpO1xuXG4gICAgICAgIHJldHVybiB7IGFlc19wcml2YXRlOiBfYWVzMi5kZWZhdWx0LmZyb21TZWVkKHNlY3JldCksXG4gICAgICAgICAgICBjaGVja3N1bTogY2hlY2tzdW1fc3RyaW5nXG4gICAgICAgIH07XG4gICAgfSxcblxuXG4gICAgLyoqIFByb3ZpZGUgYSBtYXRjaGluZyBwYXNzd29yZCBhbmQga2V5X2NoZWNrc3VtLiAgQSBcIndyb25nIHBhc3N3b3JkXCJcbiAgICBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHBhc3N3b3JkIGRvZXMgbm90IG1hdGNoLiAgSWYgdGhpcyBtZXRob2QgdGFrZXNcbiAgICBtdWNoIG1vcmUgb3IgbGVzcyB0aGFuIDEgc2Vjb25kIHRvIHJldHVybiwgb25lIHNob3VsZCBjb25zaWRlciB1cGRhdGluZ1xuICAgIGFsbCBlbmN5cnB0ZWQgZmllbGRzIHVzaW5nIGEgbmV3IGtleS5rZXlfY2hlY2tzdW0uXG4gICAgKi9cbiAgICBhZXNfcHJpdmF0ZTogZnVuY3Rpb24gYWVzX3ByaXZhdGUocGFzc3dvcmQsIGtleV9jaGVja3N1bSkge1xuICAgICAgICB2YXIgX2tleV9jaGVja3N1bSRzcGxpdCA9IGtleV9jaGVja3N1bS5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgaXRlcmF0aW9ucyA9IF9rZXlfY2hlY2tzdW0kc3BsaXRbMF0sXG4gICAgICAgICAgICBzYWx0ID0gX2tleV9jaGVja3N1bSRzcGxpdFsxXSxcbiAgICAgICAgICAgIGNoZWNrc3VtID0gX2tleV9jaGVja3N1bSRzcGxpdFsyXTtcblxuICAgICAgICB2YXIgc2VjcmV0ID0gc2FsdCArIHBhc3N3b3JkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGl0ZXJhdGlvbnMgPyBpIDwgaXRlcmF0aW9ucyA6IGkgPiBpdGVyYXRpb25zOyAwIDwgaXRlcmF0aW9ucyA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgc2VjcmV0ID0gKDAsIF9oYXNoLnNoYTI1Nikoc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gKDAsIF9oYXNoLnNoYTI1Nikoc2VjcmV0KTtcbiAgICAgICAgaWYgKCEobmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY2hlY2tzdW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBwYXNzd29yZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FlczIuZGVmYXVsdC5mcm9tU2VlZChzZWNyZXQpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAgICBBIHdlZWsgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgY2FuIHJ1biBvdXQgb2YgZW50cm9weS4gIFRoaXMgc2hvdWxkIGVuc3VyZSBldmVuIHRoZSB3b3JzdCByYW5kb20gbnVtYmVyIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgcmVhc29uYWJseSBzYWZlLlxuICAgICAgICAgQHBhcmFtMSBzdHJpbmcgZW50cm9weSBvZiBhdCBsZWFzdCAzMiBieXRlc1xuICAgICovXG4gICAgcmFuZG9tMzJCeXRlQnVmZmVyOiBmdW5jdGlvbiByYW5kb20zMkJ5dGVCdWZmZXIoKSB7XG4gICAgICAgIHZhciBlbnRyb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmJyb3dzZXJFbnRyb3B5KCk7XG5cblxuICAgICAgICBpZiAoISh0eXBlb2YgZW50cm9weSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cm9weS5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIGF0IGxlYXN0IDMyIGJ5dGVzIG9mIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRfdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgZW50cm9weSA9ICgwLCBfaGFzaC5zaGEyNTYpKGVudHJvcHkpO1xuICAgICAgICB9dmFyIGhhc2hfYXJyYXkgPSBbXTtcbiAgICAgICAgaGFzaF9hcnJheS5wdXNoKGVudHJvcHkpO1xuXG4gICAgICAgIC8vIEhhc2hpbmcgZm9yIDEgc2Vjb25kIG1heSBoZWxwcyB0aGUgY29tcHV0ZXIgaXMgbm90IGxvdyBvbiBlbnRyb3B5ICh0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJhY2stdG8tYmFjaykuXG4gICAgICAgIGhhc2hfYXJyYXkucHVzaChfc2VjdXJlUmFuZG9tMi5kZWZhdWx0LnJhbmRvbUJ1ZmZlcigzMikpO1xuXG4gICAgICAgIHJldHVybiAoMCwgX2hhc2guc2hhMjU2KShCdWZmZXIuY29uY2F0KGhhc2hfYXJyYXkpKTtcbiAgICB9LFxuXG5cbiAgICBzdWdnZXN0X2JyYWluX2tleTogZnVuY3Rpb24gc3VnZ2VzdF9icmFpbl9rZXkoKSB7XG4gICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIixcIjtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuYnJvd3NlckVudHJvcHkoKTtcblxuXG4gICAgICAgIHZhciByYW5kb21CdWZmZXIgPSB0aGlzLnJhbmRvbTMyQnl0ZUJ1ZmZlcihlbnRyb3B5KTtcblxuICAgICAgICB2YXIgd29yZF9jb3VudCA9IDE2O1xuICAgICAgICB2YXIgZGljdGlvbmFyeV9saW5lcyA9IGRpY3Rpb25hcnkuc3BsaXQoJywnKTtcblxuICAgICAgICBpZiAoIShkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCA9PT0gNDk3NDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyAnICsgNDk3NDQgKyAnIGJ1dCBnb3QgJyArIGRpY3Rpb25hcnlfbGluZXMubGVuZ3RoICsgJyBkaWN0aW9uYXJ5IHdvcmRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnJhaW5rZXkgPSBbXTtcbiAgICAgICAgdmFyIGVuZCA9IHdvcmRfY291bnQgKiAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpICs9IDIpIHtcblxuICAgICAgICAgICAgLy8gcmFuZG9tQnVmZmVyIGhhcyAyNTYgYml0cyAvIDE2IGJpdHMgcGVyIHdvcmQgPT0gMTYgd29yZHNcbiAgICAgICAgICAgIHZhciBudW0gPSAocmFuZG9tQnVmZmVyW2ldIDw8IDgpICsgcmFuZG9tQnVmZmVyW2kgKyAxXTtcblxuICAgICAgICAgICAgLy8gY29udmVydCBpbnRvIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSAoaW5jbHVzaXZlKVxuICAgICAgICAgICAgdmFyIHJuZE11bHRpcGxpZXIgPSBudW0gLyBNYXRoLnBvdygyLCAxNik7XG4gICAgICAgICAgICB2YXIgd29yZEluZGV4ID0gTWF0aC5yb3VuZChkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCAqIHJuZE11bHRpcGxpZXIpO1xuXG4gICAgICAgICAgICBicmFpbmtleS5wdXNoKGRpY3Rpb25hcnlfbGluZXNbd29yZEluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplX2JyYWluS2V5KGJyYWlua2V5LmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIGdldF9yYW5kb21fa2V5OiBmdW5jdGlvbiBnZXRfcmFuZG9tX2tleShlbnRyb3B5KSB7XG4gICAgICAgIHJldHVybiBfUHJpdmF0ZUtleTIuZGVmYXVsdC5mcm9tQnVmZmVyKHRoaXMucmFuZG9tMzJCeXRlQnVmZmVyKGVudHJvcHkpKTtcbiAgICB9LFxuICAgIGdldF9icmFpblByaXZhdGVLZXk6IGZ1bmN0aW9uIGdldF9icmFpblByaXZhdGVLZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICAgIGlmIChzZXF1ZW5jZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2VxdWVuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJhaW5LZXkgPSBrZXkubm9ybWFsaXplX2JyYWluS2V5KGJyYWluS2V5KTtcbiAgICAgICAgcmV0dXJuIF9Qcml2YXRlS2V5Mi5kZWZhdWx0LmZyb21CdWZmZXIoKDAsIF9oYXNoLnNoYTI1NikoKDAsIF9oYXNoLnNoYTUxMikoYnJhaW5LZXkgKyBcIiBcIiArIHNlcXVlbmNlKSkpO1xuICAgIH0sXG5cblxuICAgIC8vIFR1cm4gaW52aXNpYmxlIHNwYWNlIGxpa2UgY2hhcmFjdGVycyBpbnRvIGEgc2luZ2xlIHNwYWNlXG4gICAgbm9ybWFsaXplX2JyYWluS2V5OiBmdW5jdGlvbiBub3JtYWxpemVfYnJhaW5LZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGJyYWluS2V5ID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgYnJhaW5LZXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmFpbktleSA9IGJyYWluS2V5LnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGJyYWluS2V5LnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xuICAgIH0sXG4gICAgYnJvd3NlckVudHJvcHk6IGZ1bmN0aW9uIGJyb3dzZXJFbnRyb3B5KCkge1xuXG4gICAgICAgIHZhciBlbnRyb3B5U3RyID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLndpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmNvbG9yRGVwdGggKyBcIiBcIiArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLnBpeGVsRGVwdGggKyBuYXZpZ2F0b3IubGFuZ3VhZ2UgKyBcIiBcIiArIHdpbmRvdy5sb2NhdGlvbiArIFwiIFwiICsgd2luZG93Lmhpc3RvcnkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWltZVR5cGU7IGkgPCBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWltZVR5cGUgPSBuYXZpZ2F0b3IubWltZVR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGVudHJvcHlTdHIgKz0gbWltZVR5cGUuZGVzY3JpcHRpb24gKyBcIiBcIiArIG1pbWVUeXBlLnR5cGUgKyBcIiBcIiArIG1pbWVUeXBlLnN1ZmZpeGVzICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk9cXHRicm93c2VyRW50cm9weSBnYXRoZXJlZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vbm9kZWpzOlJlZmVyZW5jZUVycm9yOiB3aW5kb3cgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSAoMCwgX2hhc2guc2hhMjU2KShuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBuZXcgQnVmZmVyKGVudHJvcHlTdHIpO1xuICAgICAgICBlbnRyb3B5U3RyICs9IGIudG9TdHJpbmcoJ2JpbmFyeScpICsgXCIgXCIgKyBuZXcgRGF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBlbnRyb3B5U3RyO1xuICAgIH0sXG5cblxuICAgIC8vIEByZXR1cm4gYXJyYXkgb2YgNSBsZWdhY3kgYWRkcmVzc2VzIGZvciBhIHB1YmtleSBzdHJpbmcgcGFyYW1ldGVyLlxuICAgIGFkZHJlc3NlczogZnVuY3Rpb24gYWRkcmVzc2VzKHB1YmtleSkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHZhciBwdWJsaWNfa2V5ID0gX1B1YmxpY0tleTIuZGVmYXVsdC5mcm9tUHVibGljS2V5U3RyaW5nKHB1YmtleSwgYWRkcmVzc19wcmVmaXgpO1xuICAgICAgICAvLyBTIEwgTyBXXG4gICAgICAgIHZhciBhZGRyZXNzX3N0cmluZyA9IFtfYWRkcmVzczIuZGVmYXVsdC5mcm9tUHVibGljKHB1YmxpY19rZXksIGZhbHNlLCAwKS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIGJ0Y191bmNvbXByZXNzZWRcbiAgICAgICAgX2FkZHJlc3MyLmRlZmF1bHQuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCB0cnVlLCAwKS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIGJ0Y19jb21wcmVzc2VkXG4gICAgICAgIF9hZGRyZXNzMi5kZWZhdWx0LmZyb21QdWJsaWMocHVibGljX2tleSwgZmFsc2UsIDU2KS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIHB0c191bmNvbXByZXNzZWRcbiAgICAgICAgX2FkZHJlc3MyLmRlZmF1bHQuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCB0cnVlLCA1NikudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBwdHNfY29tcHJlc3NlZFxuICAgICAgICBwdWJsaWNfa2V5LnRvQWRkcmVzc1N0cmluZyhhZGRyZXNzX3ByZWZpeCkgLy8gYnRzX3Nob3J0LCBtb3N0IHJlY2VudCBmb3JtYXRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3Nfc3RyaW5nO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGtleTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9lY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIF9lY3VydmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWN1cnZlKTtcblxudmFyIF9iaWdpID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX2JpZ2kyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmlnaSk7XG5cbnZhciBfYnMgPSByZXF1aXJlKCdiczU4Jyk7XG5cbnZhciBfaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgX1B1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG5cbnZhciBfUHVibGljS2V5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1B1YmxpY0tleSk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc2VjcDI1NmsxID0gKDAsIF9lY3VydmUuZ2V0Q3VydmVCeU5hbWUpKCdzZWNwMjU2azEnKTtcbnZhciBHID0gc2VjcDI1NmsxLkcsXG4gICAgbiA9IHNlY3AyNTZrMS5uO1xuXG52YXIgUHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAgICBAcHJpdmF0ZSBzZWUgc3RhdGljIGZ1bmN0aW9uc1xuICAgICAgICBAcGFyYW0ge0JpZ0ludGVnZXJ9XG4gICAgKi9cbiAgICBmdW5jdGlvbiBQcml2YXRlS2V5KGQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaXZhdGVLZXkpO1xuXG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgfVxuXG4gICAgUHJpdmF0ZUtleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIHBhcmFtdGVyIHRvIGJlIGEgQnVmZmVyIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDMyICE9PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTjogRXhwZWN0aW5nIDMyIGJ5dGVzLCBpbnN0ZWFkIGdvdCAnICsgYnVmLmxlbmd0aCArICcsIHN0YWNrIHRyYWNlOicsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKGJ1ZikpO1xuICAgIH07XG5cbiAgICAvKiogQGFyZyB7c3RyaW5nfSBzZWVkIC0gYW55IGxlbmd0aCBzdHJpbmcuICBUaGlzIGlzIHByaXZhdGUsIHRoZSBzYW1lIHNlZWQgcHJvZHVjZXMgdGhlIHNhbWUgcHJpdmF0ZSBrZXkgZXZlcnkgdGltZS4gICovXG5cblxuICAgIFByaXZhdGVLZXkuZnJvbVNlZWQgPSBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgIC8vIGdlbmVyYXRlX3ByaXZhdGVfa2V5XG4gICAgICAgIGlmICghKHR5cGVvZiBzZWVkID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcigoMCwgX2hhc2guc2hhMjU2KShzZWVkKSk7XG4gICAgfTtcblxuICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9IFdhbGxldCBJbXBvcnQgRm9ybWF0IChzdGlsbCBhIHNlY3JldCwgTm90IGVuY3J5cHRlZCkgKi9cblxuXG4gICAgUHJpdmF0ZUtleS5mcm9tV2lmID0gZnVuY3Rpb24gZnJvbVdpZihfcHJpdmF0ZV93aWYpIHtcbiAgICAgICAgdmFyIHByaXZhdGVfd2lmID0gbmV3IEJ1ZmZlcigoMCwgX2JzLmRlY29kZSkoX3ByaXZhdGVfd2lmKSk7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcHJpdmF0ZV93aWYucmVhZFVJbnQ4KDApO1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKDB4ODAsIHZlcnNpb24sICdFeHBlY3RlZCB2ZXJzaW9uICcgKyAweDgwICsgJywgaW5zdGVhZCBnb3QgJyArIHZlcnNpb24pO1xuICAgICAgICAvLyBjaGVja3N1bSBpbmNsdWRlcyB0aGUgdmVyc2lvblxuICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX3dpZi5zbGljZSgwLCAtNCk7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHByaXZhdGVfd2lmLnNsaWNlKC00KTtcbiAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9ICgwLCBfaGFzaC5zaGEyNTYpKHByaXZhdGVfa2V5KTtcbiAgICAgICAgbmV3X2NoZWNrc3VtID0gKDAsIF9oYXNoLnNoYTI1NikobmV3X2NoZWNrc3VtKTtcbiAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICB2YXIgaXNFcXVhbCA9ICgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoZWNrc3VtIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihwcml2YXRlX2tleSk7XG4gICAgfTtcblxuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLnRvV2lmID0gZnVuY3Rpb24gdG9XaWYoKSB7XG4gICAgICAgIHZhciBwcml2YXRlX2tleSA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgLy8gY2hlY2tzdW0gaW5jbHVkZXMgdGhlIHZlcnNpb25cbiAgICAgICAgcHJpdmF0ZV9rZXkgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFsweDgwXSksIHByaXZhdGVfa2V5XSk7XG4gICAgICAgIHZhciBjaGVja3N1bSA9ICgwLCBfaGFzaC5zaGEyNTYpKHByaXZhdGVfa2V5KTtcbiAgICAgICAgY2hlY2tzdW0gPSAoMCwgX2hhc2guc2hhMjU2KShjaGVja3N1bSk7XG4gICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgIHZhciBwcml2YXRlX3dpZiA9IEJ1ZmZlci5jb25jYXQoW3ByaXZhdGVfa2V5LCBjaGVja3N1bV0pO1xuICAgICAgICByZXR1cm4gKDAsIF9icy5lbmNvZGUpKHByaXZhdGVfd2lmKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIEByZXR1cm4ge1BvaW50fVxuICAgICovXG5cblxuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLnRvUHVibGljS2V5UG9pbnQgPSBmdW5jdGlvbiB0b1B1YmxpY0tleVBvaW50KCkge1xuICAgICAgICB2YXIgUTtcbiAgICAgICAgcmV0dXJuIFEgPSBzZWNwMjU2azEuRy5tdWx0aXBseSh0aGlzLmQpO1xuICAgIH07XG5cbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS50b1B1YmxpY0tleSA9IGZ1bmN0aW9uIHRvUHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY19rZXkgPSBfUHVibGljS2V5Mi5kZWZhdWx0LmZyb21Qb2ludCh0aGlzLnRvUHVibGljS2V5UG9pbnQoKSk7XG4gICAgfTtcblxuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmQudG9CdWZmZXIoMzIpO1xuICAgIH07XG5cbiAgICAvKiogRUNJRVMgKi9cblxuXG4gICAgUHJpdmF0ZUtleS5wcm90b3R5cGUuZ2V0X3NoYXJlZF9zZWNyZXQgPSBmdW5jdGlvbiBnZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KSB7XG4gICAgICAgIHZhciBsZWdhY3kgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgIHB1YmxpY19rZXkgPSB0b1B1YmxpYyhwdWJsaWNfa2V5KTtcbiAgICAgICAgdmFyIEtCID0gcHVibGljX2tleS50b1VuY29tcHJlc3NlZCgpLnRvQnVmZmVyKCk7XG4gICAgICAgIHZhciBLQlAgPSBfZWN1cnZlLlBvaW50LmZyb21BZmZpbmUoc2VjcDI1NmsxLCBfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKEtCLnNsaWNlKDEsIDMzKSksIC8vIHhcbiAgICAgICAgX2JpZ2kyLmRlZmF1bHQuZnJvbUJ1ZmZlcihLQi5zbGljZSgzMywgNjUpKSAvLyB5XG4gICAgICAgICk7XG4gICAgICAgIHZhciByID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICB2YXIgUCA9IEtCUC5tdWx0aXBseShfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKHIpKTtcbiAgICAgICAgdmFyIFMgPSBQLmFmZmluZVgudG9CdWZmZXIoeyBzaXplOiAzMiB9KTtcbiAgICAgICAgLypcbiAgICAgICAgdGhlIGlucHV0IHRvIHNoYTUxMiBtdXN0IGJlIGV4YWN0bHkgMzItYnl0ZXMsIHRvIG1hdGNoIHRoZSBjKysgaW1wbGVtZW50YXRpb25cbiAgICAgICAgb2YgZ2V0X3NoYXJlZF9zZWNyZXQuICBSaWdodCBub3cgUyB3aWxsIGJlIHNob3J0ZXIgaWYgdGhlIG1vc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgYnl0ZShzKSBpcyB6ZXJvLiAgUGFkIGl0IGJhY2sgdG8gdGhlIGZ1bGwgMzItYnl0ZXNcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCFsZWdhY3kgJiYgUy5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgdmFyIHBhZCA9IG5ldyBCdWZmZXIoMzIgLSBTLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgICAgIFMgPSBCdWZmZXIuY29uY2F0KFtwYWQsIFNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNIQTUxMiB1c2VkIGluIEVDSUVTXG4gICAgICAgIHJldHVybiAoMCwgX2hhc2guc2hhNTEyKShTKTtcbiAgICB9O1xuXG4gICAgLy8gLyoqIEVDSUVTIChkb2VzIG5vdCBhbHdheXMgbWF0Y2ggdGhlIFBvaW50LmZyb21BZmZpbmUgdmVyc2lvbiBhYm92ZSkgKi9cbiAgICAvLyBnZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KXtcbiAgICAvLyAgICAgcHVibGljX2tleSA9IHRvUHVibGljKHB1YmxpY19rZXkpXG4gICAgLy8gICAgIHZhciBQID0gcHVibGljX2tleS5RLm11bHRpcGx5KCB0aGlzLmQgKTtcbiAgICAvLyAgICAgdmFyIFMgPSBQLmFmZmluZVgudG9CdWZmZXIoe3NpemU6IDMyfSk7XG4gICAgLy8gICAgIC8vIEVDSUVTLCBhZGRzIGFuIGV4dHJhIHNoYTUxMlxuICAgIC8vICAgICByZXR1cm4gc2hhNTEyKFMpO1xuICAgIC8vIH1cblxuICAgIC8qKiBAdGhyb3dzIHtFcnJvcn0gLSBvdmVyZmxvdyBvZiB0aGUga2V5IGNvdWxkIG5vdCBiZSBkZXJpdmVkICovXG5cblxuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gY2hpbGQob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMudG9QdWJsaWNLZXkoKS50b0J1ZmZlcigpLCBvZmZzZXRdKTtcbiAgICAgICAgb2Zmc2V0ID0gKDAsIF9oYXNoLnNoYTI1Nikob2Zmc2V0KTtcbiAgICAgICAgdmFyIGMgPSBfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGMuY29tcGFyZVRvKG4pID49IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG9mZnNldCB3ZW50IG91dCBvZiBib3VuZHMsIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICB2YXIgZGVyaXZlZCA9IHRoaXMuZC5hZGQoYyk7IC8vLm1vZChuKVxuXG4gICAgICAgIGlmIChkZXJpdmVkLnNpZ251bSgpID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShkZXJpdmVkKTtcbiAgICB9O1xuXG4gICAgLyogPGhlbHBlcl9mdW5jdGlvbnM+ICovXG5cbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS50b0J5dGVCdWZmZXIgPSBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgIHZhciBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgIH07XG5cbiAgICBQcml2YXRlS2V5LmZyb21IZXggPSBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgIH07XG5cbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9O1xuXG4gICAgLyogPC9oZWxwZXJfZnVuY3Rpb25zPiAqL1xuXG5cbiAgICByZXR1cm4gUHJpdmF0ZUtleTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHJpdmF0ZUtleTtcblxuXG52YXIgdG9QdWJsaWMgPSBmdW5jdGlvbiB0b1B1YmxpYyhkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLlEgPyBkYXRhIDogX1B1YmxpY0tleTIuZGVmYXVsdC5mcm9tU3RyaW5nT3JUaHJvdyhkYXRhKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9iaWdpID0gcmVxdWlyZShcImJpZ2lcIik7XG5cbnZhciBfYmlnaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaWdpKTtcblxudmFyIF9lY3VydmUgPSByZXF1aXJlKFwiZWN1cnZlXCIpO1xuXG52YXIgX2JzID0gcmVxdWlyZShcImJzNThcIik7XG5cbnZhciBfaGFzaCA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5cbnZhciBfYml0c2hhcmVzanNXcyA9IHJlcXVpcmUoXCJiaXRzaGFyZXNqcy13c1wiKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX2RlZXBFcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc2VjcDI1NmsxID0gKDAsIF9lY3VydmUuZ2V0Q3VydmVCeU5hbWUpKFwic2VjcDI1NmsxXCIpO1xudmFyIEcgPSBzZWNwMjU2azEuRyxcbiAgICBuID0gc2VjcDI1NmsxLm47XG5cbnZhciBQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBwYXJhbSB7UG9pbnR9IHB1YmxpYyBrZXkgKi9cbiAgICBmdW5jdGlvbiBQdWJsaWNLZXkoUSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVibGljS2V5KTtcblxuICAgICAgICB0aGlzLlEgPSBRO1xuICAgIH1cblxuICAgIFB1YmxpY0tleS5mcm9tQmluYXJ5ID0gZnVuY3Rpb24gZnJvbUJpbmFyeShiaW4pIHtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoYmluLCBcImJpbmFyeVwiKSk7XG4gICAgfTtcblxuICAgIFB1YmxpY0tleS5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci50b1N0cmluZyhcImhleFwiKSA9PT0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikgcmV0dXJuIG5ldyBQdWJsaWNLZXkobnVsbCk7XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KF9lY3VydmUuUG9pbnQuZGVjb2RlRnJvbShzZWNwMjU2azEsIGJ1ZmZlcikpO1xuICAgIH07XG5cbiAgICBQdWJsaWNLZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLlEgPyB0aGlzLlEuY29tcHJlc3NlZCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuUSA9PT0gbnVsbCkgcmV0dXJuIG5ldyBCdWZmZXIoXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCJoZXhcIik7XG4gICAgICAgIHJldHVybiB0aGlzLlEuZ2V0RW5jb2RlZChjb21wcmVzc2VkKTtcbiAgICB9O1xuXG4gICAgUHVibGljS2V5LmZyb21Qb2ludCA9IGZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCk7XG4gICAgfTtcblxuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9VbmNvbXByZXNzZWQgPSBmdW5jdGlvbiB0b1VuY29tcHJlc3NlZCgpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuUS5nZXRFbmNvZGVkKGZhbHNlKTtcbiAgICAgICAgdmFyIHBvaW50ID0gX2VjdXJ2ZS5Qb2ludC5kZWNvZGVGcm9tKHNlY3AyNTZrMSwgYnVmKTtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tUG9pbnQocG9pbnQpO1xuICAgIH07XG5cbiAgICAvKiogYnRzOjpibG9ja2NoYWluOjphZGRyZXNzICh1bmlxdWUgYnV0IG5vdCBhIGZ1bGwgcHVibGljIGtleSkgKi9cblxuXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS50b0Jsb2NrY2hhaW5BZGRyZXNzID0gZnVuY3Rpb24gdG9CbG9ja2NoYWluQWRkcmVzcygpIHtcbiAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgIHZhciBwdWJfc2hhID0gKDAsIF9oYXNoLnNoYTUxMikocHViX2J1Zik7XG4gICAgICAgIHJldHVybiAoMCwgX2hhc2gucmlwZW1kMTYwKShwdWJfc2hhKTtcbiAgICB9O1xuXG4gICAgLyoqIEFsaWFzIGZvciB7QGxpbmsgdG9QdWJsaWNLZXlTdHJpbmd9ICovXG5cblxuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICByZXR1cm4gdGhpcy50b1B1YmxpY0tleVN0cmluZyhhZGRyZXNzX3ByZWZpeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBGdWxsIHB1YmxpYyBrZXlcbiAgICAgICAge3JldHVybn0gc3RyaW5nXG4gICAgKi9cblxuXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS50b1B1YmxpY0tleVN0cmluZyA9IGZ1bmN0aW9uIHRvUHVibGljS2V5U3RyaW5nKCkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSAoMCwgX2hhc2gucmlwZW1kMTYwKShwdWJfYnVmKTtcbiAgICAgICAgdmFyIGFkZHkgPSBCdWZmZXIuY29uY2F0KFtwdWJfYnVmLCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICByZXR1cm4gYWRkcmVzc19wcmVmaXggKyAoMCwgX2JzLmVuY29kZSkoYWRkeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBAYXJnIHtzdHJpbmd9IHB1YmxpY19rZXkgLSBsaWtlIEdQSFh5ei4uLlxuICAgICAgICBAYXJnIHtzdHJpbmd9IGFkZHJlc3NfcHJlZml4IC0gbGlrZSBHUEhcbiAgICAgICAgQHJldHVybiBQdWJsaWNLZXkgb3IgYG51bGxgIChpZiB0aGUgcHVibGljX2tleSBzdHJpbmcgaXMgaW52YWxpZClcbiAgICAqL1xuXG5cbiAgICBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyA9IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXlTdHJpbmcocHVibGljX2tleSkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KHB1YmxpY19rZXksIGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIEBhcmcge3N0cmluZ30gcHVibGljX2tleSAtIGxpa2UgR1BIWHl6Li4uXG4gICAgICAgIEBhcmcge3N0cmluZ30gYWRkcmVzc19wcmVmaXggLSBsaWtlIEdQSFxuICAgICAgICBAdGhyb3dzIHtFcnJvcn0gaWYgcHVibGljIGtleSBpcyBpbnZhbGlkXG4gICAgICAgIEByZXR1cm4gUHVibGljS2V5XG4gICAgKi9cblxuXG4gICAgUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93ID0gZnVuY3Rpb24gZnJvbVN0cmluZ09yVGhyb3cocHVibGljX2tleSkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIGlmIChwdWJsaWNfa2V5LlEgPT09IG51bGwpIHB1YmxpY19rZXkgPSBhZGRyZXNzX3ByZWZpeCArIFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExNFQxQW5tXCI7IC8vIG51bGwga2V5XG4gICAgICAgIHZhciBwcmVmaXggPSBwdWJsaWNfa2V5LnNsaWNlKDAsIGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwoYWRkcmVzc19wcmVmaXgsIHByZWZpeCwgXCJFeHBlY3Rpbmcga2V5IHRvIGJlZ2luIHdpdGggXCIgKyBhZGRyZXNzX3ByZWZpeCArIFwiLCBpbnN0ZWFkIGdvdCBcIiArIHByZWZpeCk7XG4gICAgICAgIHB1YmxpY19rZXkgPSBwdWJsaWNfa2V5LnNsaWNlKGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG5cbiAgICAgICAgcHVibGljX2tleSA9IG5ldyBCdWZmZXIoKDAsIF9icy5kZWNvZGUpKHB1YmxpY19rZXkpLCBcImJpbmFyeVwiKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcHVibGljX2tleS5zbGljZSgtNCk7XG4gICAgICAgIHB1YmxpY19rZXkgPSBwdWJsaWNfa2V5LnNsaWNlKDAsIC00KTtcbiAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9ICgwLCBfaGFzaC5yaXBlbWQxNjApKHB1YmxpY19rZXkpO1xuICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgIHZhciBpc0VxdWFsID0gKDAsIF9kZWVwRXF1YWwyLmRlZmF1bHQpKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tzdW0gZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIocHVibGljX2tleSk7XG4gICAgfTtcblxuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9BZGRyZXNzU3RyaW5nID0gZnVuY3Rpb24gdG9BZGRyZXNzU3RyaW5nKCkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICB2YXIgcHViX3NoYSA9ICgwLCBfaGFzaC5zaGE1MTIpKHB1Yl9idWYpO1xuICAgICAgICB2YXIgYWRkeSA9ICgwLCBfaGFzaC5yaXBlbWQxNjApKHB1Yl9zaGEpO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSAoMCwgX2hhc2gucmlwZW1kMTYwKShhZGR5KTtcbiAgICAgICAgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW2FkZHksIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArICgwLCBfYnMuZW5jb2RlKShhZGR5KTtcbiAgICB9O1xuXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS50b1B0c0FkZHkgPSBmdW5jdGlvbiB0b1B0c0FkZHkoKSB7XG4gICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICB2YXIgcHViX3NoYSA9ICgwLCBfaGFzaC5zaGEyNTYpKHB1Yl9idWYpO1xuICAgICAgICB2YXIgYWRkeSA9ICgwLCBfaGFzaC5yaXBlbWQxNjApKHB1Yl9zaGEpO1xuICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHgzOF0pLCBhZGR5XSk7IC8vdmVyc2lvbiA1NihkZWNpbWFsKVxuXG4gICAgICAgIHZhciBjaGVja3N1bSA9ICgwLCBfaGFzaC5zaGEyNTYpKGFkZHkpO1xuICAgICAgICBjaGVja3N1bSA9ICgwLCBfaGFzaC5zaGEyNTYpKGNoZWNrc3VtKTtcblxuICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgcmV0dXJuICgwLCBfYnMuZW5jb2RlKShhZGR5KTtcbiAgICB9O1xuXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIGNoaWxkKG9mZnNldCkge1xuICAgICAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKG9mZnNldCksIFwiQnVmZmVyIHJlcXVpcmVkOiBvZmZzZXRcIik7XG4gICAgICAgIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwob2Zmc2V0Lmxlbmd0aCwgMzIsIFwib2Zmc2V0IGxlbmd0aFwiKTtcblxuICAgICAgICBvZmZzZXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnRvQnVmZmVyKCksIG9mZnNldF0pO1xuICAgICAgICBvZmZzZXQgPSAoMCwgX2hhc2guc2hhMjU2KShvZmZzZXQpO1xuXG4gICAgICAgIHZhciBjID0gX2JpZ2kyLmRlZmF1bHQuZnJvbUJ1ZmZlcihvZmZzZXQpO1xuXG4gICAgICAgIGlmIChjLmNvbXBhcmVUbyhuKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgd2VudCBvdXQgb2YgYm91bmRzLCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgdmFyIGNHID0gRy5tdWx0aXBseShjKTtcbiAgICAgICAgdmFyIFFwcmltZSA9IHRoaXMuUS5hZGQoY0cpO1xuXG4gICAgICAgIGlmIChzZWNwMjU2azEuaXNJbmZpbml0eShRcHJpbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KFFwcmltZSk7XG4gICAgfTtcblxuICAgIC8qIDxIRVg+ICovXG5cbiAgICBQdWJsaWNLZXkucHJvdG90eXBlLnRvQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgfTtcblxuICAgIFB1YmxpY0tleS5mcm9tSGV4ID0gZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCBcImhleFwiKSk7XG4gICAgfTtcblxuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZyhcImhleFwiKTtcbiAgICB9O1xuXG4gICAgUHVibGljS2V5LmZyb21QdWJsaWNLZXlTdHJpbmdIZXggPSBmdW5jdGlvbiBmcm9tUHVibGljS2V5U3RyaW5nSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21QdWJsaWNLZXlTdHJpbmcobmV3IEJ1ZmZlcihoZXgsIFwiaGV4XCIpKTtcbiAgICB9O1xuXG4gICAgLyogPC9IRVg+ICovXG5cblxuICAgIHJldHVybiBQdWJsaWNLZXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFB1YmxpY0tleTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX2JpdHNoYXJlc2pzV3MgPSByZXF1aXJlKCdiaXRzaGFyZXNqcy13cycpO1xuXG52YXIgX2hhc2gyID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBfYnMgPSByZXF1aXJlKCdiczU4Jyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogQWRkcmVzc2VzIGFyZSBzaG9ydGVuZWQgbm9uLXJldmVyc2FibGUgaGFzaGVzIG9mIGEgcHVibGljIGtleS4gIFRoZSBmdWxsIFB1YmxpY0tleSBpcyBwcmVmZXJyZWQuXG4gICAgQGRlcHJlY2F0ZWRcbiovXG52YXIgQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZGRyZXNzKGFkZHkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFkZHJlc3MpO1xuXG4gICAgICAgIHRoaXMuYWRkeSA9IGFkZHk7XG4gICAgfVxuXG4gICAgQWRkcmVzcy5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIF9oYXNoID0gKDAsIF9oYXNoMi5zaGE1MTIpKGJ1ZmZlcik7XG4gICAgICAgIHZhciBhZGR5ID0gKDAsIF9oYXNoMi5yaXBlbWQxNjApKF9oYXNoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFkZHkpO1xuICAgIH07XG5cbiAgICBBZGRyZXNzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF9iaXRzaGFyZXNqc1dzLkNoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHZhciBwcmVmaXggPSBzdHJpbmcuc2xpY2UoMCwgYWRkcmVzc19wcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgX2Fzc2VydDIuZGVmYXVsdC5lcXVhbChhZGRyZXNzX3ByZWZpeCwgcHJlZml4LCAnRXhwZWN0aW5nIGtleSB0byBiZWdpbiB3aXRoICcgKyBhZGRyZXNzX3ByZWZpeCArICcsIGluc3RlYWQgZ290ICcgKyBwcmVmaXgpO1xuICAgICAgICB2YXIgYWRkeSA9IHN0cmluZy5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICBhZGR5ID0gbmV3IEJ1ZmZlcigoMCwgX2JzLmRlY29kZSkoYWRkeSksICdiaW5hcnknKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gYWRkeS5zbGljZSgtNCk7XG4gICAgICAgIGFkZHkgPSBhZGR5LnNsaWNlKDAsIC00KTtcbiAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9ICgwLCBfaGFzaDIucmlwZW1kMTYwKShhZGR5KTtcbiAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICB2YXIgaXNFcXVhbCA9ICgwLCBfZGVlcEVxdWFsMi5kZWZhdWx0KShjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoZWNrc3VtIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFkZHkpO1xuICAgIH07XG5cbiAgICAvKiogQHJldHVybiBBZGRyZXNzIC0gQ29tcHJlc3NlZCBQVFMgZm9ybWF0IChieSBkZWZhdWx0KSAqL1xuICAgIEFkZHJlc3MuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMocHVibGljX2tleSkge1xuICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDU2O1xuXG4gICAgICAgIHZhciBzaGEyID0gKDAsIF9oYXNoMi5zaGEyNTYpKHB1YmxpY19rZXkudG9CdWZmZXIoY29tcHJlc3NlZCkpO1xuICAgICAgICB2YXIgcmVwID0gKDAsIF9oYXNoMi5yaXBlbWQxNjApKHNoYTIpO1xuICAgICAgICB2YXIgdmVyc2lvbkJ1ZmZlciA9IG5ldyBCdWZmZXIoMSk7XG4gICAgICAgIHZlcnNpb25CdWZmZXIud3JpdGVVSW50OCgweEZGICYgdmVyc2lvbiwgMCk7XG4gICAgICAgIHZhciBhZGRyID0gQnVmZmVyLmNvbmNhdChbdmVyc2lvbkJ1ZmZlciwgcmVwXSk7XG4gICAgICAgIHZhciBjaGVjayA9ICgwLCBfaGFzaDIuc2hhMjU2KShhZGRyKTtcbiAgICAgICAgY2hlY2sgPSAoMCwgX2hhc2gyLnNoYTI1NikoY2hlY2spO1xuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYWRkciwgY2hlY2suc2xpY2UoMCwgNCldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBfaGFzaDIucmlwZW1kMTYwKShidWZmZXIpKTtcbiAgICB9O1xuXG4gICAgQWRkcmVzcy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkeTtcbiAgICB9O1xuXG4gICAgQWRkcmVzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICB2YXIgY2hlY2tzdW0gPSAoMCwgX2hhc2gyLnJpcGVtZDE2MCkodGhpcy5hZGR5KTtcbiAgICAgICAgdmFyIGFkZHkgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmFkZHksIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArICgwLCBfYnMuZW5jb2RlKShhZGR5KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFkZHJlc3M7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFkZHJlc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hZXMgPSByZXF1aXJlKFwiY3J5cHRvLWpzL2Flc1wiKTtcblxudmFyIF9hZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWVzKTtcblxudmFyIF9lbmNIZXggPSByZXF1aXJlKFwiY3J5cHRvLWpzL2VuYy1oZXhcIik7XG5cbnZhciBfZW5jSGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VuY0hleCk7XG5cbnZhciBfZW5jQmFzZSA9IHJlcXVpcmUoXCJjcnlwdG8tanMvZW5jLWJhc2U2NFwiKTtcblxudmFyIF9lbmNCYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VuY0Jhc2UpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfYnl0ZWJ1ZmZlciA9IHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpO1xuXG52YXIgX2hhc2gyID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcblxuXG4vKiogUHJvdmlkZXMgc3ltZXRyaWMgZW5jcnlwdCBhbmQgZGVjcnlwdCB2aWEgQUVTLiAqL1xudmFyIEFlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIEFlcyhpdiwga2V5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZXMpO1xuXG4gICAgICAgIHRoaXMuaXYgPSBpdiwgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgLyoqIFRoaXMgaXMgYW4gZXhjZWxsZW50IHdheSB0byBlbnN1cmUgdGhhdCBhbGwgcmVmZXJlbmNlcyB0byBBZXMgY2FuIG5vdCBvcGVyYXRlIGFueW1vcmUgKGV4YW1wbGU6IGEgd2FsbGV0IGJlY29tZXMgbG9ja2VkKS4gIEFuIGFwcGxpY2F0aW9uIHNob3VsZCBlbnN1cmUgdGhlcmUgaXMgb25seSBvbmUgQWVzIG9iamVjdCBpbnN0YW5jZSBmb3IgYSBnaXZlbiBzZWNyZXQgYHNlZWRgLiAqL1xuXG5cbiAgICBBZXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml2ID0gdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKiBAYXJnIHtzdHJpbmd9IHNlZWQgLSBzZWNyZXQgc2VlZCBtYXkgYmUgdXNlZCB0byBlbmNyeXB0IG9yIGRlY3J5cHQuICovXG5cblxuICAgIEFlcy5mcm9tU2VlZCA9IGZ1bmN0aW9uIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgaWYgKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VlZCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2hhc2ggPSAoMCwgX2hhc2gyLnNoYTUxMikoc2VlZCk7XG4gICAgICAgIF9oYXNoID0gX2hhc2gudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIGZyb21TZWVkIF9oYXNoJyxfaGFzaClcbiAgICAgICAgcmV0dXJuIEFlcy5mcm9tU2hhNTEyKF9oYXNoKTtcbiAgICB9O1xuXG4gICAgLyoqIEBhcmcge3N0cmluZ30gaGFzaCAtIEEgMTI4IGJ5dGUgaGV4IHN0cmluZywgdHlwaWNhbGx5IG9uZSB3b3VsZCBjYWxsIHtAbGluayBmcm9tU2VlZH0gaW5zdGVhZC4gKi9cbiAgICBBZXMuZnJvbVNoYTUxMiA9IGZ1bmN0aW9uIGZyb21TaGE1MTIoaGFzaCkge1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGhhc2gubGVuZ3RoLCAxMjgsIFwiQSBTaGE1MTIgaW4gSEVYIHNob3VsZCBiZSAxMjggY2hhcmFjdGVycyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGhhc2gubGVuZ3RoKTtcbiAgICAgICAgdmFyIGl2ID0gX2VuY0hleDIuZGVmYXVsdC5wYXJzZShoYXNoLnN1YnN0cmluZyg2NCwgOTYpKTtcbiAgICAgICAgdmFyIGtleSA9IF9lbmNIZXgyLmRlZmF1bHQucGFyc2UoaGFzaC5zdWJzdHJpbmcoMCwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZXMoaXYsIGtleSk7XG4gICAgfTtcblxuICAgIEFlcy5mcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihidWYpLCBcIkV4cGVjdGluZyBCdWZmZXJcIik7XG4gICAgICAgIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwoYnVmLmxlbmd0aCwgNjQsIFwiQSBTaGE1MTIgQnVmZmVyIHNob3VsZCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcsIGluc3RlYWQgZ290IFwiICsgYnVmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBBZXMuZnJvbVNoYTUxMihidWYudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgIEB0aHJvd3Mge0Vycm9yfSAtIFwiSW52YWxpZCBLZXksIC4uLlwiXG4gICAgICAgIEBhcmcge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgZm9yIGRlY3J5cHRpb25cbiAgICAgICAgQGFyZyB7UHVibGljS2V5fSBwdWJsaWNfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgdG8gY2FsY3VhbHRlIHRoZSBzaGFyZWQgc2VjcmV0XG4gICAgICAgIEBhcmcge3N0cmluZ30gW25vbmNlID0gXCJcIl0gb3B0aW9uYWwgYnV0IHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYW5kIGJlIHVuaXF1ZSB3aGVuIHJlLXVzaW5nIHRoZSBzYW1lIHByaXZhdGUvcHVibGljIGtleXMgbW9yZSB0aGFuIG9uY2UuICBUaGlzIG5vbmNlIGlzIG5vdCBhIHNlY3JldC5cbiAgICAgICAgQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSAtIEVuY3J5cHRlZCBtZXNzYWdlIGNvbnRhaW5pbmcgYSBjaGVja3N1bVxuICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgKi9cblxuXG4gICAgQWVzLmRlY3J5cHRfd2l0aF9jaGVja3N1bSA9IGZ1bmN0aW9uIGRlY3J5cHRfd2l0aF9jaGVja3N1bShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cblxuICAgICAgICAvLyBXYXJuaW5nOiBEbyBub3QgcHV0IGBub25jZSA9IFwiXCJgIGluIHRoZSBhcmd1bWVudHMsIGluIGVzNiB0aGlzIHdpbGwgbm90IGNvbnZlcnQgXCJudWxsXCIgaW50byBhbiBlbXRweSBzdHJpbmdcbiAgICAgICAgaWYgKG5vbmNlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBub25jZSA9IFwiXCI7XG5cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBTID0gcHJpdmF0ZV9rZXkuZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSwgbGVnYWN5KTtcbiAgICAgICAgLy8gRCBFIEIgVSBHXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWNyeXB0X3dpdGhfY2hlY2tzdW0nLCB7XG4gICAgICAgIC8vICAgICBwcml2X3RvX3B1YjogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZygpLFxuICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKCksXG4gICAgICAgIC8vICAgICBub25jZTogbm9uY2UsXG4gICAgICAgIC8vICAgICBtZXNzYWdlOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC8vIH0pXG5cbiAgICAgICAgdmFyIGFlcyA9IEFlcy5mcm9tU2VlZChCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcblxuICAgICAgICB2YXIgcGxhbmVidWZmZXIgPSBhZXMuZGVjcnlwdChtZXNzYWdlKTtcbiAgICAgICAgaWYgKCEocGxhbmVidWZmZXIubGVuZ3RoID49IDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSwgY291bGQgbm90IGRlY3J5cHQgbWVzc2FnZSgxKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGxhbmVidWZmZXInLHBsYW5lYnVmZmVyKVxuICAgICAgICB2YXIgY2hlY2tzdW0gPSBwbGFuZWJ1ZmZlci5zbGljZSgwLCA0KTtcbiAgICAgICAgdmFyIHBsYWludGV4dCA9IHBsYW5lYnVmZmVyLnNsaWNlKDQpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gY2hlY2tzdW0nLGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBwbGFpbnRleHQnLHBsYWludGV4dC50b1N0cmluZygpKVxuXG4gICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSAoMCwgX2hhc2gyLnNoYTI1NikocGxhaW50ZXh0KTtcbiAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICAgIGlmICghKGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSA9PT0gbmV3X2NoZWNrc3VtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXksIGNvdWxkIG5vdCBkZWNyeXB0IG1lc3NhZ2UoMilcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH07XG5cbiAgICAvKiogSWRlbnRpY2FsIHRvIHtAbGluayBkZWNyeXB0X3dpdGhfY2hlY2tzdW19IGJ1dCB1c2VkIHRvIGVuY3J5cHQuICBTaG91bGQgbm90IHRocm93IGFuIGVycm9yLlxuICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9IG1lc3NhZ2UgLSBFbmNyeXB0ZWQgbWVzc2FnZSB3aGljaCBpbmNsdWRlcyBhIGNoZWNrc3VtXG4gICAgKi9cbiAgICBBZXMuZW5jcnlwdF93aXRoX2NoZWNrc3VtID0gZnVuY3Rpb24gZW5jcnlwdF93aXRoX2NoZWNrc3VtKHByaXZhdGVfa2V5LCBwdWJsaWNfa2V5LCBub25jZSwgbWVzc2FnZSkge1xuXG4gICAgICAgIC8vIFdhcm5pbmc6IERvIG5vdCBwdXQgYG5vbmNlID0gXCJcImAgaW4gdGhlIGFyZ3VtZW50cywgaW4gZXM2IHRoaXMgd2lsbCBub3QgY29udmVydCBcIm51bGxcIiBpbnRvIGFuIGVtdHB5IHN0cmluZ1xuXG4gICAgICAgIGlmIChub25jZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgbm9uY2UgPSBcIlwiO1xuXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAnYmluYXJ5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgUyA9IHByaXZhdGVfa2V5LmdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXkpO1xuXG4gICAgICAgIC8vIEQgRSBCIFUgR1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZW5jcnlwdF93aXRoX2NoZWNrc3VtJywge1xuICAgICAgICAvLyAgICAgcHJpdl90b19wdWI6IHByaXZhdGVfa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcoKVxuICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKClcbiAgICAgICAgLy8gICAgIG5vbmNlOiBub25jZVxuICAgICAgICAvLyAgICAgbWVzc2FnZTogbWVzc2FnZS5sZW5ndGhcbiAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC8vIH0pXG5cbiAgICAgICAgdmFyIGFlcyA9IEFlcy5mcm9tU2VlZChCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcbiAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBTJyxTLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gKDAsIF9oYXNoMi5zaGEyNTYpKG1lc3NhZ2UpLnNsaWNlKDAsIDQpO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW2NoZWNrc3VtLCBtZXNzYWdlXSk7XG4gICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGF5bG9hZCcscGF5bG9hZC50b1N0cmluZygpKVxuICAgICAgICByZXR1cm4gYWVzLmVuY3J5cHQocGF5bG9hZCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIEFlcy5wcm90b3R5cGUuX2RlY3J5cHRfd29yZF9hcnJheSA9IGZ1bmN0aW9uIF9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzLyNDdXN0b21fS2V5X2FuZF9JVlxuICAgICAgICAvLyBzZWUgd2FsbGV0X3JlY29yZHMuY3BwIG1hc3Rlcl9rZXk6OmRlY3J5cHRfa2V5XG4gICAgICAgIHJldHVybiBfYWVzMi5kZWZhdWx0LmRlY3J5cHQoeyBjaXBoZXJ0ZXh0OiBjaXBoZXIsIHNhbHQ6IG51bGwgfSwgdGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICBBZXMucHJvdG90eXBlLl9lbmNyeXB0X3dvcmRfYXJyYXkgPSBmdW5jdGlvbiBfZW5jcnlwdF93b3JkX2FycmF5KHBsYWludGV4dCkge1xuICAgICAgICAvL2h0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL2lzc3Vlcy9kZXRhaWw/aWQ9ODVcbiAgICAgICAgdmFyIGNpcGhlciA9IF9hZXMyLmRlZmF1bHQuZW5jcnlwdChwbGFpbnRleHQsIHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICByZXR1cm4gX2VuY0Jhc2UyLmRlZmF1bHQucGFyc2UoY2lwaGVyLnRvU3RyaW5nKCkpO1xuICAgIH07XG5cbiAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICBAYXJnIHtzdHJpbmd9IGNpcGhlcnRleHRcbiAgICAgICAgQHJldHVybiB7QnVmZmVyfSBiaW5hcnlcbiAgICAqL1xuXG5cbiAgICBBZXMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gbmV3IEJ1ZmZlcihjaXBoZXJ0ZXh0LCAnYmluYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2lwaGVydGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoY2lwaGVydGV4dCwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAvLyBoZXggaXMgdGhlIG9ubHkgY29tbW9uIGZvcm1hdFxuICAgICAgICB2YXIgaGV4ID0gdGhpcy5kZWNyeXB0SGV4KGNpcGhlcnRleHQudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgfTtcblxuICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgIEBhcmcge3N0cmluZ30gcGxhaW50ZXh0XG4gICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gYmluYXJ5XG4gICAgKi9cblxuXG4gICAgQWVzLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwbGFpbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBsYWludGV4dCA9IG5ldyBCdWZmZXIocGxhaW50ZXh0LCAnYmluYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGxhaW50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vYXNzZXJ0IHBsYWludGV4dCwgXCJNaXNzaW5nIHBsYWluIHRleHRcIlxuICAgICAgICAvLyBoZXggaXMgdGhlIG9ubHkgY29tbW9uIGZvcm1hdFxuICAgICAgICB2YXIgaGV4ID0gdGhpcy5lbmNyeXB0SGV4KHBsYWludGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICB9O1xuXG4gICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gcGxhaW50ZXh0XG4gICAgICAgIEByZXR1cm4ge3N0cmluZ30gaGV4XG4gICAgKi9cblxuXG4gICAgQWVzLnByb3RvdHlwZS5lbmNyeXB0VG9IZXggPSBmdW5jdGlvbiBlbmNyeXB0VG9IZXgocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGxhaW50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwbGFpbnRleHQgPSBuZXcgQnVmZmVyKHBsYWludGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBsYWludGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvL2Fzc2VydCBwbGFpbnRleHQsIFwiTWlzc2luZyBwbGFpbiB0ZXh0XCJcbiAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEhleChwbGFpbnRleHQudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9O1xuXG4gICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgQGFyZyB7c3RyaW5nfSBjaXBoZXIgLSBoZXhcbiAgICAgICAgQHJldHVybiB7c3RyaW5nfSBiaW5hcnkgKGNvdWxkIGVhc2lseSBiZSByZWFkYWJsZSB0ZXh0KVxuICAgICovXG5cblxuICAgIEFlcy5wcm90b3R5cGUuZGVjcnlwdEhleCA9IGZ1bmN0aW9uIGRlY3J5cHRIZXgoY2lwaGVyKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShjaXBoZXIsIFwiTWlzc2luZyBjaXBoZXIgdGV4dFwiKTtcbiAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICB2YXIgY2lwaGVyX2FycmF5ID0gX2VuY0hleDIuZGVmYXVsdC5wYXJzZShjaXBoZXIpO1xuICAgICAgICB2YXIgcGxhaW53b3JkcyA9IHRoaXMuX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXJfYXJyYXkpO1xuICAgICAgICByZXR1cm4gX2VuY0hleDIuZGVmYXVsdC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgfTtcblxuICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZCBhcyBzcGVjaWZpZWQgYnkgdGhlIHBhcmFtZXRlclxuICAgICovXG5cblxuICAgIEFlcy5wcm90b3R5cGUuZGVjcnlwdEhleFRvQnVmZmVyID0gZnVuY3Rpb24gZGVjcnlwdEhleFRvQnVmZmVyKGNpcGhlcikge1xuICAgICAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoY2lwaGVyLCBcIk1pc3NpbmcgY2lwaGVyIHRleHRcIik7XG4gICAgICAgIC8vIENvbnZlcnQgZGF0YSBpbnRvIHdvcmQgYXJyYXlzICh1c2VkIGJ5IENyeXB0bylcbiAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IF9lbmNIZXgyLmRlZmF1bHQucGFyc2UoY2lwaGVyKTtcbiAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgdmFyIHBsYWluaGV4ID0gX2VuY0hleDIuZGVmYXVsdC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHBsYWluaGV4LCAnaGV4Jyk7XG4gICAgfTtcblxuICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgIEBhcmcge3N0cmluZ30gW2VuY29kaW5nID0gJ2JpbmFyeSddIC0gYSB2YWxpZCBCdWZmZXIgZW5jb2RpbmdcbiAgICAgICAgQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGFzIHNwZWNpZmllZCBieSB0aGUgcGFyYW1ldGVyXG4gICAgKi9cblxuXG4gICAgQWVzLnByb3RvdHlwZS5kZWNyeXB0SGV4VG9UZXh0ID0gZnVuY3Rpb24gZGVjcnlwdEhleFRvVGV4dChjaXBoZXIpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnYmluYXJ5JztcblxuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0SGV4VG9CdWZmZXIoY2lwaGVyKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfTtcblxuICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgIEBhcmcge3N0cmluZ30gcGxhaW5oZXggLSBoZXggZm9ybWF0XG4gICAgICAgIEByZXR1cm4ge1N0cmluZ30gaGV4XG4gICAgKi9cblxuXG4gICAgQWVzLnByb3RvdHlwZS5lbmNyeXB0SGV4ID0gZnVuY3Rpb24gZW5jcnlwdEhleChwbGFpbmhleCkge1xuICAgICAgICB2YXIgcGxhaW5fYXJyYXkgPSBfZW5jSGV4Mi5kZWZhdWx0LnBhcnNlKHBsYWluaGV4KTtcbiAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IHRoaXMuX2VuY3J5cHRfd29yZF9hcnJheShwbGFpbl9hcnJheSk7XG4gICAgICAgIHJldHVybiBfZW5jSGV4Mi5kZWZhdWx0LnN0cmluZ2lmeShjaXBoZXJfYXJyYXkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQWVzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudmVyaWZ5UmF3ID0gZXhwb3J0cy52ZXJpZnkgPSBleHBvcnRzLnNpZ24gPSBleHBvcnRzLnJlY292ZXJQdWJLZXkgPSBleHBvcnRzLmRldGVybWluaXN0aWNHZW5lcmF0ZUsgPSBleHBvcnRzLmNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtID0gdW5kZWZpbmVkO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX2hhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIF9lbmZvcmNlX3R5cGVzID0gcmVxdWlyZSgnLi9lbmZvcmNlX3R5cGVzJyk7XG5cbnZhciBfZW5mb3JjZV90eXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbmZvcmNlX3R5cGVzKTtcblxudmFyIF9iaWdpID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX2JpZ2kyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmlnaSk7XG5cbnZhciBfZWNzaWduYXR1cmUgPSByZXF1aXJlKCcuL2Vjc2lnbmF0dXJlJyk7XG5cbnZhciBfZWNzaWduYXR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWNzaWduYXR1cmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxuLy8gZnJvbSBnaXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliIGZyb20gZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvZWNkc2FcbmZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGNoZWNrU2lnLCBub25jZSkge1xuXG4gICgwLCBfZW5mb3JjZV90eXBlczIuZGVmYXVsdCkoJ0J1ZmZlcicsIGhhc2gpO1xuICAoMCwgX2VuZm9yY2VfdHlwZXMyLmRlZmF1bHQpKF9iaWdpMi5kZWZhdWx0LCBkKTtcblxuICBpZiAobm9uY2UpIHtcbiAgICBoYXNoID0gKDAsIF9oYXNoLnNoYTI1NikoQnVmZmVyLmNvbmNhdChbaGFzaCwgbmV3IEJ1ZmZlcihub25jZSldKSk7XG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgX2Fzc2VydDIuZGVmYXVsdC5lcXVhbChoYXNoLmxlbmd0aCwgMzIsICdIYXNoIG11c3QgYmUgMjU2IGJpdCcpO1xuXG4gIHZhciB4ID0gZC50b0J1ZmZlcigzMik7XG4gIHZhciBrID0gbmV3IEJ1ZmZlcigzMik7XG4gIHZhciB2ID0gbmV3IEJ1ZmZlcigzMik7XG5cbiAgLy8gU3RlcCBCXG4gIHYuZmlsbCgxKTtcblxuICAvLyBTdGVwIENcbiAgay5maWxsKDApO1xuXG4gIC8vIFN0ZXAgRFxuICBrID0gKDAsIF9oYXNoLkhtYWNTSEEyNTYpKEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzBdKSwgeCwgaGFzaF0pLCBrKTtcblxuICAvLyBTdGVwIEVcbiAgdiA9ICgwLCBfaGFzaC5IbWFjU0hBMjU2KSh2LCBrKTtcblxuICAvLyBTdGVwIEZcbiAgayA9ICgwLCBfaGFzaC5IbWFjU0hBMjU2KShCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFsxXSksIHgsIGhhc2hdKSwgayk7XG5cbiAgLy8gU3RlcCBHXG4gIHYgPSAoMCwgX2hhc2guSG1hY1NIQTI1Nikodiwgayk7XG5cbiAgLy8gU3RlcCBIMS9IMmEsIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgLy8gU3RlcCBIMmJcbiAgdiA9ICgwLCBfaGFzaC5IbWFjU0hBMjU2KSh2LCBrKTtcblxuICB2YXIgVCA9IF9iaWdpMi5kZWZhdWx0LmZyb21CdWZmZXIodik7XG5cbiAgLy8gU3RlcCBIMywgcmVwZWF0IHVudGlsIFQgaXMgd2l0aGluIHRoZSBpbnRlcnZhbCBbMSwgbiAtIDFdXG4gIHdoaWxlIChULnNpZ251bSgpIDw9IDAgfHwgVC5jb21wYXJlVG8oY3VydmUubikgPj0gMCB8fCAhY2hlY2tTaWcoVCkpIHtcbiAgICBrID0gKDAsIF9oYXNoLkhtYWNTSEEyNTYpKEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzBdKV0pLCBrKTtcbiAgICB2ID0gKDAsIF9oYXNoLkhtYWNTSEEyNTYpKHYsIGspO1xuXG4gICAgLy8gU3RlcCBIMS9IMmEsIGFnYWluLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gICAgLy8gU3RlcCBIMmIgYWdhaW5cbiAgICB2ID0gKDAsIF9oYXNoLkhtYWNTSEEyNTYpKHYsIGspO1xuXG4gICAgVCA9IF9iaWdpMi5kZWZhdWx0LmZyb21CdWZmZXIodik7XG4gIH1cblxuICByZXR1cm4gVDtcbn1cblxuZnVuY3Rpb24gc2lnbihjdXJ2ZSwgaGFzaCwgZCwgbm9uY2UpIHtcblxuICB2YXIgZSA9IF9iaWdpMi5kZWZhdWx0LmZyb21CdWZmZXIoaGFzaCk7XG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByLCBzO1xuICB2YXIgayA9IGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGZ1bmN0aW9uIChrKSB7XG4gICAgLy8gZmluZCBjYW5vbmljYWxseSB2YWxpZCBzaWduYXR1cmVcbiAgICB2YXIgUSA9IEcubXVsdGlwbHkoayk7XG5cbiAgICBpZiAoY3VydmUuaXNJbmZpbml0eShRKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgciA9IFEuYWZmaW5lWC5tb2Qobik7XG4gICAgaWYgKHIuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHMgPSBrLm1vZEludmVyc2UobikubXVsdGlwbHkoZS5hZGQoZC5tdWx0aXBseShyKSkpLm1vZChuKTtcbiAgICBpZiAocy5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIG5vbmNlKTtcblxuICB2YXIgTl9PVkVSX1RXTyA9IG4uc2hpZnRSaWdodCgxKTtcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNvbXBhcmVUbyhOX09WRVJfVFdPKSA+IDApIHtcbiAgICBzID0gbi5zdWJ0cmFjdChzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX2Vjc2lnbmF0dXJlMi5kZWZhdWx0KHIsIHMpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlSYXcoY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICB2YXIgbiA9IGN1cnZlLm47XG4gIHZhciBHID0gY3VydmUuRztcblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIDEuNC4xIEVuZm9yY2UgciBhbmQgcyBhcmUgYm90aCBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzEsIG4g4oiSIDFdXG4gIGlmIChyLnNpZ251bSgpIDw9IDAgfHwgci5jb21wYXJlVG8obikgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5zaWdudW0oKSA8PSAwIHx8IHMuY29tcGFyZVRvKG4pID49IDApIHJldHVybiBmYWxzZTtcblxuICAvLyBjID0gc14tMSBtb2QgblxuICB2YXIgYyA9IHMubW9kSW52ZXJzZShuKTtcblxuICAvLyAxLjQuNCBDb21wdXRlIHUxID0gZXNe4oiSMSBtb2QgblxuICAvLyAgICAgICAgICAgICAgIHUyID0gcnNe4oiSMSBtb2QgblxuICB2YXIgdTEgPSBlLm11bHRpcGx5KGMpLm1vZChuKTtcbiAgdmFyIHUyID0gci5tdWx0aXBseShjKS5tb2Qobik7XG5cbiAgLy8gMS40LjUgQ29tcHV0ZSBSID0gKHhSLCB5UikgPSB1MUcgKyB1MlFcbiAgdmFyIFIgPSBHLm11bHRpcGx5VHdvKHUxLCBRLCB1Mik7XG5cbiAgLy8gMS40LjUgKGNvbnQuKSBFbmZvcmNlIFIgaXMgbm90IGF0IGluZmluaXR5XG4gIGlmIChjdXJ2ZS5pc0luZmluaXR5KFIpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gMS40LjYgQ29udmVydCB0aGUgZmllbGQgZWxlbWVudCBSLnggdG8gYW4gaW50ZWdlclxuICB2YXIgeFIgPSBSLmFmZmluZVg7XG5cbiAgLy8gMS40LjcgU2V0IHYgPSB4UiBtb2QgblxuICB2YXIgdiA9IHhSLm1vZChuKTtcblxuICAvLyAxLjQuOCBJZiB2ID0gciwgb3V0cHV0IFwidmFsaWRcIiwgYW5kIGlmIHYgIT0gciwgb3V0cHV0IFwiaW52YWxpZFwiXG4gIHJldHVybiB2LmVxdWFscyhyKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5KGN1cnZlLCBoYXNoLCBzaWduYXR1cmUsIFEpIHtcbiAgLy8gMS40LjIgSCA9IEhhc2goTSksIGFscmVhZHkgZG9uZSBieSB0aGUgdXNlclxuICAvLyAxLjQuMyBlID0gSFxuICB2YXIgZSA9IF9iaWdpMi5kZWZhdWx0LmZyb21CdWZmZXIoaGFzaCk7XG4gIHJldHVybiB2ZXJpZnlSYXcoY3VydmUsIGUsIHNpZ25hdHVyZSwgUSk7XG59XG5cbi8qKlxuICAqIFJlY292ZXIgYSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gICpcbiAgKiBTZWUgU0VDIDE6IEVsbGlwdGljIEN1cnZlIENyeXB0b2dyYXBoeSwgc2VjdGlvbiA0LjEuNiwgXCJQdWJsaWNcbiAgKiBLZXkgUmVjb3ZlcnkgT3BlcmF0aW9uXCIuXG4gICpcbiAgKiBodHRwOi8vd3d3LnNlY2cub3JnL2Rvd25sb2FkL2FpZC03ODAvc2VjMS12Mi5wZGZcbiAgKi9cbmZ1bmN0aW9uIHJlY292ZXJQdWJLZXkoY3VydmUsIGUsIHNpZ25hdHVyZSwgaSkge1xuICBfYXNzZXJ0Mi5kZWZhdWx0LnN0cmljdEVxdWFsKGkgJiAzLCBpLCAnUmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG5cbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG5cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoci5zaWdudW0oKSA+IDAgJiYgci5jb21wYXJlVG8obikgPCAwLCAnSW52YWxpZCByIHZhbHVlJyk7XG4gICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShzLnNpZ251bSgpID4gMCAmJiBzLmNvbXBhcmVUbyhuKSA8IDAsICdJbnZhbGlkIHMgdmFsdWUnKTtcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGkgJiAxO1xuXG4gIC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxuICAvLyBmaXJzdCBvciBzZWNvbmQgY2FuZGlkYXRlIGtleS5cbiAgdmFyIGlzU2Vjb25kS2V5ID0gaSA+PiAxO1xuXG4gIC8vIDEuMSBMZXQgeCA9IHIgKyBqblxuICB2YXIgeCA9IGlzU2Vjb25kS2V5ID8gci5hZGQobikgOiByO1xuICB2YXIgUiA9IGN1cnZlLnBvaW50RnJvbVgoaXNZT2RkLCB4KTtcblxuICAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxuICB2YXIgblIgPSBSLm11bHRpcGx5KG4pO1xuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoY3VydmUuaXNJbmZpbml0eShuUiksICduUiBpcyBub3QgYSB2YWxpZCBjdXJ2ZSBwb2ludCcpO1xuXG4gIC8vIENvbXB1dGUgLWUgZnJvbSBlXG4gIHZhciBlTmVnID0gZS5uZWdhdGUoKS5tb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICB2YXIgckludiA9IHIubW9kSW52ZXJzZShuKTtcblxuICB2YXIgUSA9IFIubXVsdGlwbHlUd28ocywgRywgZU5lZykubXVsdGlwbHkockludik7XG4gIGN1cnZlLnZhbGlkYXRlKFEpO1xuXG4gIHJldHVybiBRO1xufVxuXG4vKipcbiAgKiBDYWxjdWxhdGUgcHVia2V5IGV4dHJhY3Rpb24gcGFyYW1ldGVyLlxuICAqXG4gICogV2hlbiBleHRyYWN0aW5nIGEgcHVia2V5IGZyb20gYSBzaWduYXR1cmUsIHdlIGhhdmUgdG9cbiAgKiBkaXN0aW5ndWlzaCBmb3VyIGRpZmZlcmVudCBjYXNlcy4gUmF0aGVyIHRoYW4gcHV0dGluZyB0aGlzXG4gICogYnVyZGVuIG9uIHRoZSB2ZXJpZmllciwgQml0Y29pbiBpbmNsdWRlcyBhIDItYml0IHZhbHVlIHdpdGggdGhlXG4gICogc2lnbmF0dXJlLlxuICAqXG4gICogVGhpcyBmdW5jdGlvbiBzaW1wbHkgdHJpZXMgYWxsIGZvdXIgY2FzZXMgYW5kIHJldHVybnMgdGhlIHZhbHVlXG4gICogdGhhdCByZXN1bHRlZCBpbiBhIHN1Y2Nlc3NmdWwgcHVia2V5IHJlY292ZXJ5LlxuICAqL1xuZnVuY3Rpb24gY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWUgPSByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpO1xuXG4gICAgLy8gMS42LjIgVmVyaWZ5IFFcbiAgICBpZiAoUXByaW1lLmVxdWFscyhRKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn1cblxuZXhwb3J0cy5jYWxjUHViS2V5UmVjb3ZlcnlQYXJhbSA9IGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtO1xuZXhwb3J0cy5kZXRlcm1pbmlzdGljR2VuZXJhdGVLID0gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSztcbmV4cG9ydHMucmVjb3ZlclB1YktleSA9IHJlY292ZXJQdWJLZXk7XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5leHBvcnRzLnZlcmlmeVJhdyA9IHZlcmlmeVJhdzsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfZW5mb3JjZV90eXBlcyA9IHJlcXVpcmUoJy4vZW5mb3JjZV90eXBlcycpO1xuXG52YXIgX2VuZm9yY2VfdHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW5mb3JjZV90eXBlcyk7XG5cbnZhciBfYmlnaSA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIF9iaWdpMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpZ2kpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLWxpYlxuZnVuY3Rpb24gRUNTaWduYXR1cmUociwgcykge1xuICAoMCwgX2VuZm9yY2VfdHlwZXMyLmRlZmF1bHQpKF9iaWdpMi5kZWZhdWx0LCByKTtcbiAgKDAsIF9lbmZvcmNlX3R5cGVzMi5kZWZhdWx0KShfYmlnaTIuZGVmYXVsdCwgcyk7XG5cbiAgdGhpcy5yID0gcjtcbiAgdGhpcy5zID0gcztcbn1cblxuLy8gSW1wb3J0IG9wZXJhdGlvbnNcbkVDU2lnbmF0dXJlLnBhcnNlQ29tcGFjdCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgX2Fzc2VydDIuZGVmYXVsdC5lcXVhbChidWZmZXIubGVuZ3RoLCA2NSwgJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB2YXIgaSA9IGJ1ZmZlci5yZWFkVUludDgoMCkgLSAyNztcblxuICAvLyBBdCBtb3N0IDMgYml0c1xuICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGksIGkgJiA3LCAnSW52YWxpZCBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gIHZhciBjb21wcmVzc2VkID0gISEoaSAmIDQpO1xuXG4gIC8vIFJlY292ZXJ5IHBhcmFtIG9ubHlcbiAgaSA9IGkgJiAzO1xuXG4gIHZhciByID0gX2JpZ2kyLmRlZmF1bHQuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSwgMzMpKTtcbiAgdmFyIHMgPSBfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgzMykpO1xuXG4gIHJldHVybiB7XG4gICAgY29tcHJlc3NlZDogY29tcHJlc3NlZCxcbiAgICBpOiBpLFxuICAgIHNpZ25hdHVyZTogbmV3IEVDU2lnbmF0dXJlKHIsIHMpXG4gIH07XG59O1xuXG5FQ1NpZ25hdHVyZS5mcm9tREVSID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMCksIDB4MzAsICdOb3QgYSBERVIgc2VxdWVuY2UnKTtcbiAgX2Fzc2VydDIuZGVmYXVsdC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KDEpLCBidWZmZXIubGVuZ3RoIC0gMiwgJ0ludmFsaWQgc2VxdWVuY2UgbGVuZ3RoJyk7XG4gIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgyKSwgMHgwMiwgJ0V4cGVjdGVkIGEgREVSIGludGVnZXInKTtcblxuICB2YXIgckxlbiA9IGJ1ZmZlci5yZWFkVUludDgoMyk7XG4gICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShyTGVuID4gMCwgJ1IgbGVuZ3RoIGlzIHplcm8nKTtcblxuICB2YXIgb2Zmc2V0ID0gNCArIHJMZW47XG4gIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpLCAweDAyLCAnRXhwZWN0ZWQgYSBERVIgaW50ZWdlciAoMiknKTtcblxuICB2YXIgc0xlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSk7XG4gICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShzTGVuID4gMCwgJ1MgbGVuZ3RoIGlzIHplcm8nKTtcblxuICB2YXIgckIgPSBidWZmZXIuc2xpY2UoNCwgb2Zmc2V0KTtcbiAgdmFyIHNCID0gYnVmZmVyLnNsaWNlKG9mZnNldCArIDIpO1xuICBvZmZzZXQgKz0gMiArIHNMZW47XG5cbiAgaWYgKHJMZW4gPiAxICYmIHJCLnJlYWRVSW50OCgwKSA9PT0gMHgwMCkge1xuICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShyQi5yZWFkVUludDgoMSkgJiAweDgwLCAnUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgfVxuXG4gIGlmIChzTGVuID4gMSAmJiBzQi5yZWFkVUludDgoMCkgPT09IDB4MDApIHtcbiAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoc0IucmVhZFVJbnQ4KDEpICYgMHg4MCwgJ1MgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIH1cblxuICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKG9mZnNldCwgYnVmZmVyLmxlbmd0aCwgJ0ludmFsaWQgREVSIGVuY29kaW5nJyk7XG4gIHZhciByID0gX2JpZ2kyLmRlZmF1bHQuZnJvbURFUkludGVnZXIockIpO1xuICB2YXIgcyA9IF9iaWdpMi5kZWZhdWx0LmZyb21ERVJJbnRlZ2VyKHNCKTtcblxuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoci5zaWdudW0oKSA+PSAwLCAnUiB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkocy5zaWdudW0oKSA+PSAwLCAnUyB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuXG4gIHJldHVybiBuZXcgRUNTaWduYXR1cmUociwgcyk7XG59O1xuXG4vLyBGSVhNRTogMHgwMCwgMHgwNCwgMHg4MCBhcmUgU0lHSEFTSF8qIGJvdW5kYXJ5IGNvbnN0YW50cywgaW1wb3J0aW5nIFRyYW5zYWN0aW9uIGNhdXNlcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbkVDU2lnbmF0dXJlLnBhcnNlU2NyaXB0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB2YXIgaGFzaFR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgdmFyIGhhc2hUeXBlTW9kID0gaGFzaFR5cGUgJiB+MHg4MDtcblxuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoaGFzaFR5cGVNb2QgPiAweDAwICYmIGhhc2hUeXBlTW9kIDwgMHgwNCwgJ0ludmFsaWQgaGFzaFR5cGUnKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogRUNTaWduYXR1cmUuZnJvbURFUihidWZmZXIuc2xpY2UoMCwgLTEpKSxcbiAgICBoYXNoVHlwZTogaGFzaFR5cGVcbiAgfTtcbn07XG5cbi8vIEV4cG9ydCBvcGVyYXRpb25zXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9Db21wYWN0ID0gZnVuY3Rpb24gKGksIGNvbXByZXNzZWQpIHtcbiAgaWYgKGNvbXByZXNzZWQpIGkgKz0gNDtcbiAgaSArPSAyNztcblxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcig2NSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGksIDApO1xuXG4gIHRoaXMuci50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDEpO1xuICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmZmVyLCAzMyk7XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJCYSA9IHRoaXMuci50b0RFUkludGVnZXIoKTtcbiAgdmFyIHNCYSA9IHRoaXMucy50b0RFUkludGVnZXIoKTtcblxuICB2YXIgc2VxdWVuY2UgPSBbXTtcblxuICAvLyBJTlRFR0VSXG4gIHNlcXVlbmNlLnB1c2goMHgwMiwgckJhLmxlbmd0aCk7XG4gIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHJCYSk7XG5cbiAgLy8gSU5URUdFUlxuICBzZXF1ZW5jZS5wdXNoKDB4MDIsIHNCYS5sZW5ndGgpO1xuICBzZXF1ZW5jZSA9IHNlcXVlbmNlLmNvbmNhdChzQmEpO1xuXG4gIC8vIFNFUVVFTkNFXG4gIHNlcXVlbmNlLnVuc2hpZnQoMHgzMCwgc2VxdWVuY2UubGVuZ3RoKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihzZXF1ZW5jZSk7XG59O1xuXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9TY3JpcHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaGFzaFR5cGUpIHtcbiAgdmFyIGhhc2hUeXBlQnVmZmVyID0gbmV3IEJ1ZmZlcigxKTtcbiAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMudG9ERVIoKSwgaGFzaFR5cGVCdWZmZXJdKTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEVDU2lnbmF0dXJlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZW5mb3JjZTtcbmZ1bmN0aW9uIGVuZm9yY2UodHlwZSwgdmFsdWUpIHtcbiAgLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmIChnZXROYW1lKHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gZ2V0TmFtZSh0eXBlKSkgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgJyArIChnZXROYW1lKHR5cGUpIHx8IHR5cGUpICsgJywgZ290ICcgKyB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWUoZm4pIHtcbiAgLy8gV2h5IG5vdCBmbi5uYW1lOiBodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jZnVuY3Rpb25fbmFtZV9wcm9wZXJ0eVxuICB2YXIgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoLio/KVxcKC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5IbWFjU0hBMjU2ID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuc2hhMSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xuXG52YXIgX2NyZWF0ZUhhc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaCk7XG5cbnZhciBfY3JlYXRlSG1hYyA9IHJlcXVpcmUoXCJjcmVhdGUtaG1hY1wiKTtcblxudmFyIF9jcmVhdGVIbWFjMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhtYWMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuZnVuY3Rpb24gc2hhMShkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiAoMCwgX2NyZWF0ZUhhc2gyLmRlZmF1bHQpKCdzaGExJykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGEyNTYoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gKDAsIF9jcmVhdGVIYXNoMi5kZWZhdWx0KSgnc2hhMjU2JykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGE1MTIoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gKDAsIF9jcmVhdGVIYXNoMi5kZWZhdWx0KSgnc2hhNTEyJykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIEhtYWNTSEEyNTYoYnVmZmVyLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gKDAsIF9jcmVhdGVIbWFjMi5kZWZhdWx0KSgnc2hhMjU2Jywgc2VjcmV0KS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKTtcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIF9jcmVhdGVIYXNoMi5kZWZhdWx0KSgncm1kMTYwJykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufVxuXG4vLyBmdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuLy8gICByZXR1cm4gcmlwZW1kMTYwKHNoYTI1NihidWZmZXIpKVxuLy8gfVxuLy9cbi8vIGZ1bmN0aW9uIGhhc2gyNTYoYnVmZmVyKSB7XG4vLyAgIHJldHVybiBzaGEyNTYoc2hhMjU2KGJ1ZmZlcikpXG4vLyB9XG5cbi8vXG4vLyBmdW5jdGlvbiBIbWFjU0hBNTEyKGJ1ZmZlciwgc2VjcmV0KSB7XG4vLyAgIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgc2VjcmV0KS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxuLy8gfVxuXG5leHBvcnRzLnNoYTEgPSBzaGExO1xuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5leHBvcnRzLnNoYTUxMiA9IHNoYTUxMjtcbmV4cG9ydHMuSG1hY1NIQTI1NiA9IEhtYWNTSEEyNTY7XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZWNkc2EgPSByZXF1aXJlKCcuL2VjZHNhJyk7XG5cbnZhciBfaGFzaDIgPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIF9lY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxudmFyIF9hc3NlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0KTtcblxudmFyIF9iaWdpID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX2JpZ2kyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmlnaSk7XG5cbnZhciBfUHVibGljS2V5ID0gcmVxdWlyZSgnLi9QdWJsaWNLZXknKTtcblxudmFyIF9QdWJsaWNLZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibGljS2V5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHNlY3AyNTZrMSA9ICgwLCBfZWN1cnZlLmdldEN1cnZlQnlOYW1lKSgnc2VjcDI1NmsxJyk7XG5cbnZhciBTaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlKHIxLCBzMSwgaTEpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25hdHVyZSk7XG5cbiAgICAgICAgdGhpcy5yID0gcjE7XG4gICAgICAgIHRoaXMucyA9IHMxO1xuICAgICAgICB0aGlzLmkgPSBpMTtcbiAgICAgICAgX2Fzc2VydDIuZGVmYXVsdC5lcXVhbCh0aGlzLnIgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIF9hc3NlcnQyLmRlZmF1bHQuZXF1YWwodGhpcy5zICE9IG51bGwsIHRydWUsICdNaXNzaW5nIHBhcmFtZXRlcicpO1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKHRoaXMuaSAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBTaWduYXR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XG4gICAgICAgIHZhciBpLCByLCBzO1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgICAgIGkgPSBidWYucmVhZFVJbnQ4KDApO1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGkgLSAyNywgaSAtIDI3ICYgNywgJ0ludmFsaWQgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgICAgICByID0gX2JpZ2kyLmRlZmF1bHQuZnJvbUJ1ZmZlcihidWYuc2xpY2UoMSwgMzMpKTtcbiAgICAgICAgcyA9IF9iaWdpMi5kZWZhdWx0LmZyb21CdWZmZXIoYnVmLnNsaWNlKDMzKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMsIGkpO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgIHZhciBidWY7XG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoNjUpO1xuICAgICAgICBidWYud3JpdGVVSW50OCh0aGlzLmksIDApO1xuICAgICAgICB0aGlzLnIudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAxKTtcbiAgICAgICAgdGhpcy5zLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZiwgMzMpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnJlY292ZXJQdWJsaWNLZXlGcm9tQnVmZmVyID0gZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleUZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJQdWJsaWNLZXkoKDAsIF9oYXNoMi5zaGEyNTYpKGJ1ZmZlcikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgQHJldHVybiB7UHVibGljS2V5fVxuICAgICovXG4gICAgU2lnbmF0dXJlLnByb3RvdHlwZS5yZWNvdmVyUHVibGljS2V5ID0gZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShzaGEyNTZfYnVmZmVyKSB7XG4gICAgICAgIHZhciBRID0gdm9pZCAwLFxuICAgICAgICAgICAgZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGkgPSB2b2lkIDA7XG4gICAgICAgIGUgPSBfYmlnaTIuZGVmYXVsdC5mcm9tQnVmZmVyKHNoYTI1Nl9idWZmZXIpO1xuICAgICAgICBpID0gdGhpcy5pO1xuICAgICAgICBpIC09IDI3O1xuICAgICAgICBpID0gaSAmIDM7XG4gICAgICAgIFEgPSAoMCwgX2VjZHNhLnJlY292ZXJQdWJLZXkpKHNlY3AyNTZrMSwgZSwgdGhpcywgaSk7XG4gICAgICAgIHJldHVybiBfUHVibGljS2V5Mi5kZWZhdWx0LmZyb21Qb2ludChRKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgKi9cbiAgICBTaWduYXR1cmUuc2lnbkJ1ZmZlciA9IGZ1bmN0aW9uIHNpZ25CdWZmZXIoYnVmLCBwcml2YXRlX2tleSkge1xuICAgICAgICB2YXIgX2hhc2ggPSAoMCwgX2hhc2gyLnNoYTI1NikoYnVmKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyU2hhMjU2KF9oYXNoLCBwcml2YXRlX2tleSk7XG4gICAgfTtcblxuICAgIC8qKiBTaWduIGEgYnVmZmVyIG9mIGV4YWN0YWxseSAzMiBieXRlcyBpbiBzaXplIChzaGEyNTYodGV4dCkpXG4gICAgICAgIEBwYXJhbSB7QnVmZmVyfSBidWYgLSAzMiBieXRlcyBiaW5hcnlcbiAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgKi9cblxuXG4gICAgU2lnbmF0dXJlLnNpZ25CdWZmZXJTaGEyNTYgPSBmdW5jdGlvbiBzaWduQnVmZmVyU2hhMjU2KGJ1Zl9zaGEyNTYsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgIGlmIChidWZfc2hhMjU2Lmxlbmd0aCAhPT0gMzIgfHwgIUJ1ZmZlci5pc0J1ZmZlcihidWZfc2hhMjU2KSkgdGhyb3cgbmV3IEVycm9yKFwiYnVmX3NoYTI1NjogMzIgYnl0ZSBidWZmZXIgcmVxdXJlZFwiKTtcbiAgICAgICAgdmFyIGRlciwgZSwgZWNzaWduYXR1cmUsIGksIGxlblIsIGxlblMsIG5vbmNlO1xuICAgICAgICBpID0gbnVsbDtcbiAgICAgICAgbm9uY2UgPSAwO1xuICAgICAgICBlID0gX2JpZ2kyLmRlZmF1bHQuZnJvbUJ1ZmZlcihidWZfc2hhMjU2KTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGVjc2lnbmF0dXJlID0gKDAsIF9lY2RzYS5zaWduKShzZWNwMjU2azEsIGJ1Zl9zaGEyNTYsIHByaXZhdGVfa2V5LmQsIG5vbmNlKyspO1xuICAgICAgICAgICAgZGVyID0gZWNzaWduYXR1cmUudG9ERVIoKTtcbiAgICAgICAgICAgIGxlblIgPSBkZXJbM107XG4gICAgICAgICAgICBsZW5TID0gZGVyWzUgKyBsZW5SXTtcbiAgICAgICAgICAgIGlmIChsZW5SID09PSAzMiAmJiBsZW5TID09PSAzMikge1xuICAgICAgICAgICAgICAgIGkgPSAoMCwgX2VjZHNhLmNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtKShzZWNwMjU2azEsIGUsIGVjc2lnbmF0dXJlLCBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLlEpO1xuICAgICAgICAgICAgICAgIGkgKz0gNDsgLy8gY29tcHJlc3NlZFxuICAgICAgICAgICAgICAgIGkgKz0gMjc7IC8vIGNvbXBhY3QgIC8vICAyNCBvciAyNyA6KCBmb3JjaW5nIG9kZC15IDJuZCBrZXkgY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vbmNlICUgMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IFwiICsgbm9uY2UgKyBcIiBhdHRlbXB0cyB0byBmaW5kIGNhbm9uaWNhbCBzaWduYXR1cmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoZWNzaWduYXR1cmUuciwgZWNzaWduYXR1cmUucywgaSk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZS5zaWduID0gZnVuY3Rpb24gc2lnbihzdHJpbmcsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuc2lnbkJ1ZmZlcihuZXcgQnVmZmVyKHN0cmluZyksIHByaXZhdGVfa2V5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIEBwYXJhbSB7QnVmZmVyfSB1bi1oYXNoZWRcbiAgICAgICAgQHBhcmFtIHsuL1B1YmxpY0tleX1cbiAgICAgICAgQHJldHVybiB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUudmVyaWZ5QnVmZmVyID0gZnVuY3Rpb24gdmVyaWZ5QnVmZmVyKGJ1ZiwgcHVibGljX2tleSkge1xuICAgICAgICB2YXIgX2hhc2ggPSAoMCwgX2hhc2gyLnNoYTI1NikoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5SGFzaChfaGFzaCwgcHVibGljX2tleSk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUudmVyaWZ5SGFzaCA9IGZ1bmN0aW9uIHZlcmlmeUhhc2goaGFzaCwgcHVibGljX2tleSkge1xuICAgICAgICBfYXNzZXJ0Mi5kZWZhdWx0LmVxdWFsKGhhc2gubGVuZ3RoLCAzMiwgXCJBIFNIQSAyNTYgc2hvdWxkIGJlIDMyIGJ5dGVzIGxvbmcsIGluc3RlYWQgZ290IFwiICsgaGFzaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKDAsIF9lY2RzYS52ZXJpZnkpKHNlY3AyNTZrMSwgaGFzaCwge1xuICAgICAgICAgICAgcjogdGhpcy5yLFxuICAgICAgICAgICAgczogdGhpcy5zXG4gICAgICAgIH0sIHB1YmxpY19rZXkuUSk7XG4gICAgfTtcblxuICAgIC8qIDxIRVg+ICovXG5cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgdmFyIGI7XG4gICAgICAgIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZS5mcm9tSGV4ID0gZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCBcImhleFwiKSk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZyhcImhleFwiKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlLnNpZ25IZXggPSBmdW5jdGlvbiBzaWduSGV4KGhleCwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyKGJ1ZiwgcHJpdmF0ZV9rZXkpO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnZlcmlmeUhleCA9IGZ1bmN0aW9uIHZlcmlmeUhleChoZXgsIHB1YmxpY19rZXkpIHtcbiAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5QnVmZmVyKGJ1ZiwgcHVibGljX2tleSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTaWduYXR1cmU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNpZ25hdHVyZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5TZXJpYWxpemVyVmFsaWRhdGlvbiA9IGV4cG9ydHMudGVtcGxhdGUgPSBleHBvcnRzLm9wcyA9IGV4cG9ydHMudHlwZXMgPSBleHBvcnRzLmZwID0gZXhwb3J0cy5TZXJpYWxpemVyID0gdW5kZWZpbmVkO1xuXG52YXIgX3NlcmlhbGl6ZXIgPSByZXF1aXJlKFwiLi9zcmMvc2VyaWFsaXplclwiKTtcblxudmFyIF9zZXJpYWxpemVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlcmlhbGl6ZXIpO1xuXG52YXIgX0Zhc3RQYXJzZXIgPSByZXF1aXJlKFwiLi9zcmMvRmFzdFBhcnNlclwiKTtcblxudmFyIF9GYXN0UGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Zhc3RQYXJzZXIpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vc3JjL3R5cGVzXCIpO1xuXG52YXIgX3R5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVzKTtcblxudmFyIF9vcGVyYXRpb25zID0gcmVxdWlyZShcIi4vc3JjL29wZXJhdGlvbnNcIik7XG5cbnZhciBvcHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfb3BlcmF0aW9ucyk7XG5cbnZhciBfdGVtcGxhdGUgPSByZXF1aXJlKFwiLi9zcmMvdGVtcGxhdGVcIik7XG5cbnZhciBfdGVtcGxhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVtcGxhdGUpO1xuXG52YXIgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uID0gcmVxdWlyZShcIi4vc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uXCIpO1xuXG52YXIgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlcmlhbGl6ZXJWYWxpZGF0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5TZXJpYWxpemVyID0gX3NlcmlhbGl6ZXIyLmRlZmF1bHQ7XG5leHBvcnRzLmZwID0gX0Zhc3RQYXJzZXIyLmRlZmF1bHQ7XG5leHBvcnRzLnR5cGVzID0gX3R5cGVzMi5kZWZhdWx0O1xuZXhwb3J0cy5vcHMgPSBvcHM7XG5leHBvcnRzLnRlbXBsYXRlID0gX3RlbXBsYXRlMi5kZWZhdWx0O1xuZXhwb3J0cy5TZXJpYWxpemVyVmFsaWRhdGlvbiA9IF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUHVibGljS2V5ID0gcmVxdWlyZSgnLi4vLi4vZWNjL3NyYy9QdWJsaWNLZXknKTtcblxudmFyIF9QdWJsaWNLZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibGljS2V5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEZhc3RQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdFBhcnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZhc3RQYXJzZXIpO1xuICAgIH1cblxuICAgIEZhc3RQYXJzZXIuZml4ZWRfZGF0YSA9IGZ1bmN0aW9uIGZpeGVkX2RhdGEoYiwgbGVuLCBidWZmZXIpIHtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2xpY2UoMCwgbGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICBiLmFwcGVuZChkYXRhLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0gPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGIud3JpdGVVaW50OCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgICAgIGIuc2tpcChsZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGYXN0UGFyc2VyLnB1YmxpY19rZXkgPSBmdW5jdGlvbiBwdWJsaWNfa2V5KGIsIF9wdWJsaWNfa2V5KSB7XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IF9wdWJsaWNfa2V5LnRvQnVmZmVyKCk7XG4gICAgICAgICAgICBiLmFwcGVuZChidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgPSBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMzMpO1xuICAgICAgICAgICAgcmV0dXJuIF9QdWJsaWNLZXkyLmRlZmF1bHQuZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEZhc3RQYXJzZXIucmlwZW1kMTYwID0gZnVuY3Rpb24gcmlwZW1kMTYwKGIsIF9yaXBlbWQpIHtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9yaXBlbWQpIHtcbiAgICAgICAgICAgIEZhc3RQYXJzZXIuZml4ZWRfZGF0YShiLCAyMCwgX3JpcGVtZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDIwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGYXN0UGFyc2VyLnRpbWVfcG9pbnRfc2VjID0gZnVuY3Rpb24gdGltZV9wb2ludF9zZWMoYiwgZXBvY2gpIHtcbiAgICAgICAgaWYgKGVwb2NoKSB7XG4gICAgICAgICAgICBlcG9jaCA9IE1hdGguY2VpbChlcG9jaCAvIDEwMDApO1xuICAgICAgICAgICAgYi53cml0ZUludDMyKGVwb2NoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVwb2NoID0gYi5yZWFkSW50MzIoKTsgLy8gZmM6OnRpbWVfcG9pbnRfc2VjXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY2ggKiAxMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmFzdFBhcnNlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmFzdFBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfYnl0ZWJ1ZmZlciA9IHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpO1xuXG52YXIgX0NoYWluVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL0NoYWluVHlwZXNcIik7XG5cbnZhciBfQ2hhaW5UeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DaGFpblR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIE1BWF9TQUZFX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTUlOX1NBRkVfSU5UID0gLTkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICAgIE1vc3QgdmFsaWRhdGlvbnMgYXJlIHNraXBwZWQgYW5kIHRoZSB2YWx1ZSByZXR1cm5lZCB1bmNoYW5nZWQgd2hlbiBhbiBlbXB0eSBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCBpcyBlbmNvdW50ZXJlZCAoZXhjZXB0IFwicmVxdWlyZWRcIikuXG5cbiAgICBWYWxpZGF0aW9ucyBzdXBwb3J0IGEgc3RyaW5nIGZvcm1hdCBmb3IgZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMuXG4qL1xudmFyIF9teSA9IHtcbiAgICBpc19lbXB0eTogZnVuY3Rpb24gaXNfZW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIHJlcXVpcmVkOiBmdW5jdGlvbiByZXF1aXJlZCh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIHJlcXVpcmVkIFwiICsgZmllbGRfbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlcXVpcmVfbG9uZzogZnVuY3Rpb24gcmVxdWlyZV9sb25nKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICghX2J5dGVidWZmZXIuTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb25nIHZhbHVlIHJlcXVpcmVkIFwiICsgZmllbGRfbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZDogXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIHJlcXVpcmVkOiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB3aG9sZV9udW1iZXI6IGZ1bmN0aW9uIHdob2xlX251bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcLi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndob2xlIG51bWJlciByZXF1aXJlZCBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB1bnNpZ25lZDogZnVuY3Rpb24gdW5zaWduZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC8tLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zaWduZWQgcmVxdWlyZWQgXCIgKyBmaWVsZF9uYW1lICsgXCIgXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIGlzX2RpZ2l0czogZnVuY3Rpb24gaXNfZGlnaXRzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC9eWzAtOV0rJC8udGVzdCh2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdG9fbnVtYmVyOiBmdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub19vdmVyZmxvdzUzKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgdmFyIGludF92YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIGludF92YWx1ZTtcbiAgICB9LFxuXG4gICAgdG9fbG9uZzogZnVuY3Rpb24gdG9fbG9uZyh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcbiAgICAgICAgdmFyIHVuc2lnbmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2J5dGVidWZmZXIuTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vX292ZXJmbG93NjQodmFsdWUsIGZpZWxkX25hbWUsIHVuc2lnbmVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ieXRlYnVmZmVyLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQpO1xuICAgIH0sXG4gICAgdG9fc3RyaW5nOiBmdW5jdGlvbiB0b19zdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfYnl0ZWJ1ZmZlci5Mb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgdHlwZSBcIiArIGZpZWxkX25hbWUgKyBcIjogKFwiICsgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgKyBcIikgXCIgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHJlcXVpcmVfdGVzdDogZnVuY3Rpb24gcmVxdWlyZV90ZXN0KHJlZ2V4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bm1hdGNoZWQgXCIgKyByZWdleCArIFwiIFwiICsgZmllbGRfbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX21hdGNoOiBmdW5jdGlvbiByZXF1aXJlX21hdGNoKHJlZ2V4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5tYXRjaGVkIFwiICsgcmVnZXggKyBcIiBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSxcblxuICAgIHJlcXVpcmVfb2JqZWN0X2lkOiBmdW5jdGlvbiByZXF1aXJlX29iamVjdF9pZCh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZV9tYXRjaCgvXihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSQvLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgfSxcblxuICAgIC8vIERvZXMgbm90IHN1cHBvcnQgb3ZlciA1MyBiaXRzXG4gICAgcmVxdWlyZV9yYW5nZTogZnVuY3Rpb24gcmVxdWlyZV9yYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMudG9fbnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQgb2YgcmFuZ2UgXCIgKyB2YWx1ZSArIFwiIFwiICsgZmllbGRfbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX29iamVjdF90eXBlOiBmdW5jdGlvbiByZXF1aXJlX29iamVjdF90eXBlKCkge1xuICAgICAgICB2YXIgcmVzZXJ2ZWRfc3BhY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqZWN0X3R5cGUgPSBfQ2hhaW5UeXBlczIuZGVmYXVsdC5vYmplY3RfdHlwZVt0eXBlXTtcbiAgICAgICAgaWYgKCFvYmplY3RfdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3QgdHlwZSBcIiArIHR5cGUgKyBcIiBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHJlc2VydmVkX3NwYWNlcyArIFwiLlwiICsgb2JqZWN0X3R5cGUgKyBcIi5bMC05XSskXCIpO1xuICAgICAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgXCIgKyB0eXBlICsgXCIgaW4gZm9ybWF0IFwiICsgKHJlc2VydmVkX3NwYWNlcyArIFwiLlwiICsgb2JqZWN0X3R5cGUgKyBcIi5bMC05XSsgXCIpICsgKFwiaW5zdGVhZCBvZiBcIiArIHZhbHVlICsgXCIgXCIgKyBmaWVsZF9uYW1lICsgXCIgXCIgKyB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0X2luc3RhbmNlOiBmdW5jdGlvbiBnZXRfaW5zdGFuY2UocmVzZXJ2ZV9zcGFjZXMsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZShyZXNlcnZlX3NwYWNlcywgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWUuc3BsaXQoXCIuXCIpWzJdKTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9yZWxhdGl2ZV90eXBlOiBmdW5jdGlvbiByZXF1aXJlX3JlbGF0aXZlX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlX29iamVjdF90eXBlKDAsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfcmVsYXRpdmVfaW5zdGFuY2U6IGZ1bmN0aW9uIGdldF9yZWxhdGl2ZV9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMCwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWUuc3BsaXQoXCIuXCIpWzJdKTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9wcm90b2NvbF90eXBlOiBmdW5jdGlvbiByZXF1aXJlX3Byb3RvY29sX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlX29iamVjdF90eXBlKDEsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfaW5zdGFuY2U6IGZ1bmN0aW9uIGdldF9wcm90b2NvbF9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMSwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWUuc3BsaXQoXCIuXCIpWzJdKTtcbiAgICB9LFxuXG4gICAgZ2V0X3Byb3RvY29sX3R5cGU6IGZ1bmN0aW9uIGdldF9wcm90b2NvbF90eXBlKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfaWQodmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWVzWzFdKTtcbiAgICB9LFxuXG4gICAgZ2V0X3Byb3RvY29sX3R5cGVfbmFtZTogZnVuY3Rpb24gZ2V0X3Byb3RvY29sX3R5cGVfbmFtZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZV9pZCA9IHRoaXMuZ2V0X3Byb3RvY29sX3R5cGUodmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoX0NoYWluVHlwZXMyLmRlZmF1bHQub2JqZWN0X3R5cGUpW3R5cGVfaWRdO1xuICAgIH0sXG5cblxuICAgIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZTogZnVuY3Rpb24gcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl90eXBlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0X2ltcGxlbWVudGF0aW9uX2luc3RhbmNlOiBmdW5jdGlvbiBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2UodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1aXJlX29iamVjdF90eXBlKDIsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fbnVtYmVyKHZhbHVlLnNwbGl0KFwiLlwiKVsyXSk7XG4gICAgfSxcblxuICAgIC8vIHNpZ25lZCAvIHVuc2lnbmVkIGRlY2ltYWxcbiAgICBub19vdmVyZmxvdzUzOiBmdW5jdGlvbiBub19vdmVyZmxvdzUzKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93IFwiICsgZmllbGRfbmFtZSArIFwiIFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBpbnQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvdyBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2J5dGVidWZmZXIuTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyB0eXBlb2YgdmFsdWUudG9JbnQoKSBpcyAnbnVtYmVyJ1xuICAgICAgICAgICAgdGhpcy5ub19vdmVyZmxvdzUzKHZhbHVlLnRvSW50KCksIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgdHlwZSBcIiArIGZpZWxkX25hbWUgKyBcIjogKFwiICsgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgKyBcIikgXCIgKyB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICAvLyBzaWduZWQgLyB1bnNpZ25lZCB3aG9sZSBudW1iZXJzIG9ubHlcbiAgICBub19vdmVyZmxvdzY0OiBmdW5jdGlvbiBub19vdmVyZmxvdzY0KHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuICAgICAgICB2YXIgdW5zaWduZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL0xvbmcuanMvaXNzdWVzLzIwXG4gICAgICAgIGlmIChfYnl0ZWJ1ZmZlci5Mb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpZ0ludGVnZXIjaXNCaWdJbnRlZ2VyIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaS9pc3N1ZXMvMjBcbiAgICAgICAgaWYgKHZhbHVlLnQgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubm9fb3ZlcmZsb3c2NCh2YWx1ZS50b1N0cmluZygpLCBmaWVsZF9uYW1lLCB1bnNpZ25lZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyB6ZXJvcywgd2lsbCBjYXVzZSBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14wKy8sIFwiXCIpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICB3aGlsZSAoLzAkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXC4kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyBkb3RcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9uZ19zdHJpbmcgPSBfYnl0ZWJ1ZmZlci5Mb25nLmZyb21TdHJpbmcodmFsdWUsIHVuc2lnbmVkKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGxvbmdfc3RyaW5nICE9PSB2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvdyBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvdyBcIiArIGZpZWxkX25hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgdHlwZSBcIiArIGZpZWxkX25hbWUgKyBcIjogKFwiICsgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgKyBcIikgXCIgKyB2YWx1ZTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfbXk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogRXhjZXB0aW9uIG5lc3RpbmcuICAqL1xudmFyIEVycm9yV2l0aENhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yV2l0aENhdXNlKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvcldpdGhDYXVzZSk7XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLm1lc3NhZ2UgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiY2F1c2VcXHRcIiArIGNhdXNlLm1lc3NhZ2UgKyBcIlxcdFwiICsgdGhpcy5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gXCJcIjsgLy8obmV3IEVycm9yKS5zdGFja1xuICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrID0gXCJjYXVzZWQgYnlcXG5cXHRcIiArIGNhdXNlLnN0YWNrICsgXCJcXHRcIiArIHN0YWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcbiAgICB9XG5cbiAgICBFcnJvcldpdGhDYXVzZS50aHJvdyA9IGZ1bmN0aW9uIF90aHJvdyhtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICB2YXIgbXNnID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLm1lc3NhZ2UgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIlxcdCBjYXVzZTogXCIgKyBjYXVzZS5tZXNzYWdlICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLnN0YWNrIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCJcXG4gc3RhY2s6IFwiICsgY2F1c2Uuc3RhY2sgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEVycm9yV2l0aENhdXNlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFcnJvcldpdGhDYXVzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnN0ZWFsdGhfbWVtb19kYXRhID0gZXhwb3J0cy5zaWduZWRfdHJhbnNhY3Rpb24gPSBleHBvcnRzLnRyYW5zYWN0aW9uID0gZXhwb3J0cy5hc3NldF9jbGFpbV9mZWVzID0gZXhwb3J0cy5hc3NldF9zZXR0bGVfY2FuY2VsID0gZXhwb3J0cy50cmFuc2Zlcl9mcm9tX2JsaW5kID0gZXhwb3J0cy5ibGluZF90cmFuc2ZlciA9IGV4cG9ydHMuYmxpbmRfaW5wdXQgPSBleHBvcnRzLnRyYW5zZmVyX3RvX2JsaW5kID0gZXhwb3J0cy5ibGluZF9vdXRwdXQgPSBleHBvcnRzLnN0ZWFsdGhfY29uZmlybWF0aW9uID0gZXhwb3J0cy5vdmVycmlkZV90cmFuc2ZlciA9IGV4cG9ydHMuYmFsYW5jZV9jbGFpbSA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5ibG9ja19pZF9wcmVkaWNhdGUgPSBleHBvcnRzLmFzc2V0X3N5bWJvbF9lcV9saXRfcHJlZGljYXRlID0gZXhwb3J0cy5hY2NvdW50X25hbWVfZXFfbGl0X3ByZWRpY2F0ZSA9IGV4cG9ydHMuY3VzdG9tID0gZXhwb3J0cy53b3JrZXJfY3JlYXRlID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5idXJuX3dvcmtlcl9pbml0aWFsaXplciA9IGV4cG9ydHMudmVzdGluZ19iYWxhbmNlX3dvcmtlcl9pbml0aWFsaXplciA9IGV4cG9ydHMucmVmdW5kX3dvcmtlcl9pbml0aWFsaXplciA9IGV4cG9ydHMudmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3ID0gZXhwb3J0cy52ZXN0aW5nX2JhbGFuY2VfY3JlYXRlID0gZXhwb3J0cy5jZGRfdmVzdGluZ19wb2xpY3lfaW5pdGlhbGl6ZXIgPSBleHBvcnRzLmxpbmVhcl92ZXN0aW5nX3BvbGljeV9pbml0aWFsaXplciA9IGV4cG9ydHMuY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnMgPSBleHBvcnRzLmNoYWluX3BhcmFtZXRlcnMgPSBleHBvcnRzLmNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX2NyZWF0ZSA9IGV4cG9ydHMud2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGUgPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fY2xhaW0gPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fdXBkYXRlID0gZXhwb3J0cy53aXRoZHJhd19wZXJtaXNzaW9uX2NyZWF0ZSA9IGV4cG9ydHMucHJvcG9zYWxfZGVsZXRlID0gZXhwb3J0cy5wcm9wb3NhbF91cGRhdGUgPSBleHBvcnRzLnByb3Bvc2FsX2NyZWF0ZSA9IGV4cG9ydHMub3Bfd3JhcHBlciA9IGV4cG9ydHMud2l0bmVzc191cGRhdGUgPSBleHBvcnRzLndpdG5lc3NfY3JlYXRlID0gZXhwb3J0cy5hc3NldF9wdWJsaXNoX2ZlZWQgPSBleHBvcnRzLnByaWNlX2ZlZWQgPSBleHBvcnRzLmFzc2V0X2dsb2JhbF9zZXR0bGUgPSBleHBvcnRzLmFzc2V0X3NldHRsZSA9IGV4cG9ydHMuYXNzZXRfZnVuZF9mZWVfcG9vbCA9IGV4cG9ydHMuYXNzZXRfcmVzZXJ2ZSA9IGV4cG9ydHMuYXNzZXRfaXNzdWUgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2VycyA9IGV4cG9ydHMuYXNzZXRfdXBkYXRlX2JpdGFzc2V0ID0gZXhwb3J0cy5hc3NldF91cGRhdGUgPSBleHBvcnRzLmFzc2V0X2NyZWF0ZSA9IGV4cG9ydHMuYml0YXNzZXRfb3B0aW9ucyA9IGV4cG9ydHMuYXNzZXRfb3B0aW9ucyA9IGV4cG9ydHMucHJpY2UgPSBleHBvcnRzLmFjY291bnRfdHJhbnNmZXIgPSBleHBvcnRzLmFjY291bnRfdXBncmFkZSA9IGV4cG9ydHMuYWNjb3VudF93aGl0ZWxpc3QgPSBleHBvcnRzLmFjY291bnRfdXBkYXRlID0gZXhwb3J0cy5hY2NvdW50X2NyZWF0ZSA9IGV4cG9ydHMuYWNjb3VudF9vcHRpb25zID0gZXhwb3J0cy5hdXRob3JpdHkgPSBleHBvcnRzLmZpbGxfb3JkZXIgPSBleHBvcnRzLmNhbGxfb3JkZXJfdXBkYXRlID0gZXhwb3J0cy5saW1pdF9vcmRlcl9jYW5jZWwgPSBleHBvcnRzLmxpbWl0X29yZGVyX2NyZWF0ZSA9IGV4cG9ydHMudHJhbnNmZXIgPSBleHBvcnRzLm1lbW9fZGF0YSA9IGV4cG9ydHMuc2lnbmVkX2Jsb2NrX2hlYWRlciA9IGV4cG9ydHMuYmxvY2tfaGVhZGVyID0gZXhwb3J0cy5zaWduZWRfYmxvY2sgPSBleHBvcnRzLnByb2Nlc3NlZF90cmFuc2FjdGlvbiA9IGV4cG9ydHMuYXNzZXQgPSBleHBvcnRzLnZvaWRfcmVzdWx0ID0gZXhwb3J0cy5mZWVfc2NoZWR1bGUgPSBleHBvcnRzLmFzc2V0X2NsYWltX2ZlZXNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9zZXR0bGVfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudHJhbnNmZXJfZnJvbV9ibGluZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmJsaW5kX3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudHJhbnNmZXJfdG9fYmxpbmRfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5vdmVycmlkZV90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmJhbGFuY2VfY2xhaW1fb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NlcnRfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jdXN0b21fb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy53b3JrZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudmVzdGluZ19iYWxhbmNlX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlX2dsb2JhbF9wYXJhbWV0ZXJzX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuY29tbWl0dGVlX21lbWJlcl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fZGVsZXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMud2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMud2l0aGRyYXdfcGVybWlzc2lvbl9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5wcm9wb3NhbF9kZWxldGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5wcm9wb3NhbF91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5wcm9wb3NhbF9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy53aXRuZXNzX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLndpdG5lc3NfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXRfcHVibGlzaF9mZWVkX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXRfZ2xvYmFsX3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X2Z1bmRfZmVlX3Bvb2xfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9yZXNlcnZlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXRfaXNzdWVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF91cGRhdGVfZmVlZF9wcm9kdWNlcnNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF91cGRhdGVfYml0YXNzZXRfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hY2NvdW50X3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYWNjb3VudF91cGdyYWRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYWNjb3VudF93aGl0ZWxpc3Rfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hY2NvdW50X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFjY291bnRfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuZmlsbF9vcmRlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmNhbGxfb3JkZXJfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMubGltaXRfb3JkZXJfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMubGltaXRfb3JkZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5vcGVyYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxudmFyIF90eXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlcyk7XG5cbnZhciBfc2VyaWFsaXplciA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIik7XG5cbnZhciBfc2VyaWFsaXplcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXJpYWxpemVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHVpbnQ4ID0gX3R5cGVzMi5kZWZhdWx0LnVpbnQ4LFxuICAgIHVpbnQxNiA9IF90eXBlczIuZGVmYXVsdC51aW50MTYsXG4gICAgdWludDMyID0gX3R5cGVzMi5kZWZhdWx0LnVpbnQzMixcbiAgICBpbnQ2NCA9IF90eXBlczIuZGVmYXVsdC5pbnQ2NCxcbiAgICB1aW50NjQgPSBfdHlwZXMyLmRlZmF1bHQudWludDY0LFxuICAgIHN0cmluZyA9IF90eXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gICAgYnl0ZXMgPSBfdHlwZXMyLmRlZmF1bHQuYnl0ZXMsXG4gICAgYm9vbCA9IF90eXBlczIuZGVmYXVsdC5ib29sLFxuICAgIGFycmF5ID0gX3R5cGVzMi5kZWZhdWx0LmFycmF5LFxuICAgIGZpeGVkX2FycmF5ID0gX3R5cGVzMi5kZWZhdWx0LmZpeGVkX2FycmF5LFxuICAgIHByb3RvY29sX2lkX3R5cGUgPSBfdHlwZXMyLmRlZmF1bHQucHJvdG9jb2xfaWRfdHlwZSxcbiAgICBvYmplY3RfaWRfdHlwZSA9IF90eXBlczIuZGVmYXVsdC5vYmplY3RfaWRfdHlwZSxcbiAgICB2b3RlX2lkID0gX3R5cGVzMi5kZWZhdWx0LnZvdGVfaWQsXG4gICAgZnV0dXJlX2V4dGVuc2lvbnMgPSBfdHlwZXMyLmRlZmF1bHQuZnV0dXJlX2V4dGVuc2lvbnMsXG4gICAgc3RhdGljX3ZhcmlhbnQgPSBfdHlwZXMyLmRlZmF1bHQuc3RhdGljX3ZhcmlhbnQsXG4gICAgbWFwID0gX3R5cGVzMi5kZWZhdWx0Lm1hcCxcbiAgICBzZXQgPSBfdHlwZXMyLmRlZmF1bHQuc2V0LFxuICAgIHB1YmxpY19rZXkgPSBfdHlwZXMyLmRlZmF1bHQucHVibGljX2tleSxcbiAgICBhZGRyZXNzID0gX3R5cGVzMi5kZWZhdWx0LmFkZHJlc3MsXG4gICAgdGltZV9wb2ludF9zZWMgPSBfdHlwZXMyLmRlZmF1bHQudGltZV9wb2ludF9zZWMsXG4gICAgb3B0aW9uYWwgPSBfdHlwZXMyLmRlZmF1bHQub3B0aW9uYWw7XG5cblxuZnV0dXJlX2V4dGVuc2lvbnMgPSBfdHlwZXMyLmRlZmF1bHQudm9pZDtcblxuLypcbldoZW4gdXBkYXRpbmcgZ2VuZXJhdGVkIGNvZGVcblJlcGxhY2U6ICBvcGVyYXRpb24gPSBzdGF0aWNfdmFyaWFudCBbXG53aXRoOiAgICAgb3BlcmF0aW9uLnN0X29wZXJhdGlvbnMgPSBbXG5cbkRlbGV0ZTpcbnB1YmxpY19rZXkgPSBuZXcgU2VyaWFsaXplcihcbiAgICBcInB1YmxpY19rZXlcIlxuICAgIGtleV9kYXRhOiBieXRlcyAzM1xuKVxuXG4qL1xuLy8gUGxhY2UtaG9sZGVyLCB0aGVpciBhcmUgZGVwZW5kZW5jaWVzIG9uIFwib3BlcmF0aW9uXCIgLi4gVGhlIGZpbmFsIGxpc3Qgb2Zcbi8vIG9wZXJhdGlvbnMgaXMgbm90IGF2aWFsYmxlIHVudGlsIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4vLyBTZWU6IG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gLi4uXG52YXIgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQoKTtcbi8vIG1vZHVsZS5leHBvcnRzW1wib3BlcmF0aW9uXCJdID0gb3BlcmF0aW9uO1xuXG5leHBvcnRzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbi8vIEZvciBtb2R1bGUuZXhwb3J0c1xuXG52YXIgU2VyaWFsaXplciA9IGZ1bmN0aW9uIFNlcmlhbGl6ZXIob3BlcmF0aW9uX25hbWUsIHNlcmlsaXphdGlvbl90eXBlc19vYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IF9zZXJpYWxpemVyMi5kZWZhdWx0KG9wZXJhdGlvbl9uYW1lLCBzZXJpbGl6YXRpb25fdHlwZXNfb2JqZWN0KTtcbiAgICAvLyByZXR1cm4gbW9kdWxlLmV4cG9ydHNbb3BlcmF0aW9uX25hbWVdID0gcztcbn07XG5cbi8vIEN1c3RvbS10eXBlcyBmb2xsb3cgR2VuZXJhdGVkIGNvZGU6XG5cbi8vICMjICBHZW5lcmF0ZWQgY29kZSBmb2xsb3dzXG4vLyAjIHByb2dyYW1zL2pzX29wZXJhdGlvbl9zZXJpYWxpemVyID4gbnBtIGkgLWcgZGVjYWZmZWluYXRlXG4vLyAjIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy50cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgbGltaXRfb3JkZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMubGltaXRfb3JkZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgbGltaXRfb3JkZXJfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMubGltaXRfb3JkZXJfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgY2FsbF9vcmRlcl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jYWxsX29yZGVyX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImNhbGxfb3JkZXJfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgZmlsbF9vcmRlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmZpbGxfb3JkZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJmaWxsX29yZGVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiKTtcblxudmFyIGFjY291bnRfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYWNjb3VudF9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBiYXNpY19mZWU6IHVpbnQ2NCxcbiAgICBwcmVtaXVtX2ZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgYWNjb3VudF91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hY2NvdW50X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogaW50NjQsXG4gICAgcHJpY2VfcGVyX2tieXRlOiB1aW50MzIgfSk7XG5cbnZhciBhY2NvdW50X3doaXRlbGlzdF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFjY291bnRfd2hpdGVsaXN0X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF93aGl0ZWxpc3Rfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzXCIsIHsgZmVlOiBpbnQ2NCB9KTtcblxudmFyIGFjY291bnRfdXBncmFkZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFjY291bnRfdXBncmFkZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfdXBncmFkZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBtZW1iZXJzaGlwX2FubnVhbF9mZWU6IHVpbnQ2NCxcbiAgICBtZW1iZXJzaGlwX2xpZmV0aW1lX2ZlZTogdWludDY0IH0pO1xuXG52YXIgYWNjb3VudF90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFjY291bnRfdHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgYXNzZXRfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXRfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IHN5bWJvbDM6IHVpbnQ2NCxcbiAgICBzeW1ib2w0OiB1aW50NjQsXG4gICAgbG9uZ19zeW1ib2w6IHVpbnQ2NCxcbiAgICBwcmljZV9wZXJfa2J5dGU6IHVpbnQzMiB9KTtcblxudmFyIGFzc2V0X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCxcbiAgICBwcmljZV9wZXJfa2J5dGU6IHVpbnQzMiB9KTtcblxudmFyIGFzc2V0X3VwZGF0ZV9iaXRhc3NldF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9iaXRhc3NldF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3VwZGF0ZV9iaXRhc3NldF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2Vyc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2Vyc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2Vyc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X2lzc3VlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXRfaXNzdWVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF9pc3N1ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCxcbiAgICBwcmljZV9wZXJfa2J5dGU6IHVpbnQzMiB9KTtcblxudmFyIGFzc2V0X3Jlc2VydmVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9yZXNlcnZlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfcmVzZXJ2ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X2Z1bmRfZmVlX3Bvb2xfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9mdW5kX2ZlZV9wb29sX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfZnVuZF9mZWVfcG9vbF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X2dsb2JhbF9zZXR0bGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9nbG9iYWxfc2V0dGxlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfZ2xvYmFsX3NldHRsZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGFzc2V0X3B1Ymxpc2hfZmVlZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3B1Ymxpc2hfZmVlZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3B1Ymxpc2hfZmVlZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIHdpdG5lc3NfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMud2l0bmVzc19jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRuZXNzX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIHdpdG5lc3NfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMud2l0bmVzc191cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRuZXNzX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IGludDY0IH0pO1xuXG52YXIgcHJvcG9zYWxfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMucHJvcG9zYWxfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwicHJvcG9zYWxfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgcHJvcG9zYWxfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMucHJvcG9zYWxfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwicHJvcG9zYWxfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgcHJvcG9zYWxfZGVsZXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMucHJvcG9zYWxfZGVsZXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwicHJvcG9zYWxfZGVsZXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy53aXRoZHJhd19wZXJtaXNzaW9uX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Blcm1pc3Npb25fY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy53aXRoZHJhd19wZXJtaXNzaW9uX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Blcm1pc3Npb25fdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fY2xhaW1fb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRoZHJhd19wZXJtaXNzaW9uX2NsYWltX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy53aXRoZHJhd19wZXJtaXNzaW9uX2RlbGV0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Blcm1pc3Npb25fZGVsZXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgY29tbWl0dGVlX21lbWJlcl9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1pdHRlZV9tZW1iZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgY29tbWl0dGVlX21lbWJlcl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX3VwZGF0ZV9nbG9iYWxfcGFyYW1ldGVyc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlX2dsb2JhbF9wYXJhbWV0ZXJzX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgdmVzdGluZ19iYWxhbmNlX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLnZlc3RpbmdfYmFsYW5jZV9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ2ZXN0aW5nX2JhbGFuY2VfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgdmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwidmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgd29ya2VyX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLndvcmtlcl9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ3b3JrZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgY3VzdG9tX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuY3VzdG9tX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0LFxuICAgIHByaWNlX3Blcl9rYnl0ZTogdWludDMyIH0pO1xuXG52YXIgYXNzZXJ0X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMuYXNzZXJ0X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXJ0X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgYmFsYW5jZV9jbGFpbV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmJhbGFuY2VfY2xhaW1fb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJiYWxhbmNlX2NsYWltX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiKTtcblxudmFyIG92ZXJyaWRlX3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMub3ZlcnJpZGVfdHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJvdmVycmlkZV90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCxcbiAgICBwcmljZV9wZXJfa2J5dGU6IHVpbnQzMiB9KTtcblxudmFyIHRyYW5zZmVyX3RvX2JsaW5kX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IGV4cG9ydHMudHJhbnNmZXJfdG9fYmxpbmRfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl90b19ibGluZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCxcbiAgICBwcmljZV9wZXJfb3V0cHV0OiB1aW50MzIgfSk7XG5cbnZhciBibGluZF90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmJsaW5kX3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYmxpbmRfdHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzXCIsIHsgZmVlOiB1aW50NjQsXG4gICAgcHJpY2VfcGVyX291dHB1dDogdWludDMyIH0pO1xuXG52YXIgdHJhbnNmZXJfZnJvbV9ibGluZF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLnRyYW5zZmVyX2Zyb21fYmxpbmRfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl9mcm9tX2JsaW5kX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiLCB7IGZlZTogdWludDY0IH0pO1xuXG52YXIgYXNzZXRfc2V0dGxlX2NhbmNlbF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMgPSBleHBvcnRzLmFzc2V0X3NldHRsZV9jYW5jZWxfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF9zZXR0bGVfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVyc1wiKTtcblxudmFyIGFzc2V0X2NsYWltX2ZlZXNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzID0gZXhwb3J0cy5hc3NldF9jbGFpbV9mZWVzX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfY2xhaW1fZmVlc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnNcIiwgeyBmZWU6IHVpbnQ2NCB9KTtcblxudmFyIGZlZV9wYXJhbWV0ZXJzID0gc3RhdGljX3ZhcmlhbnQoW3RyYW5zZmVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgbGltaXRfb3JkZXJfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgbGltaXRfb3JkZXJfY2FuY2VsX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgY2FsbF9vcmRlcl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBmaWxsX29yZGVyX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYWNjb3VudF9jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBhY2NvdW50X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFjY291bnRfd2hpdGVsaXN0X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYWNjb3VudF91cGdyYWRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYWNjb3VudF90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X3VwZGF0ZV9iaXRhc3NldF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2Vyc19vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X2lzc3VlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYXNzZXRfcmVzZXJ2ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X2Z1bmRfZmVlX3Bvb2xfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBhc3NldF9zZXR0bGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBhc3NldF9nbG9iYWxfc2V0dGxlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYXNzZXRfcHVibGlzaF9mZWVkX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgd2l0bmVzc19jcmVhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCB3aXRuZXNzX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIHByb3Bvc2FsX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIHByb3Bvc2FsX3VwZGF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIHByb3Bvc2FsX2RlbGV0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIHdpdGhkcmF3X3Blcm1pc3Npb25fY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgd2l0aGRyYXdfcGVybWlzc2lvbl91cGRhdGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCB3aXRoZHJhd19wZXJtaXNzaW9uX2NsYWltX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgd2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGVfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBjb21taXR0ZWVfbWVtYmVyX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCB2ZXN0aW5nX2JhbGFuY2VfY3JlYXRlX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgdmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3X29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgd29ya2VyX2NyZWF0ZV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGN1c3RvbV9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2VydF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGJhbGFuY2VfY2xhaW1fb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCBvdmVycmlkZV90cmFuc2Zlcl9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIHRyYW5zZmVyX3RvX2JsaW5kX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYmxpbmRfdHJhbnNmZXJfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzLCB0cmFuc2Zlcl9mcm9tX2JsaW5kX29wZXJhdGlvbl9mZWVfcGFyYW1ldGVycywgYXNzZXRfc2V0dGxlX2NhbmNlbF9vcGVyYXRpb25fZmVlX3BhcmFtZXRlcnMsIGFzc2V0X2NsYWltX2ZlZXNfb3BlcmF0aW9uX2ZlZV9wYXJhbWV0ZXJzXSk7XG5cbnZhciBmZWVfc2NoZWR1bGUgPSBleHBvcnRzLmZlZV9zY2hlZHVsZSA9IG5ldyBTZXJpYWxpemVyKFwiZmVlX3NjaGVkdWxlXCIsIHsgcGFyYW1ldGVyczogc2V0KGZlZV9wYXJhbWV0ZXJzKSxcbiAgICBzY2FsZTogdWludDMyIH0pO1xuXG52YXIgdm9pZF9yZXN1bHQgPSBleHBvcnRzLnZvaWRfcmVzdWx0ID0gbmV3IFNlcmlhbGl6ZXIoXCJ2b2lkX3Jlc3VsdFwiKTtcblxudmFyIGFzc2V0ID0gZXhwb3J0cy5hc3NldCA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRcIiwgeyBhbW91bnQ6IGludDY0LFxuICAgIGFzc2V0X2lkOiBwcm90b2NvbF9pZF90eXBlKFwiYXNzZXRcIikgfSk7XG5cbnZhciBvcGVyYXRpb25fcmVzdWx0ID0gc3RhdGljX3ZhcmlhbnQoW3ZvaWRfcmVzdWx0LCBvYmplY3RfaWRfdHlwZSwgYXNzZXRdKTtcblxudmFyIHByb2Nlc3NlZF90cmFuc2FjdGlvbiA9IGV4cG9ydHMucHJvY2Vzc2VkX3RyYW5zYWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJwcm9jZXNzZWRfdHJhbnNhY3Rpb25cIiwgeyByZWZfYmxvY2tfbnVtOiB1aW50MTYsXG4gICAgcmVmX2Jsb2NrX3ByZWZpeDogdWludDMyLFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjLFxuICAgIG9wZXJhdGlvbnM6IGFycmF5KG9wZXJhdGlvbiksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSxcbiAgICBzaWduYXR1cmVzOiBhcnJheShieXRlcyg2NSkpLFxuICAgIG9wZXJhdGlvbl9yZXN1bHRzOiBhcnJheShvcGVyYXRpb25fcmVzdWx0KSB9KTtcblxudmFyIHNpZ25lZF9ibG9jayA9IGV4cG9ydHMuc2lnbmVkX2Jsb2NrID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfYmxvY2tcIiwgeyBwcmV2aW91czogYnl0ZXMoMjApLFxuICAgIHRpbWVzdGFtcDogdGltZV9wb2ludF9zZWMsXG4gICAgd2l0bmVzczogcHJvdG9jb2xfaWRfdHlwZShcIndpdG5lc3NcIiksXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpLFxuICAgIHdpdG5lc3Nfc2lnbmF0dXJlOiBieXRlcyg2NSksXG4gICAgdHJhbnNhY3Rpb25zOiBhcnJheShwcm9jZXNzZWRfdHJhbnNhY3Rpb24pIH0pO1xuXG52YXIgYmxvY2tfaGVhZGVyID0gZXhwb3J0cy5ibG9ja19oZWFkZXIgPSBuZXcgU2VyaWFsaXplcihcImJsb2NrX2hlYWRlclwiLCB7IHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBwcm90b2NvbF9pZF90eXBlKFwid2l0bmVzc1wiKSxcbiAgICB0cmFuc2FjdGlvbl9tZXJrbGVfcm9vdDogYnl0ZXMoMjApLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBzaWduZWRfYmxvY2tfaGVhZGVyID0gZXhwb3J0cy5zaWduZWRfYmxvY2tfaGVhZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfYmxvY2tfaGVhZGVyXCIsIHsgcHJldmlvdXM6IGJ5dGVzKDIwKSxcbiAgICB0aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHdpdG5lc3M6IHByb3RvY29sX2lkX3R5cGUoXCJ3aXRuZXNzXCIpLFxuICAgIHRyYW5zYWN0aW9uX21lcmtsZV9yb290OiBieXRlcygyMCksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSxcbiAgICB3aXRuZXNzX3NpZ25hdHVyZTogYnl0ZXMoNjUpIH0pO1xuXG52YXIgbWVtb19kYXRhID0gZXhwb3J0cy5tZW1vX2RhdGEgPSBuZXcgU2VyaWFsaXplcihcIm1lbW9fZGF0YVwiLCB7IGZyb206IHB1YmxpY19rZXksXG4gICAgdG86IHB1YmxpY19rZXksXG4gICAgbm9uY2U6IHVpbnQ2NCxcbiAgICBtZXNzYWdlOiBieXRlcygpIH0pO1xuXG52YXIgdHJhbnNmZXIgPSBleHBvcnRzLnRyYW5zZmVyID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2ZlclwiLCB7IGZlZTogYXNzZXQsXG4gICAgZnJvbTogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgdG86IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgbWVtbzogb3B0aW9uYWwobWVtb19kYXRhKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgbGltaXRfb3JkZXJfY3JlYXRlID0gZXhwb3J0cy5saW1pdF9vcmRlcl9jcmVhdGUgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NyZWF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgc2VsbGVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhbW91bnRfdG9fc2VsbDogYXNzZXQsXG4gICAgbWluX3RvX3JlY2VpdmU6IGFzc2V0LFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjLFxuICAgIGZpbGxfb3Jfa2lsbDogYm9vbCxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgbGltaXRfb3JkZXJfY2FuY2VsID0gZXhwb3J0cy5saW1pdF9vcmRlcl9jYW5jZWwgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NhbmNlbFwiLCB7IGZlZTogYXNzZXQsXG4gICAgZmVlX3BheWluZ19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBvcmRlcjogcHJvdG9jb2xfaWRfdHlwZShcImxpbWl0X29yZGVyXCIpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBjYWxsX29yZGVyX3VwZGF0ZSA9IGV4cG9ydHMuY2FsbF9vcmRlcl91cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcImNhbGxfb3JkZXJfdXBkYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICBmdW5kaW5nX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGRlbHRhX2NvbGxhdGVyYWw6IGFzc2V0LFxuICAgIGRlbHRhX2RlYnQ6IGFzc2V0LFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBmaWxsX29yZGVyID0gZXhwb3J0cy5maWxsX29yZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJmaWxsX29yZGVyXCIsIHsgZmVlOiBhc3NldCxcbiAgICBvcmRlcl9pZDogb2JqZWN0X2lkX3R5cGUsXG4gICAgYWNjb3VudF9pZDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgcGF5czogYXNzZXQsXG4gICAgcmVjZWl2ZXM6IGFzc2V0IH0pO1xuXG52YXIgYXV0aG9yaXR5ID0gZXhwb3J0cy5hdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcImF1dGhvcml0eVwiLCB7IHdlaWdodF90aHJlc2hvbGQ6IHVpbnQzMixcbiAgICBhY2NvdW50X2F1dGhzOiBtYXAocHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksIHVpbnQxNiksXG4gICAga2V5X2F1dGhzOiBtYXAocHVibGljX2tleSwgdWludDE2KSxcbiAgICBhZGRyZXNzX2F1dGhzOiBtYXAoYWRkcmVzcywgdWludDE2KSB9KTtcblxudmFyIGFjY291bnRfb3B0aW9ucyA9IGV4cG9ydHMuYWNjb3VudF9vcHRpb25zID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X29wdGlvbnNcIiwgeyBtZW1vX2tleTogcHVibGljX2tleSxcbiAgICB2b3RpbmdfYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgbnVtX3dpdG5lc3M6IHVpbnQxNixcbiAgICBudW1fY29tbWl0dGVlOiB1aW50MTYsXG4gICAgdm90ZXM6IHNldCh2b3RlX2lkKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYWNjb3VudF9jcmVhdGUgPSBleHBvcnRzLmFjY291bnRfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X2NyZWF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgcmVnaXN0cmFyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICByZWZlcnJlcjogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgcmVmZXJyZXJfcGVyY2VudDogdWludDE2LFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBvd25lcjogYXV0aG9yaXR5LFxuICAgIGFjdGl2ZTogYXV0aG9yaXR5LFxuICAgIG9wdGlvbnM6IGFjY291bnRfb3B0aW9ucyxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYWNjb3VudF91cGRhdGUgPSBleHBvcnRzLmFjY291bnRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3VwZGF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgb3duZXI6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgYWN0aXZlOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICAgIG5ld19vcHRpb25zOiBvcHRpb25hbChhY2NvdW50X29wdGlvbnMpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBhY2NvdW50X3doaXRlbGlzdCA9IGV4cG9ydHMuYWNjb3VudF93aGl0ZWxpc3QgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfd2hpdGVsaXN0XCIsIHsgZmVlOiBhc3NldCxcbiAgICBhdXRob3JpemluZ19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhY2NvdW50X3RvX2xpc3Q6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIG5ld19saXN0aW5nOiB1aW50OCxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYWNjb3VudF91cGdyYWRlID0gZXhwb3J0cy5hY2NvdW50X3VwZ3JhZGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfdXBncmFkZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgYWNjb3VudF90b191cGdyYWRlOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICB1cGdyYWRlX3RvX2xpZmV0aW1lX21lbWJlcjogYm9vbCxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYWNjb3VudF90cmFuc2ZlciA9IGV4cG9ydHMuYWNjb3VudF90cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF90cmFuc2ZlclwiLCB7IGZlZTogYXNzZXQsXG4gICAgYWNjb3VudF9pZDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgbmV3X293bmVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgcHJpY2UgPSBleHBvcnRzLnByaWNlID0gbmV3IFNlcmlhbGl6ZXIoXCJwcmljZVwiLCB7IGJhc2U6IGFzc2V0LFxuICAgIHF1b3RlOiBhc3NldCB9KTtcblxudmFyIGFzc2V0X29wdGlvbnMgPSBleHBvcnRzLmFzc2V0X29wdGlvbnMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X29wdGlvbnNcIiwgeyBtYXhfc3VwcGx5OiBpbnQ2NCxcbiAgICBtYXJrZXRfZmVlX3BlcmNlbnQ6IHVpbnQxNixcbiAgICBtYXhfbWFya2V0X2ZlZTogaW50NjQsXG4gICAgaXNzdWVyX3Blcm1pc3Npb25zOiB1aW50MTYsXG4gICAgZmxhZ3M6IHVpbnQxNixcbiAgICBjb3JlX2V4Y2hhbmdlX3JhdGU6IHByaWNlLFxuICAgIHdoaXRlbGlzdF9hdXRob3JpdGllczogc2V0KHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpKSxcbiAgICBibGFja2xpc3RfYXV0aG9yaXRpZXM6IHNldChwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSksXG4gICAgd2hpdGVsaXN0X21hcmtldHM6IHNldChwcm90b2NvbF9pZF90eXBlKFwiYXNzZXRcIikpLFxuICAgIGJsYWNrbGlzdF9tYXJrZXRzOiBzZXQocHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpKSxcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBiaXRhc3NldF9vcHRpb25zID0gZXhwb3J0cy5iaXRhc3NldF9vcHRpb25zID0gbmV3IFNlcmlhbGl6ZXIoXCJiaXRhc3NldF9vcHRpb25zXCIsIHsgZmVlZF9saWZldGltZV9zZWM6IHVpbnQzMixcbiAgICBtaW5pbXVtX2ZlZWRzOiB1aW50OCxcbiAgICBmb3JjZV9zZXR0bGVtZW50X2RlbGF5X3NlYzogdWludDMyLFxuICAgIGZvcmNlX3NldHRsZW1lbnRfb2Zmc2V0X3BlcmNlbnQ6IHVpbnQxNixcbiAgICBtYXhpbXVtX2ZvcmNlX3NldHRsZW1lbnRfdm9sdW1lOiB1aW50MTYsXG4gICAgc2hvcnRfYmFja2luZ19hc3NldDogcHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBhc3NldF9jcmVhdGUgPSBleHBvcnRzLmFzc2V0X2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfY3JlYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICBpc3N1ZXI6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIHN5bWJvbDogc3RyaW5nLFxuICAgIHByZWNpc2lvbjogdWludDgsXG4gICAgY29tbW9uX29wdGlvbnM6IGFzc2V0X29wdGlvbnMsXG4gICAgYml0YXNzZXRfb3B0czogb3B0aW9uYWwoYml0YXNzZXRfb3B0aW9ucyksXG4gICAgaXNfcHJlZGljdGlvbl9tYXJrZXQ6IGJvb2wsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSB9KTtcblxudmFyIGFzc2V0X3VwZGF0ZSA9IGV4cG9ydHMuYXNzZXRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF91cGRhdGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGlzc3VlcjogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYXNzZXRfdG9fdXBkYXRlOiBwcm90b2NvbF9pZF90eXBlKFwiYXNzZXRcIiksXG4gICAgbmV3X2lzc3Vlcjogb3B0aW9uYWwocHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIikpLFxuICAgIG5ld19vcHRpb25zOiBhc3NldF9vcHRpb25zLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBhc3NldF91cGRhdGVfYml0YXNzZXQgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9iaXRhc3NldCA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfdXBkYXRlX2JpdGFzc2V0XCIsIHsgZmVlOiBhc3NldCxcbiAgICBpc3N1ZXI6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFzc2V0X3RvX3VwZGF0ZTogcHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpLFxuICAgIG5ld19vcHRpb25zOiBiaXRhc3NldF9vcHRpb25zLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBhc3NldF91cGRhdGVfZmVlZF9wcm9kdWNlcnMgPSBleHBvcnRzLmFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2VycyA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfdXBkYXRlX2ZlZWRfcHJvZHVjZXJzXCIsIHsgZmVlOiBhc3NldCxcbiAgICBpc3N1ZXI6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFzc2V0X3RvX3VwZGF0ZTogcHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpLFxuICAgIG5ld19mZWVkX3Byb2R1Y2Vyczogc2V0KHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYXNzZXRfaXNzdWUgPSBleHBvcnRzLmFzc2V0X2lzc3VlID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF9pc3N1ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgaXNzdWVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhc3NldF90b19pc3N1ZTogYXNzZXQsXG4gICAgaXNzdWVfdG9fYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgbWVtbzogb3B0aW9uYWwobWVtb19kYXRhKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYXNzZXRfcmVzZXJ2ZSA9IGV4cG9ydHMuYXNzZXRfcmVzZXJ2ZSA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfcmVzZXJ2ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgcGF5ZXI6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFtb3VudF90b19yZXNlcnZlOiBhc3NldCxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgYXNzZXRfZnVuZF9mZWVfcG9vbCA9IGV4cG9ydHMuYXNzZXRfZnVuZF9mZWVfcG9vbCA9IG5ldyBTZXJpYWxpemVyKFwiYXNzZXRfZnVuZF9mZWVfcG9vbFwiLCB7IGZlZTogYXNzZXQsXG4gICAgZnJvbV9hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhc3NldF9pZDogcHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpLFxuICAgIGFtb3VudDogaW50NjQsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSB9KTtcblxudmFyIGFzc2V0X3NldHRsZSA9IGV4cG9ydHMuYXNzZXRfc2V0dGxlID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF9zZXR0bGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGFjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSB9KTtcblxudmFyIGFzc2V0X2dsb2JhbF9zZXR0bGUgPSBleHBvcnRzLmFzc2V0X2dsb2JhbF9zZXR0bGUgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X2dsb2JhbF9zZXR0bGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGlzc3VlcjogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYXNzZXRfdG9fc2V0dGxlOiBwcm90b2NvbF9pZF90eXBlKFwiYXNzZXRcIiksXG4gICAgc2V0dGxlX3ByaWNlOiBwcmljZSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgcHJpY2VfZmVlZCA9IGV4cG9ydHMucHJpY2VfZmVlZCA9IG5ldyBTZXJpYWxpemVyKFwicHJpY2VfZmVlZFwiLCB7IHNldHRsZW1lbnRfcHJpY2U6IHByaWNlLFxuICAgIG1haW50ZW5hbmNlX2NvbGxhdGVyYWxfcmF0aW86IHVpbnQxNixcbiAgICBtYXhpbXVtX3Nob3J0X3NxdWVlemVfcmF0aW86IHVpbnQxNixcbiAgICBjb3JlX2V4Y2hhbmdlX3JhdGU6IHByaWNlIH0pO1xuXG52YXIgYXNzZXRfcHVibGlzaF9mZWVkID0gZXhwb3J0cy5hc3NldF9wdWJsaXNoX2ZlZWQgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3B1Ymxpc2hfZmVlZFwiLCB7IGZlZTogYXNzZXQsXG4gICAgcHVibGlzaGVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhc3NldF9pZDogcHJvdG9jb2xfaWRfdHlwZShcImFzc2V0XCIpLFxuICAgIGZlZWQ6IHByaWNlX2ZlZWQsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSB9KTtcblxudmFyIHdpdG5lc3NfY3JlYXRlID0gZXhwb3J0cy53aXRuZXNzX2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwid2l0bmVzc19jcmVhdGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIHdpdG5lc3NfYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYmxvY2tfc2lnbmluZ19rZXk6IHB1YmxpY19rZXkgfSk7XG5cbnZhciB3aXRuZXNzX3VwZGF0ZSA9IGV4cG9ydHMud2l0bmVzc191cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcIndpdG5lc3NfdXBkYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICB3aXRuZXNzOiBwcm90b2NvbF9pZF90eXBlKFwid2l0bmVzc1wiKSxcbiAgICB3aXRuZXNzX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIG5ld191cmw6IG9wdGlvbmFsKHN0cmluZyksXG4gICAgbmV3X3NpZ25pbmdfa2V5OiBvcHRpb25hbChwdWJsaWNfa2V5KSB9KTtcblxudmFyIG9wX3dyYXBwZXIgPSBleHBvcnRzLm9wX3dyYXBwZXIgPSBuZXcgU2VyaWFsaXplcihcIm9wX3dyYXBwZXJcIiwgeyBvcDogb3BlcmF0aW9uIH0pO1xuXG52YXIgcHJvcG9zYWxfY3JlYXRlID0gZXhwb3J0cy5wcm9wb3NhbF9jcmVhdGUgPSBuZXcgU2VyaWFsaXplcihcInByb3Bvc2FsX2NyZWF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgZmVlX3BheWluZ19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBleHBpcmF0aW9uX3RpbWU6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHByb3Bvc2VkX29wczogYXJyYXkob3Bfd3JhcHBlciksXG4gICAgcmV2aWV3X3BlcmlvZF9zZWNvbmRzOiBvcHRpb25hbCh1aW50MzIpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBwcm9wb3NhbF91cGRhdGUgPSBleHBvcnRzLnByb3Bvc2FsX3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwicHJvcG9zYWxfdXBkYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICBmZWVfcGF5aW5nX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIHByb3Bvc2FsOiBwcm90b2NvbF9pZF90eXBlKFwicHJvcG9zYWxcIiksXG4gICAgYWN0aXZlX2FwcHJvdmFsc190b19hZGQ6IHNldChwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSksXG4gICAgYWN0aXZlX2FwcHJvdmFsc190b19yZW1vdmU6IHNldChwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSksXG4gICAgb3duZXJfYXBwcm92YWxzX3RvX2FkZDogc2V0KHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpKSxcbiAgICBvd25lcl9hcHByb3ZhbHNfdG9fcmVtb3ZlOiBzZXQocHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIikpLFxuICAgIGtleV9hcHByb3ZhbHNfdG9fYWRkOiBzZXQocHVibGljX2tleSksXG4gICAga2V5X2FwcHJvdmFsc190b19yZW1vdmU6IHNldChwdWJsaWNfa2V5KSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgcHJvcG9zYWxfZGVsZXRlID0gZXhwb3J0cy5wcm9wb3NhbF9kZWxldGUgPSBuZXcgU2VyaWFsaXplcihcInByb3Bvc2FsX2RlbGV0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgZmVlX3BheWluZ19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICB1c2luZ19vd25lcl9hdXRob3JpdHk6IGJvb2wsXG4gICAgcHJvcG9zYWw6IHByb3RvY29sX2lkX3R5cGUoXCJwcm9wb3NhbFwiKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl9jcmVhdGUgPSBleHBvcnRzLndpdGhkcmF3X3Blcm1pc3Npb25fY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRoZHJhd19wZXJtaXNzaW9uX2NyZWF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgd2l0aGRyYXdfZnJvbV9hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhdXRob3JpemVkX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIHdpdGhkcmF3YWxfbGltaXQ6IGFzc2V0LFxuICAgIHdpdGhkcmF3YWxfcGVyaW9kX3NlYzogdWludDMyLFxuICAgIHBlcmlvZHNfdW50aWxfZXhwaXJhdGlvbjogdWludDMyLFxuICAgIHBlcmlvZF9zdGFydF90aW1lOiB0aW1lX3BvaW50X3NlYyB9KTtcblxudmFyIHdpdGhkcmF3X3Blcm1pc3Npb25fdXBkYXRlID0gZXhwb3J0cy53aXRoZHJhd19wZXJtaXNzaW9uX3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwid2l0aGRyYXdfcGVybWlzc2lvbl91cGRhdGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIHdpdGhkcmF3X2Zyb21fYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYXV0aG9yaXplZF9hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBwZXJtaXNzaW9uX3RvX3VwZGF0ZTogcHJvdG9jb2xfaWRfdHlwZShcIndpdGhkcmF3X3Blcm1pc3Npb25cIiksXG4gICAgd2l0aGRyYXdhbF9saW1pdDogYXNzZXQsXG4gICAgd2l0aGRyYXdhbF9wZXJpb2Rfc2VjOiB1aW50MzIsXG4gICAgcGVyaW9kX3N0YXJ0X3RpbWU6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHBlcmlvZHNfdW50aWxfZXhwaXJhdGlvbjogdWludDMyIH0pO1xuXG52YXIgd2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbSA9IGV4cG9ydHMud2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbSA9IG5ldyBTZXJpYWxpemVyKFwid2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbVwiLCB7IGZlZTogYXNzZXQsXG4gICAgd2l0aGRyYXdfcGVybWlzc2lvbjogcHJvdG9jb2xfaWRfdHlwZShcIndpdGhkcmF3X3Blcm1pc3Npb25cIiksXG4gICAgd2l0aGRyYXdfZnJvbV9hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICB3aXRoZHJhd190b19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhbW91bnRfdG9fd2l0aGRyYXc6IGFzc2V0LFxuICAgIG1lbW86IG9wdGlvbmFsKG1lbW9fZGF0YSkgfSk7XG5cbnZhciB3aXRoZHJhd19wZXJtaXNzaW9uX2RlbGV0ZSA9IGV4cG9ydHMud2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGUgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Blcm1pc3Npb25fZGVsZXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICB3aXRoZHJhd19mcm9tX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGF1dGhvcml6ZWRfYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgd2l0aGRyYXdhbF9wZXJtaXNzaW9uOiBwcm90b2NvbF9pZF90eXBlKFwid2l0aGRyYXdfcGVybWlzc2lvblwiKSB9KTtcblxudmFyIGNvbW1pdHRlZV9tZW1iZXJfY3JlYXRlID0gZXhwb3J0cy5jb21taXR0ZWVfbWVtYmVyX2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWl0dGVlX21lbWJlcl9jcmVhdGVcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGNvbW1pdHRlZV9tZW1iZXJfYWNjb3VudDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgdXJsOiBzdHJpbmcgfSk7XG5cbnZhciBjb21taXR0ZWVfbWVtYmVyX3VwZGF0ZSA9IGV4cG9ydHMuY29tbWl0dGVlX21lbWJlcl91cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcImNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICBjb21taXR0ZWVfbWVtYmVyOiBwcm90b2NvbF9pZF90eXBlKFwiY29tbWl0dGVlX21lbWJlclwiKSxcbiAgICBjb21taXR0ZWVfbWVtYmVyX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIG5ld191cmw6IG9wdGlvbmFsKHN0cmluZykgfSk7XG5cbnZhciBjaGFpbl9wYXJhbWV0ZXJzID0gZXhwb3J0cy5jaGFpbl9wYXJhbWV0ZXJzID0gbmV3IFNlcmlhbGl6ZXIoXCJjaGFpbl9wYXJhbWV0ZXJzXCIsIHsgY3VycmVudF9mZWVzOiBmZWVfc2NoZWR1bGUsXG4gICAgYmxvY2tfaW50ZXJ2YWw6IHVpbnQ4LFxuICAgIG1haW50ZW5hbmNlX2ludGVydmFsOiB1aW50MzIsXG4gICAgbWFpbnRlbmFuY2Vfc2tpcF9zbG90czogdWludDgsXG4gICAgY29tbWl0dGVlX3Byb3Bvc2FsX3Jldmlld19wZXJpb2Q6IHVpbnQzMixcbiAgICBtYXhpbXVtX3RyYW5zYWN0aW9uX3NpemU6IHVpbnQzMixcbiAgICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgICBtYXhpbXVtX3RpbWVfdW50aWxfZXhwaXJhdGlvbjogdWludDMyLFxuICAgIG1heGltdW1fcHJvcG9zYWxfbGlmZXRpbWU6IHVpbnQzMixcbiAgICBtYXhpbXVtX2Fzc2V0X3doaXRlbGlzdF9hdXRob3JpdGllczogdWludDgsXG4gICAgbWF4aW11bV9hc3NldF9mZWVkX3B1Ymxpc2hlcnM6IHVpbnQ4LFxuICAgIG1heGltdW1fd2l0bmVzc19jb3VudDogdWludDE2LFxuICAgIG1heGltdW1fY29tbWl0dGVlX2NvdW50OiB1aW50MTYsXG4gICAgbWF4aW11bV9hdXRob3JpdHlfbWVtYmVyc2hpcDogdWludDE2LFxuICAgIHJlc2VydmVfcGVyY2VudF9vZl9mZWU6IHVpbnQxNixcbiAgICBuZXR3b3JrX3BlcmNlbnRfb2ZfZmVlOiB1aW50MTYsXG4gICAgbGlmZXRpbWVfcmVmZXJyZXJfcGVyY2VudF9vZl9mZWU6IHVpbnQxNixcbiAgICBjYXNoYmFja192ZXN0aW5nX3BlcmlvZF9zZWNvbmRzOiB1aW50MzIsXG4gICAgY2FzaGJhY2tfdmVzdGluZ190aHJlc2hvbGQ6IGludDY0LFxuICAgIGNvdW50X25vbl9tZW1iZXJfdm90ZXM6IGJvb2wsXG4gICAgYWxsb3dfbm9uX21lbWJlcl93aGl0ZWxpc3RzOiBib29sLFxuICAgIHdpdG5lc3NfcGF5X3Blcl9ibG9jazogaW50NjQsXG4gICAgd29ya2VyX2J1ZGdldF9wZXJfZGF5OiBpbnQ2NCxcbiAgICBtYXhfcHJlZGljYXRlX29wY29kZTogdWludDE2LFxuICAgIGZlZV9saXF1aWRhdGlvbl90aHJlc2hvbGQ6IGludDY0LFxuICAgIGFjY291bnRzX3Blcl9mZWVfc2NhbGU6IHVpbnQxNixcbiAgICBhY2NvdW50X2ZlZV9zY2FsZV9iaXRzaGlmdHM6IHVpbnQ4LFxuICAgIG1heF9hdXRob3JpdHlfZGVwdGg6IHVpbnQ4LFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBjb21taXR0ZWVfbWVtYmVyX3VwZGF0ZV9nbG9iYWxfcGFyYW1ldGVycyA9IGV4cG9ydHMuY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1pdHRlZV9tZW1iZXJfdXBkYXRlX2dsb2JhbF9wYXJhbWV0ZXJzXCIsIHsgZmVlOiBhc3NldCxcbiAgICBuZXdfcGFyYW1ldGVyczogY2hhaW5fcGFyYW1ldGVycyB9KTtcblxudmFyIGxpbmVhcl92ZXN0aW5nX3BvbGljeV9pbml0aWFsaXplciA9IGV4cG9ydHMubGluZWFyX3Zlc3RpbmdfcG9saWN5X2luaXRpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoXCJsaW5lYXJfdmVzdGluZ19wb2xpY3lfaW5pdGlhbGl6ZXJcIiwgeyBiZWdpbl90aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHZlc3RpbmdfY2xpZmZfc2Vjb25kczogdWludDMyLFxuICAgIHZlc3RpbmdfZHVyYXRpb25fc2Vjb25kczogdWludDMyIH0pO1xuXG52YXIgY2RkX3Zlc3RpbmdfcG9saWN5X2luaXRpYWxpemVyID0gZXhwb3J0cy5jZGRfdmVzdGluZ19wb2xpY3lfaW5pdGlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcihcImNkZF92ZXN0aW5nX3BvbGljeV9pbml0aWFsaXplclwiLCB7IHN0YXJ0X2NsYWltOiB0aW1lX3BvaW50X3NlYyxcbiAgICB2ZXN0aW5nX3NlY29uZHM6IHVpbnQzMiB9KTtcblxudmFyIHZlc3RpbmdfcG9saWN5X2luaXRpYWxpemVyID0gc3RhdGljX3ZhcmlhbnQoW2xpbmVhcl92ZXN0aW5nX3BvbGljeV9pbml0aWFsaXplciwgY2RkX3Zlc3RpbmdfcG9saWN5X2luaXRpYWxpemVyXSk7XG5cbnZhciB2ZXN0aW5nX2JhbGFuY2VfY3JlYXRlID0gZXhwb3J0cy52ZXN0aW5nX2JhbGFuY2VfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJ2ZXN0aW5nX2JhbGFuY2VfY3JlYXRlXCIsIHsgZmVlOiBhc3NldCxcbiAgICBjcmVhdG9yOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBvd25lcjogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBwb2xpY3k6IHZlc3RpbmdfcG9saWN5X2luaXRpYWxpemVyIH0pO1xuXG52YXIgdmVzdGluZ19iYWxhbmNlX3dpdGhkcmF3ID0gZXhwb3J0cy52ZXN0aW5nX2JhbGFuY2Vfd2l0aGRyYXcgPSBuZXcgU2VyaWFsaXplcihcInZlc3RpbmdfYmFsYW5jZV93aXRoZHJhd1wiLCB7IGZlZTogYXNzZXQsXG4gICAgdmVzdGluZ19iYWxhbmNlOiBwcm90b2NvbF9pZF90eXBlKFwidmVzdGluZ19iYWxhbmNlXCIpLFxuICAgIG93bmVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBhbW91bnQ6IGFzc2V0IH0pO1xuXG52YXIgcmVmdW5kX3dvcmtlcl9pbml0aWFsaXplciA9IGV4cG9ydHMucmVmdW5kX3dvcmtlcl9pbml0aWFsaXplciA9IG5ldyBTZXJpYWxpemVyKFwicmVmdW5kX3dvcmtlcl9pbml0aWFsaXplclwiKTtcblxudmFyIHZlc3RpbmdfYmFsYW5jZV93b3JrZXJfaW5pdGlhbGl6ZXIgPSBleHBvcnRzLnZlc3RpbmdfYmFsYW5jZV93b3JrZXJfaW5pdGlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcihcInZlc3RpbmdfYmFsYW5jZV93b3JrZXJfaW5pdGlhbGl6ZXJcIiwgeyBwYXlfdmVzdGluZ19wZXJpb2RfZGF5czogdWludDE2IH0pO1xuXG52YXIgYnVybl93b3JrZXJfaW5pdGlhbGl6ZXIgPSBleHBvcnRzLmJ1cm5fd29ya2VyX2luaXRpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoXCJidXJuX3dvcmtlcl9pbml0aWFsaXplclwiKTtcblxudmFyIHdvcmtlcl9pbml0aWFsaXplciA9IHN0YXRpY192YXJpYW50KFtyZWZ1bmRfd29ya2VyX2luaXRpYWxpemVyLCB2ZXN0aW5nX2JhbGFuY2Vfd29ya2VyX2luaXRpYWxpemVyLCBidXJuX3dvcmtlcl9pbml0aWFsaXplcl0pO1xuXG52YXIgd29ya2VyX2NyZWF0ZSA9IGV4cG9ydHMud29ya2VyX2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwid29ya2VyX2NyZWF0ZVwiLCB7IGZlZTogYXNzZXQsXG4gICAgb3duZXI6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIHdvcmtfYmVnaW5fZGF0ZTogdGltZV9wb2ludF9zZWMsXG4gICAgd29ya19lbmRfZGF0ZTogdGltZV9wb2ludF9zZWMsXG4gICAgZGFpbHlfcGF5OiBpbnQ2NCxcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgaW5pdGlhbGl6ZXI6IHdvcmtlcl9pbml0aWFsaXplciB9KTtcblxudmFyIGN1c3RvbSA9IGV4cG9ydHMuY3VzdG9tID0gbmV3IFNlcmlhbGl6ZXIoXCJjdXN0b21cIiwgeyBmZWU6IGFzc2V0LFxuICAgIHBheWVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICByZXF1aXJlZF9hdXRoczogc2V0KHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpKSxcbiAgICBpZDogdWludDE2LFxuICAgIGRhdGE6IGJ5dGVzKCkgfSk7XG5cbnZhciBhY2NvdW50X25hbWVfZXFfbGl0X3ByZWRpY2F0ZSA9IGV4cG9ydHMuYWNjb3VudF9uYW1lX2VxX2xpdF9wcmVkaWNhdGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfbmFtZV9lcV9saXRfcHJlZGljYXRlXCIsIHsgYWNjb3VudF9pZDogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgbmFtZTogc3RyaW5nIH0pO1xuXG52YXIgYXNzZXRfc3ltYm9sX2VxX2xpdF9wcmVkaWNhdGUgPSBleHBvcnRzLmFzc2V0X3N5bWJvbF9lcV9saXRfcHJlZGljYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhc3NldF9zeW1ib2xfZXFfbGl0X3ByZWRpY2F0ZVwiLCB7IGFzc2V0X2lkOiBwcm90b2NvbF9pZF90eXBlKFwiYXNzZXRcIiksXG4gICAgc3ltYm9sOiBzdHJpbmcgfSk7XG5cbnZhciBibG9ja19pZF9wcmVkaWNhdGUgPSBleHBvcnRzLmJsb2NrX2lkX3ByZWRpY2F0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYmxvY2tfaWRfcHJlZGljYXRlXCIsIHsgaWQ6IGJ5dGVzKDIwKSB9KTtcblxudmFyIHByZWRpY2F0ZSA9IHN0YXRpY192YXJpYW50KFthY2NvdW50X25hbWVfZXFfbGl0X3ByZWRpY2F0ZSwgYXNzZXRfc3ltYm9sX2VxX2xpdF9wcmVkaWNhdGUsIGJsb2NrX2lkX3ByZWRpY2F0ZV0pO1xuXG52YXIgYXNzZXJ0ID0gZXhwb3J0cy5hc3NlcnQgPSBuZXcgU2VyaWFsaXplcihcImFzc2VydFwiLCB7IGZlZTogYXNzZXQsXG4gICAgZmVlX3BheWluZ19hY2NvdW50OiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBwcmVkaWNhdGVzOiBhcnJheShwcmVkaWNhdGUpLFxuICAgIHJlcXVpcmVkX2F1dGhzOiBzZXQocHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIikpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBiYWxhbmNlX2NsYWltID0gZXhwb3J0cy5iYWxhbmNlX2NsYWltID0gbmV3IFNlcmlhbGl6ZXIoXCJiYWxhbmNlX2NsYWltXCIsIHsgZmVlOiBhc3NldCxcbiAgICBkZXBvc2l0X3RvX2FjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGJhbGFuY2VfdG9fY2xhaW06IHByb3RvY29sX2lkX3R5cGUoXCJiYWxhbmNlXCIpLFxuICAgIGJhbGFuY2Vfb3duZXJfa2V5OiBwdWJsaWNfa2V5LFxuICAgIHRvdGFsX2NsYWltZWQ6IGFzc2V0IH0pO1xuXG52YXIgb3ZlcnJpZGVfdHJhbnNmZXIgPSBleHBvcnRzLm92ZXJyaWRlX3RyYW5zZmVyID0gbmV3IFNlcmlhbGl6ZXIoXCJvdmVycmlkZV90cmFuc2ZlclwiLCB7IGZlZTogYXNzZXQsXG4gICAgaXNzdWVyOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBmcm9tOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICB0bzogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBtZW1vOiBvcHRpb25hbChtZW1vX2RhdGEpLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucykgfSk7XG5cbnZhciBzdGVhbHRoX2NvbmZpcm1hdGlvbiA9IGV4cG9ydHMuc3RlYWx0aF9jb25maXJtYXRpb24gPSBuZXcgU2VyaWFsaXplcihcInN0ZWFsdGhfY29uZmlybWF0aW9uXCIsIHsgb25lX3RpbWVfa2V5OiBwdWJsaWNfa2V5LFxuICAgIHRvOiBvcHRpb25hbChwdWJsaWNfa2V5KSxcbiAgICBlbmNyeXB0ZWRfbWVtbzogYnl0ZXMoKSB9KTtcblxudmFyIGJsaW5kX291dHB1dCA9IGV4cG9ydHMuYmxpbmRfb3V0cHV0ID0gbmV3IFNlcmlhbGl6ZXIoXCJibGluZF9vdXRwdXRcIiwgeyBjb21taXRtZW50OiBieXRlcygzMyksXG4gICAgcmFuZ2VfcHJvb2Y6IGJ5dGVzKCksXG4gICAgb3duZXI6IGF1dGhvcml0eSxcbiAgICBzdGVhbHRoX21lbW86IG9wdGlvbmFsKHN0ZWFsdGhfY29uZmlybWF0aW9uKSB9KTtcblxudmFyIHRyYW5zZmVyX3RvX2JsaW5kID0gZXhwb3J0cy50cmFuc2Zlcl90b19ibGluZCA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfdG9fYmxpbmRcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgZnJvbTogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYmxpbmRpbmdfZmFjdG9yOiBieXRlcygzMiksXG4gICAgb3V0cHV0czogYXJyYXkoYmxpbmRfb3V0cHV0KSB9KTtcblxudmFyIGJsaW5kX2lucHV0ID0gZXhwb3J0cy5ibGluZF9pbnB1dCA9IG5ldyBTZXJpYWxpemVyKFwiYmxpbmRfaW5wdXRcIiwgeyBjb21taXRtZW50OiBieXRlcygzMyksXG4gICAgb3duZXI6IGF1dGhvcml0eSB9KTtcblxudmFyIGJsaW5kX3RyYW5zZmVyID0gZXhwb3J0cy5ibGluZF90cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiYmxpbmRfdHJhbnNmZXJcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGlucHV0czogYXJyYXkoYmxpbmRfaW5wdXQpLFxuICAgIG91dHB1dHM6IGFycmF5KGJsaW5kX291dHB1dCkgfSk7XG5cbnZhciB0cmFuc2Zlcl9mcm9tX2JsaW5kID0gZXhwb3J0cy50cmFuc2Zlcl9mcm9tX2JsaW5kID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl9mcm9tX2JsaW5kXCIsIHsgZmVlOiBhc3NldCxcbiAgICBhbW91bnQ6IGFzc2V0LFxuICAgIHRvOiBwcm90b2NvbF9pZF90eXBlKFwiYWNjb3VudFwiKSxcbiAgICBibGluZGluZ19mYWN0b3I6IGJ5dGVzKDMyKSxcbiAgICBpbnB1dHM6IGFycmF5KGJsaW5kX2lucHV0KSB9KTtcblxudmFyIGFzc2V0X3NldHRsZV9jYW5jZWwgPSBleHBvcnRzLmFzc2V0X3NldHRsZV9jYW5jZWwgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X3NldHRsZV9jYW5jZWxcIiwgeyBmZWU6IGFzc2V0LFxuICAgIHNldHRsZW1lbnQ6IHByb3RvY29sX2lkX3R5cGUoXCJmb3JjZV9zZXR0bGVtZW50XCIpLFxuICAgIGFjY291bnQ6IHByb3RvY29sX2lkX3R5cGUoXCJhY2NvdW50XCIpLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSB9KTtcblxudmFyIGFzc2V0X2NsYWltX2ZlZXMgPSBleHBvcnRzLmFzc2V0X2NsYWltX2ZlZXMgPSBuZXcgU2VyaWFsaXplcihcImFzc2V0X2NsYWltX2ZlZXNcIiwgeyBmZWU6IGFzc2V0LFxuICAgIGlzc3VlcjogcHJvdG9jb2xfaWRfdHlwZShcImFjY291bnRcIiksXG4gICAgYW1vdW50X3RvX2NsYWltOiBhc3NldCxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG5vcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IFt0cmFuc2ZlciwgbGltaXRfb3JkZXJfY3JlYXRlLCBsaW1pdF9vcmRlcl9jYW5jZWwsIGNhbGxfb3JkZXJfdXBkYXRlLCBmaWxsX29yZGVyLCBhY2NvdW50X2NyZWF0ZSwgYWNjb3VudF91cGRhdGUsIGFjY291bnRfd2hpdGVsaXN0LCBhY2NvdW50X3VwZ3JhZGUsIGFjY291bnRfdHJhbnNmZXIsIGFzc2V0X2NyZWF0ZSwgYXNzZXRfdXBkYXRlLCBhc3NldF91cGRhdGVfYml0YXNzZXQsIGFzc2V0X3VwZGF0ZV9mZWVkX3Byb2R1Y2VycywgYXNzZXRfaXNzdWUsIGFzc2V0X3Jlc2VydmUsIGFzc2V0X2Z1bmRfZmVlX3Bvb2wsIGFzc2V0X3NldHRsZSwgYXNzZXRfZ2xvYmFsX3NldHRsZSwgYXNzZXRfcHVibGlzaF9mZWVkLCB3aXRuZXNzX2NyZWF0ZSwgd2l0bmVzc191cGRhdGUsIHByb3Bvc2FsX2NyZWF0ZSwgcHJvcG9zYWxfdXBkYXRlLCBwcm9wb3NhbF9kZWxldGUsIHdpdGhkcmF3X3Blcm1pc3Npb25fY3JlYXRlLCB3aXRoZHJhd19wZXJtaXNzaW9uX3VwZGF0ZSwgd2l0aGRyYXdfcGVybWlzc2lvbl9jbGFpbSwgd2l0aGRyYXdfcGVybWlzc2lvbl9kZWxldGUsIGNvbW1pdHRlZV9tZW1iZXJfY3JlYXRlLCBjb21taXR0ZWVfbWVtYmVyX3VwZGF0ZSwgY29tbWl0dGVlX21lbWJlcl91cGRhdGVfZ2xvYmFsX3BhcmFtZXRlcnMsIHZlc3RpbmdfYmFsYW5jZV9jcmVhdGUsIHZlc3RpbmdfYmFsYW5jZV93aXRoZHJhdywgd29ya2VyX2NyZWF0ZSwgY3VzdG9tLCBhc3NlcnQsIGJhbGFuY2VfY2xhaW0sIG92ZXJyaWRlX3RyYW5zZmVyLCB0cmFuc2Zlcl90b19ibGluZCwgYmxpbmRfdHJhbnNmZXIsIHRyYW5zZmVyX2Zyb21fYmxpbmQsIGFzc2V0X3NldHRsZV9jYW5jZWwsIGFzc2V0X2NsYWltX2ZlZXNdO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBleHBvcnRzLnRyYW5zYWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2FjdGlvblwiLCB7IHJlZl9ibG9ja19udW06IHVpbnQxNixcbiAgICByZWZfYmxvY2tfcHJlZml4OiB1aW50MzIsXG4gICAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWMsXG4gICAgb3BlcmF0aW9uczogYXJyYXkob3BlcmF0aW9uKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpIH0pO1xuXG52YXIgc2lnbmVkX3RyYW5zYWN0aW9uID0gZXhwb3J0cy5zaWduZWRfdHJhbnNhY3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF90cmFuc2FjdGlvblwiLCB7IHJlZl9ibG9ja19udW06IHVpbnQxNixcbiAgICByZWZfYmxvY2tfcHJlZml4OiB1aW50MzIsXG4gICAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWMsXG4gICAgb3BlcmF0aW9uczogYXJyYXkob3BlcmF0aW9uKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpLFxuICAgIHNpZ25hdHVyZXM6IGFycmF5KGJ5dGVzKDY1KSkgfSk7XG4vLyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jICBHZW5lcmF0ZWQgY29kZSBlbmRcbi8vIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEN1c3RvbSBUeXBlc1xuXG52YXIgc3RlYWx0aF9tZW1vX2RhdGEgPSBleHBvcnRzLnN0ZWFsdGhfbWVtb19kYXRhID0gbmV3IFNlcmlhbGl6ZXIoXCJzdGVhbHRoX21lbW9fZGF0YVwiLCB7XG4gICAgZnJvbTogb3B0aW9uYWwocHVibGljX2tleSksXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBibGluZGluZ19mYWN0b3I6IGJ5dGVzKDMyKSxcbiAgICBjb21taXRtZW50OiBieXRlcygzMyksXG4gICAgY2hlY2s6IHVpbnQzMlxufSk7XG4vLyB2YXIgc3RlYWx0aF9jb25maXJtYXRpb24gPSBuZXcgU2VyaWFsaXplcihcbi8vICAgICBcInN0ZWFsdGhfY29uZmlybWF0aW9uXCIsIHtcbi8vICAgICBvbmVfdGltZV9rZXk6IHB1YmxpY19rZXksXG4vLyAgICAgdG86IG9wdGlvbmFsKCBwdWJsaWNfa2V5ICksXG4vLyAgICAgZW5jcnlwdGVkX21lbW86IHN0ZWFsdGhfbWVtb19kYXRhXG4vLyB9KSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ieXRlYnVmZmVyID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpO1xuXG52YXIgX2J5dGVidWZmZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnl0ZWJ1ZmZlcik7XG5cbnZhciBfZXJyb3Jfd2l0aF9jYXVzZSA9IHJlcXVpcmUoJy4vZXJyb3Jfd2l0aF9jYXVzZScpO1xuXG52YXIgX2Vycm9yX3dpdGhfY2F1c2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXJyb3Jfd2l0aF9jYXVzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIRVhfRFVNUCA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfX2dyYXBoZW5lX3NlcmlhbGl6ZXJfaGV4X2R1bXA7XG5cbnZhciBTZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIob3BlcmF0aW9uX25hbWUsIHR5cGVzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJpYWxpemVyKTtcblxuICAgICAgICB0aGlzLm9wZXJhdGlvbl9uYW1lID0gb3BlcmF0aW9uX25hbWU7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgaWYgKHRoaXMudHlwZXMpIHRoaXMua2V5cyA9IE9iamVjdC5rZXlzKHRoaXMudHlwZXMpO1xuXG4gICAgICAgIFNlcmlhbGl6ZXIucHJpbnREZWJ1ZyA9IHRydWU7XG4gICAgfVxuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuZnJvbUJ5dGVCdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUub3BlcmF0aW9uX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHR5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzEgPSBiLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMiA9IGIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIub2Zmc2V0ID0gbzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iLnJlc2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBiLmNvcHkobzEsIG8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCArICdcXHQnLCBfYi50b0hleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3RbZmllbGRdID0gdHlwZS5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTZXJpYWxpemVyLnByaW50RGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgJyArIHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCArICcgaW4gZGF0YTonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHJpbnREZWJ1ZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgX2Vycm9yX3dpdGhfY2F1c2UyLmRlZmF1bHQudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5hcHBlbmRCeXRlQnVmZmVyID0gZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yX3dpdGhfY2F1c2UyLmRlZmF1bHQudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgXCIgPSBcIiArIEpTT04uc3RyaW5naWZ5KG9iamVjdFtmaWVsZF0pLCBlcnJvcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2lyY3VsYXIgcmVmXG4gICAgICAgICAgICAgICAgX2Vycm9yX3dpdGhfY2F1c2UyLmRlZmF1bHQudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgXCIgPSBcIiArIG9iamVjdFtmaWVsZF0sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KHNlcmlhbGl6ZWRfb2JqZWN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmlhbGl6ZWRfb2JqZWN0W2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAvL0RFQlVHIHZhbHVlID0gdmFsdWUucmVzb2x2ZSBpZiB2YWx1ZS5yZXNvbHZlXG4gICAgICAgICAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZygnLi4uIHZhbHVlJyxmaWVsZCx2YWx1ZSlcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gdHlwZS5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRdID0gb2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgX2Vycm9yX3dpdGhfY2F1c2UyLmRlZmF1bHQudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2RlYnVnLnVzZV9kZWZhdWx0ID0gZmFsc2VdIC0gbW9yZSB0ZW1wbGF0ZSBmcmllbmRseVxuICAgICAgICBAYXJnIHtib29sZWFufSBbZGVidWcuYW5ub3RhdGUgPSBmYWxzZV0gLSBhZGQgdXNlci1mcmllbmRseSBpbmZvcm1hdGlvblxuICAgICovXG5cblxuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkX29iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyB1c2VfZGVmYXVsdDogZmFsc2UsIGFubm90YXRlOiBmYWxzZSB9O1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlcykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHR5cGUudG9PYmplY3QodHlwZW9mIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBudWxsID8gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdIDogdW5kZWZpbmVkLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkXSA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBuZXcgX2J5dGVidWZmZXIyLmRlZmF1bHQoX2J5dGVidWZmZXIyLmRlZmF1bHQuREVGQVVMVF9DQVBBQ0lUWSwgX2J5dGVidWZmZXIyLmRlZmF1bHQuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCB0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGwgPyBzZXJpYWxpemVkX29iamVjdFtmaWVsZF0gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBiID0gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGIudG9IZXgoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgX2Vycm9yX3dpdGhfY2F1c2UyLmRlZmF1bHQudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKiogU29ydCBieSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIG9wZXJhdGlvbiAqL1xuXG5cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0X2tleSA9IHRoaXMua2V5c1swXTtcbiAgICAgICAgdmFyIGZpcnN0X3R5cGUgPSB0aGlzLnR5cGVzW2ZpcnN0X2tleV07XG5cbiAgICAgICAgdmFyIHZhbEEgPSBhW2ZpcnN0X2tleV07XG4gICAgICAgIHZhciB2YWxCID0gYltmaXJzdF9rZXldO1xuXG4gICAgICAgIGlmIChmaXJzdF90eXBlLmNvbXBhcmUpIHJldHVybiBmaXJzdF90eXBlLmNvbXBhcmUodmFsQSwgdmFsQik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWxBID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWxCID09PSBcIm51bWJlclwiKSByZXR1cm4gdmFsQSAtIHZhbEI7XG5cbiAgICAgICAgdmFyIGVuY29kaW5nID0gdm9pZCAwO1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbEEpICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWxCKSkge1xuICAgICAgICAgICAgLy8gQSBiaW5hcnkgc3RyaW5nIGNvbXBhcmUgZG9lcyBub3Qgd29yay4gIElmIGxvY2FsZUNvbXBhcmUgaXMgd2VsbCBzdXBwb3J0ZWQgdGhhdCBjb3VsZCByZXBsYWNlIEhFWC4gIFBlcmZvcm1hbmFuY2UgaXMgdmVyeSBnb29kIHNvIGNvbXBhcmluZyBIRVggd29ya3MuXG4gICAgICAgICAgICBlbmNvZGluZyA9IFwiaGV4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyQSA9IHZhbEEudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICB2YXIgc3RyQiA9IHZhbEIudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4gc3RyQSA+IHN0ckIgPyAxIDogc3RyQSA8IHN0ckIgPyAtMSA6IDA7XG4gICAgfTtcblxuICAgIC8vIDxoZWxwZXJfZnVuY3Rpb25zPlxuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuZnJvbUhleCA9IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHZhciBiID0gX2J5dGVidWZmZXIyLmRlZmF1bHQuZnJvbUhleChoZXgsIF9ieXRlYnVmZmVyMi5kZWZhdWx0LkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICB9O1xuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIHZhciBiID0gX2J5dGVidWZmZXIyLmRlZmF1bHQuZnJvbUJpbmFyeShidWZmZXIudG9TdHJpbmcoXCJiaW5hcnlcIiksIF9ieXRlYnVmZmVyMi5kZWZhdWx0LkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICB9O1xuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiB0b0hleChvYmplY3QpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMudG9CdWZmZXIob2JqZWN0KS50b1N0cmluZyhcImhleFwiKVxuICAgICAgICB2YXIgYiA9IHRoaXMudG9CeXRlQnVmZmVyKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBiLnRvSGV4KCk7XG4gICAgfTtcblxuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLnRvQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcihvYmplY3QpIHtcbiAgICAgICAgdmFyIGIgPSBuZXcgX2J5dGVidWZmZXIyLmRlZmF1bHQoX2J5dGVidWZmZXIyLmRlZmF1bHQuREVGQVVMVF9DQVBBQ0lUWSwgX2J5dGVidWZmZXIyLmRlZmF1bHQuTElUVExFX0VORElBTik7XG4gICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy50b0J5dGVCdWZmZXIob2JqZWN0KS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXJpYWxpemVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTZXJpYWxpemVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB0ZW1wbGF0ZTtcblxuLyoqIENvbnNvbGUgcHJpbnQgYW55IHRyYW5zYWN0aW9uIG9iamVjdCB3aXRoIHplcm8gZGVmYXVsdCB2YWx1ZXMuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShvcCkge1xuXG4gICAgdmFyIG9iamVjdCA9IG9wLnRvT2JqZWN0KHZvaWQgMCwgeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IHRydWUgfSk7XG5cbiAgICAvLyB2aXN1YWwgKHdpdGggZGVzY3JpcHRpb25zKVxuICAgIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqZWN0LCBudWxsLCA0KSk7XG5cbiAgICAvLyB1c2FibGUgaW4gYSBjb3B5LXBhc3RlXG5cbiAgICBvYmplY3QgPSBvcC50b09iamVjdCh2b2lkIDAsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiBmYWxzZSB9KTtcblxuICAgIC8vIGNvcHktcGFzdGUgb25lLWxpbmVlclxuICAgIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8vIExvdy1sZXZlbCB0eXBlcyB0aGF0IG1ha2UgdXAgb3BlcmF0aW9uc1xuXG52YXIgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uID0gcmVxdWlyZShcIi4vU2VyaWFsaXplclZhbGlkYXRpb25cIik7XG5cbnZhciBfU2VyaWFsaXplclZhbGlkYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VyaWFsaXplclZhbGlkYXRpb24pO1xuXG52YXIgX0Zhc3RQYXJzZXIgPSByZXF1aXJlKFwiLi9GYXN0UGFyc2VyXCIpO1xuXG52YXIgX0Zhc3RQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRmFzdFBhcnNlcik7XG5cbnZhciBfQ2hhaW5UeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5UeXBlc1wiKTtcblxudmFyIF9DaGFpblR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoYWluVHlwZXMpO1xuXG52YXIgX09iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9PYmplY3RJZFwiKTtcblxudmFyIF9PYmplY3RJZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9PYmplY3RJZCk7XG5cbnZhciBfZWNjID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKTtcblxudmFyIF9iaXRzaGFyZXNqc1dzID0gcmVxdWlyZShcImJpdHNoYXJlc2pzLXdzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgVHlwZXMgPSB7fTtcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxuVHlwZXMudWludDggPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmLCBvYmplY3QsIFwidWludDggXCIgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVWludDgob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZiwgb2JqZWN0LCBcInVpbnQ4IFwiICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlX3JhbmdlKDAsIDB4ZmYsIG9iamVjdCwgXCJ1aW50OCBcIiArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQxNiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDE2KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmZmYsIG9iamVjdCwgXCJ1aW50MTYgXCIgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVWludDE2KG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlX3JhbmdlKDAsIDB4ZmZmZiwgb2JqZWN0LCBcInVpbnQxNiBcIiArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmZmYsIG9iamVjdCwgXCJ1aW50MTYgXCIgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG5UeXBlcy51aW50MzIgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQzMigpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZmZmZmZmZiwgb2JqZWN0LCBcInVpbnQzMiBcIiArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZmZmZmZmZiwgb2JqZWN0LCBcInVpbnQzMiBcIiArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmZmZmZmZmLCBvYmplY3QsIFwidWludDMyIFwiICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxudmFyIE1JTl9TSUdORURfMzIgPSAtMSAqIE1hdGgucG93KDIsIDMxKTtcbnZhciBNQVhfU0lHTkVEXzMyID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcblxuVHlwZXMudmFyaW50MzIgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFZhcmludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsIFwidWludDMyIFwiICsgb2JqZWN0KTtcbiAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlX3JhbmdlKE1JTl9TSUdORURfMzIsIE1BWF9TSUdORURfMzIsIG9iamVjdCwgXCJ1aW50MzIgXCIgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCBcInVpbnQzMiBcIiArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLmludDY0ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRJbnQ2NCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVJbnQ2NChfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQudG9fbG9uZyhvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQudG9fbG9uZyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnRvX2xvbmcob2JqZWN0KS50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQ2NCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDY0KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBiLndyaXRlVWludDY0KF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC50b19sb25nKF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC51bnNpZ25lZChvYmplY3QpLCB1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC50b19sb25nKF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC51bnNpZ25lZChvYmplY3QpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQudG9fbG9uZyhvYmplY3QsIHVuZGVmaW5lZCwgdHJ1ZSkudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy5zdHJpbmcgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIGJfY29weTtcbiAgICAgICAgdmFyIGxlbiA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBsZW4pLCBiLnNraXAobGVuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksIFwiYmluYXJ5XCIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKFwiYmluYXJ5XCIpLCBcImJpbmFyeVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMuYnl0ZXMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJfY29weTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgc2l6ZSksIGIuc2tpcChzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgXCJiaW5hcnlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBuZXcgQnVmZmVyKG9iamVjdCwgXCJoZXhcIik7XG5cbiAgICAgICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLmFwcGVuZChvYmplY3QudG9TdHJpbmcoXCJiaW5hcnlcIiksIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCwgXCJoZXhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB6ZXJvcyA9IGZ1bmN0aW9uIHplcm9zKG51bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KG51bSkuam9pbihcIjAwXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9zKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLmJvb2wgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCkgPT09IDE7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAvLyBzdXBwb3J0cyBib29sZWFuIG9yIGludGVnZXJcbiAgICAgICAgYi53cml0ZVVpbnQ4KEpTT04ucGFyc2Uob2JqZWN0KSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uob2JqZWN0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbn07XG5cblR5cGVzLnZvaWQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfVxufTtcblxuVHlwZXMuYXJyYXkgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBzaXplID8gaSA8IHNpemUgOiBpID4gc2l6ZTsgMCA8IHNpemUgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24ocmVzdWx0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3QobykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0LCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy50aW1lX3BvaW50X3NlYyA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJudW1iZXJcIikgb2JqZWN0ID0gVHlwZXMudGltZV9wb2ludF9zZWMuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIGIud3JpdGVVaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gTWF0aC5mbG9vcihvYmplY3QuZ2V0VGltZSgpIC8gMTAwMCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0ZSB0eXBlOiBcIiArIG9iamVjdCk7XG5cbiAgICAgICAgaWYgKC9UWzAtMl1bMC05XTpbMC01XVswLTldOlswLTVdWzAtOV0kLy50ZXN0KG9iamVjdCkpIG9iamVjdCA9IG9iamVjdCArIFwiWlwiO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKG9iamVjdCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IERhdGUoMCkudG9JU09TdHJpbmcoKS5zcGxpdChcIi5cIilbMF07XG5cbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdO1xuXG4gICAgICAgIHZhciBpbnQgPSBwYXJzZUludChvYmplY3QpO1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmZmZmZmZmLCBpbnQsIFwidWludDMyIFwiICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGludCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdO1xuICAgIH1cbn07XG5cblR5cGVzLnNldCA9IGZ1bmN0aW9uIChzdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBkdXBfbWFwID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9IHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobyksIFtcInN0cmluZ1wiLCBcIm51bWJlclwiXS5pbmRleE9mKHJlZikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHVwX21hcFtvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgKHNldClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHVwX21hcFtvXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24oYXJyYXksIHN0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInZhcmludDMyIHNpemUgPSBcIiArIHNpemUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBzaXplID8gaSA8IHNpemUgOiBpID4gc2l6ZTsgMCA8IHNpemUgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy52YWxpZGF0ZShvYmplY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBnbG9iYWxfcGFyYW1ldGVyc191cGRhdGVfb3BlcmF0aW9uIGN1cnJlbnRfZmVlc1xuVHlwZXMuZml4ZWRfYXJyYXkgPSBmdW5jdGlvbiAoY291bnQsIHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihyZXN1bHRzLCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGksIGosIHJlZjtcbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3RbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0LCBkZWJ1Zykge1xuICAgICAgICAgICAgdmFyIGksIGosIGssIHJlZiwgcmVmMSwgcmVzdWx0cywgcmVzdWx0czE7XG4gICAgICAgICAgICBpZiAoZGVidWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYnVnID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3Qodm9pZCAwLCBkZWJ1ZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gY291bnQ7IGsgPCByZWYxOyBpID0gayArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0W2ldLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qIFN1cHBvcnRzIGluc3RhbmNlIG51bWJlcnMgKDExKSBvciBvYmplY3QgdHlwZXMgKDEuMi4xMSkuICBPYmplY3QgdHlwZVxuVmFsaWRhdGlvbiBpcyBlbmZvcmNlZCB3aGVuIGFuIG9iamVjdCB0eXBlIGlzIHVzZWQuICovXG52YXIgaWRfdHlwZSA9IGZ1bmN0aW9uIGlkX3R5cGUocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSkge1xuICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChyZXNlcnZlZF9zcGFjZXMsIFwicmVzZXJ2ZWRfc3BhY2VzXCIpO1xuICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3RfdHlwZSwgXCJvYmplY3RfdHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgcmV0dXJuIGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IDEuMi5uIGludG8ganVzdCBuXG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIoX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnRvX251bWJlcihvYmplY3QpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQuaXNfZGlnaXRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnRvX251bWJlcihvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5nZXRfaW5zdGFuY2UocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSwgb2JqZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIG9iamVjdF90eXBlX2lkID0gX0NoYWluVHlwZXMyLmRlZmF1bHQub2JqZWN0X3R5cGVbb2JqZWN0X3R5cGVdO1xuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc2VydmVkX3NwYWNlcyArIFwiLlwiICsgb2JqZWN0X3R5cGVfaWQgKyBcIi4wXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNlcnZlZF9zcGFjZXMgKyBcIi5cIiArIG9iamVjdF90eXBlX2lkICsgXCIuXCIgKyBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMucHJvdG9jb2xfaWRfdHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG5hbWUsIFwibmFtZVwiKTtcbiAgICByZXR1cm4gaWRfdHlwZShfQ2hhaW5UeXBlczIuZGVmYXVsdC5yZXNlcnZlZF9zcGFjZXMucHJvdG9jb2xfaWRzLCBuYW1lKTtcbn07XG5cblR5cGVzLm9iamVjdF9pZF90eXBlID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBfT2JqZWN0SWQyLmRlZmF1bHQuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IF9PYmplY3RJZDIuZGVmYXVsdC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5hcHBlbmRCeXRlQnVmZmVyKGIpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfT2JqZWN0SWQyLmRlZmF1bHQuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMC4wLjBcIjtcbiAgICAgICAgfVxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IF9PYmplY3RJZDIuZGVmYXVsdC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy52b3RlX2lkID0ge1xuICAgIFRZUEU6IDB4MDAwMDAwZmYsXG4gICAgSUQ6IDB4ZmZmZmZmMDAsXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYi5yZWFkVWludDMyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZSAmIHRoaXMuVFlQRSxcbiAgICAgICAgICAgIGlkOiB2YWx1ZSAmIHRoaXMuSURcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuaWQgPDwgOCB8IG9iamVjdC50eXBlO1xuICAgICAgICBiLndyaXRlVWludDMyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCwgXCIodHlwZSB2b3RlX2lkKVwiKTtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqZWN0KSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QudHlwZSwgXCJ0eXBlXCIpO1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdC5pZCwgXCJpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVfdGVzdCgvXlswLTldKzpbMC05XSskLywgb2JqZWN0LCBcInZvdGVfaWQgZm9ybWF0IFwiICsgb2JqZWN0KTtcblxuICAgICAgICB2YXIgX29iamVjdCRzcGxpdCA9IG9iamVjdC5zcGxpdChcIjpcIiksXG4gICAgICAgICAgICB0eXBlID0gX29iamVjdCRzcGxpdFswXSxcbiAgICAgICAgICAgIGlkID0gX29iamVjdCRzcGxpdFsxXTtcblxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZV9yYW5nZSgwLCAweGZmLCB0eXBlLCBcInZvdGUgdHlwZSBcIiArIG9iamVjdCk7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlX3JhbmdlKDAsIDB4ZmZmZmZmLCBpZCwgXCJ2b3RlIGlkIFwiICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgaWQ6IGlkIH07XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwOjBcIjtcbiAgICAgICAgfVxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIG9iamVjdCA9IFR5cGVzLnZvdGVfaWQuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIHJldHVybiBvYmplY3QudHlwZSArIFwiOlwiICsgb2JqZWN0LmlkO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihhKSkgIT09IFwib2JqZWN0XCIpIGEgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3QoYSk7XG4gICAgICAgIGlmICgodHlwZW9mIGIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihiKSkgIT09IFwib2JqZWN0XCIpIGIgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3QoYik7XG4gICAgICAgIHJldHVybiBwYXJzZUludChhLmlkKSAtIHBhcnNlSW50KGIuaWQpO1xuICAgIH1cbn07XG5cblR5cGVzLm9wdGlvbmFsID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwic3Rfb3BlcmF0aW9uXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICBpZiAoIShiLnJlYWRVaW50OCgpID09PSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIud3JpdGVVaW50OCgxKTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIHRvT2JqZWN0IGlzIG9ubHkgbnVsbCBzYXZlIGlmIHVzZV9kZWZhdWx0IGlzIHRydWVcbiAgICAgICAgICAgIHZhciByZXN1bHRfb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLmFubm90YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0X29iamVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHJlc3VsdF9vYmplY3QpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRfb2JqZWN0Ll9fb3B0aW9uYWwgPSBcInBhcmVudCBpcyBvcHRpb25hbFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF9vYmplY3QgPSB7IF9fb3B0aW9uYWw6IHJlc3VsdF9vYmplY3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0X29iamVjdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5zdGF0aWNfdmFyaWFudCA9IGZ1bmN0aW9uIChfc3Rfb3BlcmF0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vc29ydDogdHJ1ZSxcbiAgICAgICAgc3Rfb3BlcmF0aW9uczogX3N0X29wZXJhdGlvbnMsXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInN0YXRpY192YXJpYW50IGlkIDB4XCIgKyB0eXBlX2lkLnRvU3RyaW5nKDE2KSArIFwiIChcIiArIHR5cGVfaWQgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCBcIm9wZXJhdGlvbiBcIiArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYildO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IG9iamVjdFswXTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCBcIm9wZXJhdGlvbiBcIiArIHR5cGVfaWQpO1xuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKHR5cGVfaWQpO1xuICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0WzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBvYmplY3RbMF07XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgXCJvcGVyYXRpb24gXCIgKyB0eXBlX2lkKTtcbiAgICAgICAgICAgIHJldHVybiBbdHlwZV9pZCwgc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob2JqZWN0WzFdKV07XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgdGhpcy5zdF9vcGVyYXRpb25zWzBdLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBvYmplY3RbMF07XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgX1NlcmlhbGl6ZXJWYWxpZGF0aW9uMi5kZWZhdWx0LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgXCJvcGVyYXRpb24gXCIgKyB0eXBlX2lkKTtcbiAgICAgICAgICAgIHJldHVybiBbdHlwZV9pZCwgc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdFsxXSwgZGVidWcpXTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5tYXAgPSBmdW5jdGlvbiAoa2V5X3N0X29wZXJhdGlvbiwgdmFsdWVfc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR1cF9tYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICBpZiAoIShvLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIHR3byBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9IF90eXBlb2Yob1swXSksIFtcIm51bWJlclwiLCBcInN0cmluZ1wiXS5pbmRleE9mKHJlZikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHVwX21hcFtvWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgKG1hcClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHVwX21hcFtvWzBdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24oYXJyYXksIGtleV9zdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGVuZCA/IGkgPCBlbmQgOiBpID4gZW5kOyAwIDwgZW5kID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleV9zdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYiksIHZhbHVlX3N0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICBrZXlfc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb1swXSk7XG4gICAgICAgICAgICAgICAgdmFsdWVfc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9bMF0pLCB2YWx1ZV9zdF9vcGVyYXRpb24uZnJvbU9iamVjdChvWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtba2V5X3N0X29wZXJhdGlvbi50b09iamVjdCh1bmRlZmluZWQsIGRlYnVnKSwgdmFsdWVfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXMudmFsaWRhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi50b09iamVjdChvWzBdLCBkZWJ1ZyksIHZhbHVlX3N0X29wZXJhdGlvbi50b09iamVjdChvWzFdLCBkZWJ1ZyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMucHVibGljX2tleSA9IHtcbiAgICB0b1B1YmxpYzogZnVuY3Rpb24gdG9QdWJsaWMob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3QuUSA/IG9iamVjdCA6IF9lY2MuUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KG9iamVjdCk7XG4gICAgfSxcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gX0Zhc3RQYXJzZXIyLmRlZmF1bHQucHVibGljX2tleShiKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBfRmFzdFBhcnNlcjIuZGVmYXVsdC5wdWJsaWNfa2V5KGIsIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LlEpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCArIFwiODU5Z3hmblh5VXJpTWdVZVRoaDFmV3Yzb3FjcExGeUhhM1RmRllDNFBLMkhxaFRvVk1cIjtcbiAgICAgICAgfVxuICAgICAgICBfU2VyaWFsaXplclZhbGlkYXRpb24yLmRlZmF1bHQucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBUeXBlcy5wdWJsaWNfa2V5LmZyb21PYmplY3QoYSkudG9CbG9ja2NoYWluQWRkcmVzcygpLmNvbXBhcmUoVHlwZXMucHVibGljX2tleS5mcm9tT2JqZWN0KGIpLnRvQmxvY2tjaGFpbkFkZHJlc3MoKSk7XG4gICAgfVxufTtcblxuVHlwZXMuYWRkcmVzcyA9IHtcbiAgICBfdG9fYWRkcmVzczogZnVuY3Rpb24gX3RvX2FkZHJlc3Mob2JqZWN0KSB7XG4gICAgICAgIF9TZXJpYWxpemVyVmFsaWRhdGlvbjIuZGVmYXVsdC5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LmFkZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9lY2MuQWRkcmVzcy5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgfSxcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gbmV3IF9lY2MuQWRkcmVzcyhfRmFzdFBhcnNlcjIuZGVmYXVsdC5yaXBlbWQxNjAoYikpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgX0Zhc3RQYXJzZXIyLmRlZmF1bHQucmlwZW1kMTYwKGIsIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KS50b0J1ZmZlcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYml0c2hhcmVzanNXcy5DaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCArIFwiNjY0S21IeFN1UXlEc2Z3bzRXRUp2V3B6ZzFRS2RnNjdTXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBzdHJDbXAoYS50b1N0cmluZygpLCBiLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5cbnZhciBzdHJDbXAgPSBmdW5jdGlvbiBzdHJDbXAoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG52YXIgZmlyc3RFbCA9IGZ1bmN0aW9uIGZpcnN0RWwoZWwpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlbCkgPyBlbFswXSA6IGVsO1xufTtcbnZhciBzb3J0T3BlcmF0aW9uID0gZnVuY3Rpb24gc29ydE9wZXJhdGlvbihhcnJheSwgc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHN0X29wZXJhdGlvbi5ub3NvcnQgPyBhcnJheSA6IHN0X29wZXJhdGlvbi5jb21wYXJlID8gYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmNvbXBhcmUoZmlyc3RFbChhKSwgZmlyc3RFbChiKSk7XG4gICAgfSkgLy8gY3VzdG9tIGNvbXBhcmUgb3BlcmF0aW9uXG4gICAgOiBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZmlyc3RFbChhKSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZmlyc3RFbChiKSA9PT0gXCJudW1iZXJcIiA/IGZpcnN0RWwoYSkgLSBmaXJzdEVsKGIpIDogLy8gQSBiaW5hcnkgc3RyaW5nIGNvbXBhcmUgZG9lcyBub3Qgd29yay4gUGVyZm9ybWFuYW5jZSBpcyB2ZXJ5IGdvb2Qgc28gSEVYIGlzIHVzZWQuLiAgbG9jYWxlQ29tcGFyZSBpcyBhbm90aGVyIG9wdGlvbi5cbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGZpcnN0RWwoYSkpICYmIEJ1ZmZlci5pc0J1ZmZlcihmaXJzdEVsKGIpKSA/IHN0ckNtcChmaXJzdEVsKGEpLnRvU3RyaW5nKFwiaGV4XCIpLCBmaXJzdEVsKGIpLnRvU3RyaW5nKFwiaGV4XCIpKSA6IHN0ckNtcChmaXJzdEVsKGEpLnRvU3RyaW5nKCksIGZpcnN0RWwoYikudG9TdHJpbmcoKSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUeXBlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiLy8gYmFzZS14IGVuY29kaW5nXG4vLyBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbi8vIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbi8vIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbi8vIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbi8vIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIHZhciBBTFBIQUJFVF9NQVAgPSB7fVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG5cbiAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gIGZvciAodmFyIHogPSAwOyB6IDwgQUxQSEFCRVQubGVuZ3RoOyB6KyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdCh6KVxuXG4gICAgaWYgKEFMUEhBQkVUX01BUFt4XSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpXG4gICAgQUxQSEFCRVRfTUFQW3hdID0gelxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG5cbiAgICB2YXIgZGlnaXRzID0gWzBdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IHNvdXJjZVtpXTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgOFxuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIEJBU0VcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSB8IDBcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIEJBU0UpXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9ICcnXG5cbiAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIGZvciAodmFyIGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHN0cmluZyArPSBBTFBIQUJFVFswXVxuICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgZm9yICh2YXIgcSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBxID49IDA7IC0tcSkgc3RyaW5nICs9IEFMUEhBQkVUW2RpZ2l0c1txXV1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMClcblxuICAgIHZhciBieXRlcyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBBTFBIQUJFVF9NQVBbc3RyaW5nW2ldXVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVyblxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogQkFTRVxuICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZlxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKVxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yICh2YXIgayA9IDA7IHN0cmluZ1trXSA9PT0gTEVBREVSICYmIGsgPCBzdHJpbmcubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICBieXRlcy5wdXNoKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzLnJldmVyc2UoKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGJ1ZmZlclxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvLyAocHVibGljKSBDb25zdHJ1Y3RvclxuZnVuY3Rpb24gQmlnSW50ZWdlcihhLCBiLCBjKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyKSlcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYSwgYiwgYylcblxuICBpZiAoYSAhPSBudWxsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHRoaXMuZnJvbU51bWJlcihhLCBiLCBjKVxuICAgIGVsc2UgaWYgKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwgMjU2KVxuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsIGIpXG4gIH1cbn1cblxudmFyIHByb3RvID0gQmlnSW50ZWdlci5wcm90b3R5cGVcblxuLy8gZHVjay10eXBlZCBpc0JpZ0ludGVnZXJcbnByb3RvLl9fYmlnaSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cbkJpZ0ludGVnZXIuaXNCaWdJbnRlZ2VyID0gZnVuY3Rpb24gKG9iaiwgY2hlY2tfdmVyKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fYmlnaSAmJiAoIWNoZWNrX3ZlciB8fCBvYmouX19iaWdpID09PSBwcm90by5fX2JpZ2kpXG59XG5cbi8vIEJpdHMgcGVyIGRpZ2l0XG52YXIgZGJpdHNcblxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cblxuLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxuLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2Vcbi8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbmZ1bmN0aW9uIGFtMShpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciB2ID0geCAqIHRoaXNbaSsrXSArIHdbal0gKyBjXG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDB4NDAwMDAwMClcbiAgICB3W2orK10gPSB2ICYgMHgzZmZmZmZmXG4gIH1cbiAgcmV0dXJuIGNcbn1cbi8vIGFtMiBhdm9pZHMgYSBiaWcgbXVsdC1hbmQtZXh0cmFjdCBjb21wbGV0ZWx5LlxuLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbi8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbmZ1bmN0aW9uIGFtMihpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHZhciB4bCA9IHggJiAweDdmZmYsXG4gICAgeGggPSB4ID4+IDE1XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpc1tpXSAmIDB4N2ZmZlxuICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE1XG4gICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGxcbiAgICBsID0geGwgKiBsICsgKChtICYgMHg3ZmZmKSA8PCAxNSkgKyB3W2pdICsgKGMgJiAweDNmZmZmZmZmKVxuICAgIGMgPSAobCA+Pj4gMzApICsgKG0gPj4+IDE1KSArIHhoICogaCArIChjID4+PiAzMClcbiAgICB3W2orK10gPSBsICYgMHgzZmZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG4vLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcbi8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbmZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHZhciB4bCA9IHggJiAweDNmZmYsXG4gICAgeGggPSB4ID4+IDE0XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpc1tpXSAmIDB4M2ZmZlxuICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE0XG4gICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGxcbiAgICBsID0geGwgKiBsICsgKChtICYgMHgzZmZmKSA8PCAxNCkgKyB3W2pdICsgY1xuICAgIGMgPSAobCA+PiAyOCkgKyAobSA+PiAxNCkgKyB4aCAqIGhcbiAgICB3W2orK10gPSBsICYgMHhmZmZmZmZmXG4gIH1cbiAgcmV0dXJuIGNcbn1cblxuLy8gd3RmP1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTFcbmRiaXRzID0gMjZcblxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0c1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDEgPDwgZGJpdHMpIC0gMSlcbnZhciBEViA9IEJpZ0ludGVnZXIucHJvdG90eXBlLkRWID0gKDEgPDwgZGJpdHMpXG5cbnZhciBCSV9GUCA9IDUyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsIEJJX0ZQKVxuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIgKiBkYml0cyAtIEJJX0ZQXG5cbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiXG52YXIgQklfUkMgPSBuZXcgQXJyYXkoKVxudmFyIHJyLCB2dlxucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApXG5mb3IgKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2dlxucnIgPSBcImFcIi5jaGFyQ29kZUF0KDApXG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnZcbnJyID0gXCJBXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHtcbiAgcmV0dXJuIEJJX1JNLmNoYXJBdChuKVxufVxuXG5mdW5jdGlvbiBpbnRBdChzLCBpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXVxuICByZXR1cm4gKGMgPT0gbnVsbCkgPyAtMSA6IGNcbn1cblxuLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbmZ1bmN0aW9uIGJucENvcHlUbyhyKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkgcltpXSA9IHRoaXNbaV1cbiAgci50ID0gdGhpcy50XG4gIHIucyA9IHRoaXMuc1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxXG4gIHRoaXMucyA9ICh4IDwgMCkgPyAtMSA6IDBcbiAgaWYgKHggPiAwKSB0aGlzWzBdID0geFxuICBlbHNlIGlmICh4IDwgLTEpIHRoaXNbMF0gPSB4ICsgRFZcbiAgZWxzZSB0aGlzLnQgPSAwXG59XG5cbi8vIHJldHVybiBiaWdpbnQgaW5pdGlhbGl6ZWQgdG8gdmFsdWVcbmZ1bmN0aW9uIG5idihpKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICByLmZyb21JbnQoaSlcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gc3RyaW5nIGFuZCByYWRpeFxuZnVuY3Rpb24gYm5wRnJvbVN0cmluZyhzLCBiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBrXG4gIGlmIChiID09IDE2KSBrID0gNFxuICBlbHNlIGlmIChiID09IDgpIGsgPSAzXG4gIGVsc2UgaWYgKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmIChiID09IDIpIGsgPSAxXG4gIGVsc2UgaWYgKGIgPT0gMzIpIGsgPSA1XG4gIGVsc2UgaWYgKGIgPT0gNCkgayA9IDJcbiAgZWxzZSB7XG4gICAgc2VsZi5mcm9tUmFkaXgocywgYilcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLnQgPSAwXG4gIHNlbGYucyA9IDBcbiAgdmFyIGkgPSBzLmxlbmd0aCxcbiAgICBtaSA9IGZhbHNlLFxuICAgIHNoID0gMFxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB2YXIgeCA9IChrID09IDgpID8gc1tpXSAmIDB4ZmYgOiBpbnRBdChzLCBpKVxuICAgIGlmICh4IDwgMCkge1xuICAgICAgaWYgKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIG1pID0gZmFsc2VcbiAgICBpZiAoc2ggPT0gMClcbiAgICAgIHNlbGZbc2VsZi50KytdID0geFxuICAgIGVsc2UgaWYgKHNoICsgayA+IHNlbGYuREIpIHtcbiAgICAgIHNlbGZbc2VsZi50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHNlbGYuREIgLSBzaCkpIC0gMSkpIDw8IHNoXG4gICAgICBzZWxmW3NlbGYudCsrXSA9ICh4ID4+IChzZWxmLkRCIC0gc2gpKVxuICAgIH0gZWxzZVxuICAgICAgc2VsZltzZWxmLnQgLSAxXSB8PSB4IDw8IHNoXG4gICAgc2ggKz0ga1xuICAgIGlmIChzaCA+PSBzZWxmLkRCKSBzaCAtPSBzZWxmLkRCXG4gIH1cbiAgaWYgKGsgPT0gOCAmJiAoc1swXSAmIDB4ODApICE9IDApIHtcbiAgICBzZWxmLnMgPSAtMVxuICAgIGlmIChzaCA+IDApIHNlbGZbc2VsZi50IC0gMV0gfD0gKCgxIDw8IChzZWxmLkRCIC0gc2gpKSAtIDEpIDw8IHNoXG4gIH1cbiAgc2VsZi5jbGFtcCgpXG4gIGlmIChtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHNlbGYsIHNlbGYpXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zICYgdGhpcy5ETVxuICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudCAtIDFdID09IGMpLS10aGlzLnRcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5zIDwgMCkgcmV0dXJuIFwiLVwiICsgc2VsZi5uZWdhdGUoKVxuICAgIC50b1N0cmluZyhiKVxuICB2YXIga1xuICBpZiAoYiA9PSAxNikgayA9IDRcbiAgZWxzZSBpZiAoYiA9PSA4KSBrID0gM1xuICBlbHNlIGlmIChiID09IDIpIGsgPSAxXG4gIGVsc2UgaWYgKGIgPT0gMzIpIGsgPSA1XG4gIGVsc2UgaWYgKGIgPT0gNCkgayA9IDJcbiAgZWxzZSByZXR1cm4gc2VsZi50b1JhZGl4KGIpXG4gIHZhciBrbSA9ICgxIDw8IGspIC0gMSxcbiAgICBkLCBtID0gZmFsc2UsXG4gICAgciA9IFwiXCIsXG4gICAgaSA9IHNlbGYudFxuICB2YXIgcCA9IHNlbGYuREIgLSAoaSAqIHNlbGYuREIpICUga1xuICBpZiAoaS0tID4gMCkge1xuICAgIGlmIChwIDwgc2VsZi5EQiAmJiAoZCA9IHNlbGZbaV0gPj4gcCkgPiAwKSB7XG4gICAgICBtID0gdHJ1ZVxuICAgICAgciA9IGludDJjaGFyKGQpXG4gICAgfVxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGlmIChwIDwgaykge1xuICAgICAgICBkID0gKHNlbGZbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKGsgLSBwKVxuICAgICAgICBkIHw9IHNlbGZbLS1pXSA+PiAocCArPSBzZWxmLkRCIC0gaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSA+PiAocCAtPSBrKSkgJiBrbVxuICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgcCArPSBzZWxmLkRCXG4gICAgICAgICAgLS1pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkID4gMCkgbSA9IHRydWVcbiAgICAgIGlmIChtKSByICs9IGludDJjaGFyKGQpXG4gICAgfVxuICB9XG4gIHJldHVybiBtID8gciA6IFwiMFwiXG59XG5cbi8vIChwdWJsaWMpIC10aGlzXG5mdW5jdGlvbiBibk5lZ2F0ZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB8dGhpc3xcbmZ1bmN0aW9uIGJuQWJzKCkge1xuICByZXR1cm4gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXNcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbmZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpIHtcbiAgdmFyIHIgPSB0aGlzLnMgLSBhLnNcbiAgaWYgKHIgIT0gMCkgcmV0dXJuIHJcbiAgdmFyIGkgPSB0aGlzLnRcbiAgciA9IGkgLSBhLnRcbiAgaWYgKHIgIT0gMCkgcmV0dXJuICh0aGlzLnMgPCAwKSA/IC1yIDogclxuICB3aGlsZSAoLS1pID49IDApXG4gICAgaWYgKChyID0gdGhpc1tpXSAtIGFbaV0pICE9IDApIHJldHVybiByXG4gIHJldHVybiAwXG59XG5cbi8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG5mdW5jdGlvbiBuYml0cyh4KSB7XG4gIHZhciByID0gMSxcbiAgICB0XG4gIGlmICgodCA9IHggPj4+IDE2KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDE2XG4gIH1cbiAgaWYgKCh0ID0geCA+PiA4KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDhcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gNFxuICB9XG4gIGlmICgodCA9IHggPj4gMikgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAyXG4gIH1cbiAgaWYgKCh0ID0geCA+PiAxKSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDFcbiAgfVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgaWYgKHRoaXMudCA8PSAwKSByZXR1cm4gMFxuICByZXR1cm4gdGhpcy5EQiAqICh0aGlzLnQgLSAxKSArIG5iaXRzKHRoaXNbdGhpcy50IC0gMV0gXiAodGhpcy5zICYgdGhpcy5ETSkpXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJ5dGVMZW5ndGgoKSB7XG4gIHJldHVybiB0aGlzLmJpdExlbmd0aCgpID4+IDNcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHJbaSArIG5dID0gdGhpc1tpXVxuICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwXG4gIHIudCA9IHRoaXMudCArIG5cbiAgci5zID0gdGhpcy5zXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLCByKSB7XG4gIGZvciAodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHJbaSAtIG5dID0gdGhpc1tpXVxuICByLnQgPSBNYXRoLm1heCh0aGlzLnQgLSBuLCAwKVxuICByLnMgPSB0aGlzLnNcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obiwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGJzID0gbiAlIHNlbGYuREJcbiAgdmFyIGNicyA9IHNlbGYuREIgLSBic1xuICB2YXIgYm0gPSAoMSA8PCBjYnMpIC0gMVxuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyBzZWxmLkRCKSxcbiAgICBjID0gKHNlbGYucyA8PCBicykgJiBzZWxmLkRNLFxuICAgIGlcbiAgZm9yIChpID0gc2VsZi50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICByW2kgKyBkcyArIDFdID0gKHNlbGZbaV0gPj4gY2JzKSB8IGNcbiAgICBjID0gKHNlbGZbaV0gJiBibSkgPDwgYnNcbiAgfVxuICBmb3IgKGkgPSBkcyAtIDE7IGkgPj0gMDsgLS1pKSByW2ldID0gMFxuICByW2RzXSA9IGNcbiAgci50ID0gc2VsZi50ICsgZHMgKyAxXG4gIHIucyA9IHNlbGYuc1xuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obiwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgci5zID0gc2VsZi5zXG4gIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHNlbGYuREIpXG4gIGlmIChkcyA+PSBzZWxmLnQpIHtcbiAgICByLnQgPSAwXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGJzID0gbiAlIHNlbGYuREJcbiAgdmFyIGNicyA9IHNlbGYuREIgLSBic1xuICB2YXIgYm0gPSAoMSA8PCBicykgLSAxXG4gIHJbMF0gPSBzZWxmW2RzXSA+PiBic1xuICBmb3IgKHZhciBpID0gZHMgKyAxOyBpIDwgc2VsZi50OyArK2kpIHtcbiAgICByW2kgLSBkcyAtIDFdIHw9IChzZWxmW2ldICYgYm0pIDw8IGNic1xuICAgIHJbaSAtIGRzXSA9IHNlbGZbaV0gPj4gYnNcbiAgfVxuICBpZiAoYnMgPiAwKSByW3NlbGYudCAtIGRzIC0gMV0gfD0gKHNlbGYucyAmIGJtKSA8PCBjYnNcbiAgci50ID0gc2VsZi50IC0gZHNcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGkgPSAwLFxuICAgIGMgPSAwLFxuICAgIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgYyArPSBzZWxmW2ldIC0gYVtpXVxuICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgYyA+Pj0gc2VsZi5EQlxuICB9XG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBjIC09IGEuc1xuICAgIHdoaWxlIChpIDwgc2VsZi50KSB7XG4gICAgICBjICs9IHNlbGZbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgKz0gc2VsZi5zXG4gIH0gZWxzZSB7XG4gICAgYyArPSBzZWxmLnNcbiAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgYyAtPSBhW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjIC09IGEuc1xuICB9XG4gIHIucyA9IChjIDwgMCkgPyAtMSA6IDBcbiAgaWYgKGMgPCAtMSkgcltpKytdID0gc2VsZi5EViArIGNcbiAgZWxzZSBpZiAoYyA+IDApIHJbaSsrXSA9IGNcbiAgci50ID0gaVxuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLCByKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKSxcbiAgICB5ID0gYS5hYnMoKVxuICB2YXIgaSA9IHgudFxuICByLnQgPSBpICsgeS50XG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKSByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpXG4gIHIucyA9IDBcbiAgci5jbGFtcCgpXG4gIGlmICh0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcilcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKVxuICB2YXIgaSA9IHIudCA9IDIgKiB4LnRcbiAgd2hpbGUgKC0taSA+PSAwKSByW2ldID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgeC50IC0gMTsgKytpKSB7XG4gICAgdmFyIGMgPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKVxuICAgIGlmICgocltpICsgeC50XSArPSB4LmFtKGkgKyAxLCAyICogeFtpXSwgciwgMiAqIGkgKyAxLCBjLCB4LnQgLSBpIC0gMSkpID49IHguRFYpIHtcbiAgICAgIHJbaSArIHgudF0gLT0geC5EVlxuICAgICAgcltpICsgeC50ICsgMV0gPSAxXG4gICAgfVxuICB9XG4gIGlmIChyLnQgPiAwKSByW3IudCAtIDFdICs9IHguYW0oaSwgeFtpXSwgciwgMiAqIGksIDAsIDEpXG4gIHIucyA9IDBcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuLy8gciAhPSBxLCB0aGlzICE9IG0uICBxIG9yIHIgbWF5IGJlIG51bGwuXG5mdW5jdGlvbiBibnBEaXZSZW1UbyhtLCBxLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcG0gPSBtLmFicygpXG4gIGlmIChwbS50IDw9IDApIHJldHVyblxuICB2YXIgcHQgPSBzZWxmLmFicygpXG4gIGlmIChwdC50IDwgcG0udCkge1xuICAgIGlmIChxICE9IG51bGwpIHEuZnJvbUludCgwKVxuICAgIGlmIChyICE9IG51bGwpIHNlbGYuY29weVRvKHIpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHIgPT0gbnVsbCkgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHRzID0gc2VsZi5zLFxuICAgIG1zID0gbS5zXG4gIHZhciBuc2ggPSBzZWxmLkRCIC0gbmJpdHMocG1bcG0udCAtIDFdKTsgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgaWYgKG5zaCA+IDApIHtcbiAgICBwbS5sU2hpZnRUbyhuc2gsIHkpXG4gICAgcHQubFNoaWZ0VG8obnNoLCByKVxuICB9IGVsc2Uge1xuICAgIHBtLmNvcHlUbyh5KVxuICAgIHB0LmNvcHlUbyhyKVxuICB9XG4gIHZhciB5cyA9IHkudFxuICB2YXIgeTAgPSB5W3lzIC0gMV1cbiAgaWYgKHkwID09IDApIHJldHVyblxuICB2YXIgeXQgPSB5MCAqICgxIDw8IHNlbGYuRjEpICsgKCh5cyA+IDEpID8geVt5cyAtIDJdID4+IHNlbGYuRjIgOiAwKVxuICB2YXIgZDEgPSBzZWxmLkZWIC8geXQsXG4gICAgZDIgPSAoMSA8PCBzZWxmLkYxKSAvIHl0LFxuICAgIGUgPSAxIDw8IHNlbGYuRjJcbiAgdmFyIGkgPSByLnQsXG4gICAgaiA9IGkgLSB5cyxcbiAgICB0ID0gKHEgPT0gbnVsbCkgPyBuZXcgQmlnSW50ZWdlcigpIDogcVxuICB5LmRsU2hpZnRUbyhqLCB0KVxuICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHJbci50KytdID0gMVxuICAgIHIuc3ViVG8odCwgcilcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsIHQpXG4gIHQuc3ViVG8oeSwgeSk7IC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlICh5LnQgPCB5cykgeVt5LnQrK10gPSAwXG4gIHdoaWxlICgtLWogPj0gMCkge1xuICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgdmFyIHFkID0gKHJbLS1pXSA9PSB5MCkgPyBzZWxmLkRNIDogTWF0aC5mbG9vcihyW2ldICogZDEgKyAocltpIC0gMV0gKyBlKSAqIGQyKVxuICAgIGlmICgocltpXSArPSB5LmFtKDAsIHFkLCByLCBqLCAwLCB5cykpIDwgcWQpIHsgLy8gVHJ5IGl0IG91dFxuICAgICAgeS5kbFNoaWZ0VG8oaiwgdClcbiAgICAgIHIuc3ViVG8odCwgcilcbiAgICAgIHdoaWxlIChyW2ldIDwgLS1xZCkgci5zdWJUbyh0LCByKVxuICAgIH1cbiAgfVxuICBpZiAocSAhPSBudWxsKSB7XG4gICAgci5kclNoaWZ0VG8oeXMsIHEpXG4gICAgaWYgKHRzICE9IG1zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSwgcSlcbiAgfVxuICByLnQgPSB5c1xuICByLmNsYW1wKClcbiAgaWYgKG5zaCA+IDApIHIuclNoaWZ0VG8obnNoLCByKTsgLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gIGlmICh0cyA8IDApIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKVxufVxuXG4vLyAocHVibGljKSB0aGlzIG1vZCBhXG5mdW5jdGlvbiBibk1vZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmFicygpXG4gICAgLmRpdlJlbVRvKGEsIG51bGwsIHIpXG4gIGlmICh0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSBhLnN1YlRvKHIsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxuZnVuY3Rpb24gQ2xhc3NpYyhtKSB7XG4gIHRoaXMubSA9IG1cbn1cblxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZiAoeC5zIDwgMCB8fCB4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHJldHVybiB4Lm1vZCh0aGlzLm0pXG4gIGVsc2UgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gY1JldmVydCh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkge1xuICB4LmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgeClcbn1cblxuZnVuY3Rpb24gY011bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbmZ1bmN0aW9uIGNTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0XG5DbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlXG5DbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUb1xuQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG9cblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmICh0aGlzLnQgPCAxKSByZXR1cm4gMFxuICB2YXIgeCA9IHRoaXNbMF1cbiAgaWYgKCh4ICYgMSkgPT0gMCkgcmV0dXJuIDBcbiAgdmFyIHkgPSB4ICYgMzsgLy8geSA9PSAxL3ggbW9kIDJeMlxuICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmKSAqIHkpKSAmIDB4ZjsgLy8geSA9PSAxL3ggbW9kIDJeNFxuICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmZikgKiB5KSkgJiAweGZmOyAvLyB5ID09IDEveCBtb2QgMl44XG4gIHkgPSAoeSAqICgyIC0gKCgoeCAmIDB4ZmZmZikgKiB5KSAmIDB4ZmZmZikpKSAmIDB4ZmZmZjsgLy8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5XG4gIC8vIGFzc3VtZXMgMTYgPCBEQiA8PSAzMiBhbmQgYXNzdW1lcyBhYmlsaXR5IHRvIGhhbmRsZSA0OC1iaXQgaW50c1xuICB5ID0gKHkgKiAoMiAtIHggKiB5ICUgdGhpcy5EVikpICUgdGhpcy5EVjsgLy8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5ID4gMCkgPyB0aGlzLkRWIC0geSA6IC15XG59XG5cbi8vIE1vbnRnb21lcnkgcmVkdWN0aW9uXG5mdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgdGhpcy5tID0gbVxuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpXG4gIHRoaXMubXBsID0gdGhpcy5tcCAmIDB4N2ZmZlxuICB0aGlzLm1waCA9IHRoaXMubXAgPj4gMTVcbiAgdGhpcy51bSA9ICgxIDw8IChtLkRCIC0gMTUpKSAtIDFcbiAgdGhpcy5tdDIgPSAyICogbS50XG59XG5cbi8vIHhSIG1vZCBtXG5mdW5jdGlvbiBtb250Q29udmVydCh4KSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB4LmFicygpXG4gICAgLmRsU2hpZnRUbyh0aGlzLm0udCwgcilcbiAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpXG4gIGlmICh4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB0aGlzLm0uc3ViVG8ociwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHguY29weVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG4gIHJldHVybiByXG59XG5cbi8vIHggPSB4L1IgbW9kIG0gKEhBQyAxNC4zMilcbmZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCkge1xuICB3aGlsZSAoeC50IDw9IHRoaXMubXQyKSAvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICB4W3gudCsrXSA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4W2ldICYgMHg3ZmZmXG4gICAgdmFyIHUwID0gKGogKiB0aGlzLm1wbCArICgoKGogKiB0aGlzLm1waCArICh4W2ldID4+IDE1KSAqIHRoaXMubXBsKSAmIHRoaXMudW0pIDw8IDE1KSkgJiB4LkRNXG4gICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgaiA9IGkgKyB0aGlzLm0udFxuICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udClcbiAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICB3aGlsZSAoeFtqXSA+PSB4LkRWKSB7XG4gICAgICB4W2pdIC09IHguRFZcbiAgICAgIHhbKytqXSsrXG4gICAgfVxuICB9XG4gIHguY2xhbXAoKVxuICB4LmRyU2hpZnRUbyh0aGlzLm0udCwgeClcbiAgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0sIHgpXG59XG5cbi8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuZnVuY3Rpb24gbW9udFNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG4vLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG5mdW5jdGlvbiBtb250TXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IG1vbnRNdWxUb1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG9cblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG5mdW5jdGlvbiBibnBJc0V2ZW4oKSB7XG4gIHJldHVybiAoKHRoaXMudCA+IDApID8gKHRoaXNbMF0gJiAxKSA6IHRoaXMucykgPT0gMFxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzXmUsIGUgPCAyXjMyLCBkb2luZyBzcXIgYW5kIG11bCB3aXRoIFwiclwiIChIQUMgMTQuNzkpXG5mdW5jdGlvbiBibnBFeHAoZSwgeikge1xuICBpZiAoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHJldHVybiBCaWdJbnRlZ2VyLk9ORVxuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgcjIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIGcgPSB6LmNvbnZlcnQodGhpcyksXG4gICAgaSA9IG5iaXRzKGUpIC0gMVxuICBnLmNvcHlUbyhyKVxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB6LnNxclRvKHIsIHIyKVxuICAgIGlmICgoZSAmICgxIDw8IGkpKSA+IDApIHoubXVsVG8ocjIsIGcsIHIpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgdCA9IHJcbiAgICAgIHIgPSByMlxuICAgICAgcjIgPSB0XG4gICAgfVxuICB9XG4gIHJldHVybiB6LnJldmVydChyKVxufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLCBtKSB7XG4gIHZhciB6XG4gIGlmIChlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHogPSBuZXcgQ2xhc3NpYyhtKVxuICBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKVxuICByZXR1cm4gdGhpcy5leHAoZSwgeilcbn1cblxuLy8gcHJvdGVjdGVkXG5wcm90by5jb3B5VG8gPSBibnBDb3B5VG9cbnByb3RvLmZyb21JbnQgPSBibnBGcm9tSW50XG5wcm90by5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZ1xucHJvdG8uY2xhbXAgPSBibnBDbGFtcFxucHJvdG8uZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvXG5wcm90by5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG9cbnByb3RvLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG9cbnByb3RvLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG9cbnByb3RvLnN1YlRvID0gYm5wU3ViVG9cbnByb3RvLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvXG5wcm90by5zcXVhcmVUbyA9IGJucFNxdWFyZVRvXG5wcm90by5kaXZSZW1UbyA9IGJucERpdlJlbVRvXG5wcm90by5pbnZEaWdpdCA9IGJucEludkRpZ2l0XG5wcm90by5pc0V2ZW4gPSBibnBJc0V2ZW5cbnByb3RvLmV4cCA9IGJucEV4cFxuXG4vLyBwdWJsaWNcbnByb3RvLnRvU3RyaW5nID0gYm5Ub1N0cmluZ1xucHJvdG8ubmVnYXRlID0gYm5OZWdhdGVcbnByb3RvLmFicyA9IGJuQWJzXG5wcm90by5jb21wYXJlVG8gPSBibkNvbXBhcmVUb1xucHJvdG8uYml0TGVuZ3RoID0gYm5CaXRMZW5ndGhcbnByb3RvLmJ5dGVMZW5ndGggPSBibkJ5dGVMZW5ndGhcbnByb3RvLm1vZCA9IGJuTW9kXG5wcm90by5tb2RQb3dJbnQgPSBibk1vZFBvd0ludFxuXG4vLyAocHVibGljKVxuZnVuY3Rpb24gYm5DbG9uZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuY29weVRvKHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuICBpZiAodGhpcy5zIDwgMCkge1xuICAgIGlmICh0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF0gLSB0aGlzLkRWXG4gICAgZWxzZSBpZiAodGhpcy50ID09IDApIHJldHVybiAtMVxuICB9IGVsc2UgaWYgKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXVxuICBlbHNlIGlmICh0aGlzLnQgPT0gMCkgcmV0dXJuIDBcbiAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBieXRlXG5mdW5jdGlvbiBibkJ5dGVWYWx1ZSgpIHtcbiAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAyNCkgPj4gMjRcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIHNob3J0IChhc3N1bWVzIERCPj0xNilcbmZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHtcbiAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAxNikgPj4gMTZcbn1cblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIgKiB0aGlzLkRCIC8gTWF0aC5sb2cocikpXG59XG5cbi8vIChwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXG5mdW5jdGlvbiBiblNpZ051bSgpIHtcbiAgaWYgKHRoaXMucyA8IDApIHJldHVybiAtMVxuICBlbHNlIGlmICh0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpc1swXSA8PSAwKSkgcmV0dXJuIDBcbiAgZWxzZSByZXR1cm4gMVxufVxuXG4vLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG4gIGlmIChiID09IG51bGwpIGIgPSAxMFxuICBpZiAodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNikgcmV0dXJuIFwiMFwiXG4gIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpXG4gIHZhciBhID0gTWF0aC5wb3coYiwgY3MpXG4gIHZhciBkID0gbmJ2KGEpLFxuICAgIHkgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHogPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHIgPSBcIlwiXG4gIHRoaXMuZGl2UmVtVG8oZCwgeSwgeilcbiAgd2hpbGUgKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgciA9IChhICsgei5pbnRWYWx1ZSgpKVxuICAgICAgLnRvU3RyaW5nKGIpXG4gICAgICAuc3Vic3RyKDEpICsgclxuICAgIHkuZGl2UmVtVG8oZCwgeSwgeilcbiAgfVxuICByZXR1cm4gei5pbnRWYWx1ZSgpXG4gICAgLnRvU3RyaW5nKGIpICsgclxufVxuXG4vLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocywgYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5mcm9tSW50KDApXG4gIGlmIChiID09IG51bGwpIGIgPSAxMFxuICB2YXIgY3MgPSBzZWxmLmNodW5rU2l6ZShiKVxuICB2YXIgZCA9IE1hdGgucG93KGIsIGNzKSxcbiAgICBtaSA9IGZhbHNlLFxuICAgIGogPSAwLFxuICAgIHcgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB4ID0gaW50QXQocywgaSlcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiBzZWxmLnNpZ251bSgpID09IDApIG1pID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdyA9IGIgKiB3ICsgeFxuICAgIGlmICgrK2ogPj0gY3MpIHtcbiAgICAgIHNlbGYuZE11bHRpcGx5KGQpXG4gICAgICBzZWxmLmRBZGRPZmZzZXQodywgMClcbiAgICAgIGogPSAwXG4gICAgICB3ID0gMFxuICAgIH1cbiAgfVxuICBpZiAoaiA+IDApIHtcbiAgICBzZWxmLmRNdWx0aXBseShNYXRoLnBvdyhiLCBqKSlcbiAgICBzZWxmLmRBZGRPZmZzZXQodywgMClcbiAgfVxuICBpZiAobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLCBzZWxmKVxufVxuXG4vLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbmZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSwgYiwgYykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsaW50LFJORylcbiAgICBpZiAoYSA8IDIpIHNlbGYuZnJvbUludCgxKVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5mcm9tTnVtYmVyKGEsIGMpXG4gICAgICBpZiAoIXNlbGYudGVzdEJpdChhIC0gMSkpIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgc2VsZi5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgb3Bfb3IsIHNlbGYpXG4gICAgICBpZiAoc2VsZi5pc0V2ZW4oKSkgc2VsZi5kQWRkT2Zmc2V0KDEsIDApOyAvLyBmb3JjZSBvZGRcbiAgICAgIHdoaWxlICghc2VsZi5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgc2VsZi5kQWRkT2Zmc2V0KDIsIDApXG4gICAgICAgIGlmIChzZWxmLmJpdExlbmd0aCgpID4gYSkgc2VsZi5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBzZWxmKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuICAgIHZhciB4ID0gbmV3IEFycmF5KCksXG4gICAgICB0ID0gYSAmIDdcbiAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMVxuICAgIGIubmV4dEJ5dGVzKHgpXG4gICAgaWYgKHQgPiAwKSB4WzBdICY9ICgoMSA8PCB0KSAtIDEpXG4gICAgZWxzZSB4WzBdID0gMFxuICAgIHNlbGYuZnJvbVN0cmluZyh4LCAyNTYpXG4gIH1cbn1cblxuLy8gKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpID0gc2VsZi50LFxuICAgIHIgPSBuZXcgQXJyYXkoKVxuICByWzBdID0gc2VsZi5zXG4gIHZhciBwID0gc2VsZi5EQiAtIChpICogc2VsZi5EQikgJSA4LFxuICAgIGQsIGsgPSAwXG4gIGlmIChpLS0gPiAwKSB7XG4gICAgaWYgKHAgPCBzZWxmLkRCICYmIChkID0gc2VsZltpXSA+PiBwKSAhPSAoc2VsZi5zICYgc2VsZi5ETSkgPj4gcClcbiAgICAgIHJbaysrXSA9IGQgfCAoc2VsZi5zIDw8IChzZWxmLkRCIC0gcCkpXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKHAgPCA4KSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoOCAtIHApXG4gICAgICAgIGQgfD0gc2VsZlstLWldID4+IChwICs9IHNlbGYuREIgLSA4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IChzZWxmW2ldID4+IChwIC09IDgpKSAmIDB4ZmZcbiAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgIHAgKz0gc2VsZi5EQlxuICAgICAgICAgIC0taVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGQgJiAweDgwKSAhPSAwKSBkIHw9IC0yNTZcbiAgICAgIGlmIChrID09PSAwICYmIChzZWxmLnMgJiAweDgwKSAhPSAoZCAmIDB4ODApKSsra1xuICAgICAgaWYgKGsgPiAwIHx8IGQgIT0gc2VsZi5zKSByW2srK10gPSBkXG4gICAgfVxuICB9XG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHtcbiAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA9PSAwKVxufVxuXG5mdW5jdGlvbiBibk1pbihhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPCAwKSA/IHRoaXMgOiBhXG59XG5cbmZ1bmN0aW9uIGJuTWF4KGEpIHtcbiAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA+IDApID8gdGhpcyA6IGFcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgb3AgYSAoYml0d2lzZSlcbmZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLCBvcCwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgcltpXSA9IG9wKHNlbGZbaV0sIGFbaV0pXG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBmID0gYS5zICYgc2VsZi5ETVxuICAgIGZvciAoaSA9IG07IGkgPCBzZWxmLnQ7ICsraSkgcltpXSA9IG9wKHNlbGZbaV0sIGYpXG4gICAgci50ID0gc2VsZi50XG4gIH0gZWxzZSB7XG4gICAgZiA9IHNlbGYucyAmIHNlbGYuRE1cbiAgICBmb3IgKGkgPSBtOyBpIDwgYS50OyArK2kpIHJbaV0gPSBvcChmLCBhW2ldKVxuICAgIHIudCA9IGEudFxuICB9XG4gIHIucyA9IG9wKHNlbGYucywgYS5zKVxuICByLmNsYW1wKClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIGFcbmZ1bmN0aW9uIG9wX2FuZCh4LCB5KSB7XG4gIHJldHVybiB4ICYgeVxufVxuXG5mdW5jdGlvbiBibkFuZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmQsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgfCBhXG5mdW5jdGlvbiBvcF9vcih4LCB5KSB7XG4gIHJldHVybiB4IHwgeVxufVxuXG5mdW5jdGlvbiBibk9yKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX29yLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgsIHkpIHtcbiAgcmV0dXJuIHggXiB5XG59XG5cbmZ1bmN0aW9uIGJuWG9yKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX3hvciwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIH5hXG5mdW5jdGlvbiBvcF9hbmRub3QoeCwgeSkge1xuICByZXR1cm4geCAmIH55XG59XG5cbmZ1bmN0aW9uIGJuQW5kTm90KGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZG5vdCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgfnRoaXNcbmZ1bmN0aW9uIGJuTm90KCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgcltpXSA9IHRoaXMuRE0gJiB+dGhpc1tpXVxuICByLnQgPSB0aGlzLnRcbiAgci5zID0gfnRoaXMuc1xuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGlmIChuIDwgMCkgdGhpcy5yU2hpZnRUbygtbiwgcilcbiAgZWxzZSB0aGlzLmxTaGlmdFRvKG4sIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgPj4gblxuZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGlmIChuIDwgMCkgdGhpcy5sU2hpZnRUbygtbiwgcilcbiAgZWxzZSB0aGlzLnJTaGlmdFRvKG4sIHIpXG4gIHJldHVybiByXG59XG5cbi8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLTFcbiAgdmFyIHIgPSAwXG4gIGlmICgoeCAmIDB4ZmZmZikgPT0gMCkge1xuICAgIHggPj49IDE2XG4gICAgciArPSAxNlxuICB9XG4gIGlmICgoeCAmIDB4ZmYpID09IDApIHtcbiAgICB4ID4+PSA4XG4gICAgciArPSA4XG4gIH1cbiAgaWYgKCh4ICYgMHhmKSA9PSAwKSB7XG4gICAgeCA+Pj0gNFxuICAgIHIgKz0gNFxuICB9XG4gIGlmICgoeCAmIDMpID09IDApIHtcbiAgICB4ID4+PSAyXG4gICAgciArPSAyXG4gIH1cbiAgaWYgKCh4ICYgMSkgPT0gMCkrK3JcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiAgICBpZiAodGhpc1tpXSAhPSAwKSByZXR1cm4gaSAqIHRoaXMuREIgKyBsYml0KHRoaXNbaV0pXG4gIGlmICh0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50ICogdGhpcy5EQlxuICByZXR1cm4gLTFcbn1cblxuLy8gcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG4gIHZhciByID0gMFxuICB3aGlsZSAoeCAhPSAwKSB7XG4gICAgeCAmPSB4IC0gMVxuICAgICsrclxuICB9XG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiBudW1iZXIgb2Ygc2V0IGJpdHNcbmZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG4gIHZhciByID0gMCxcbiAgICB4ID0gdGhpcy5zICYgdGhpcy5ETVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpc1tpXSBeIHgpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRydWUgaWZmIG50aCBiaXQgaXMgc2V0XG5mdW5jdGlvbiBiblRlc3RCaXQobikge1xuICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpXG4gIGlmIChqID49IHRoaXMudCkgcmV0dXJuICh0aGlzLnMgIT0gMClcbiAgcmV0dXJuICgodGhpc1tqXSAmICgxIDw8IChuICUgdGhpcy5EQikpKSAhPSAwKVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sIG9wKSB7XG4gIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pXG4gIHRoaXMuYml0d2lzZVRvKHIsIG9wLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG5mdW5jdGlvbiBiblNldEJpdChuKSB7XG4gIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF9vcilcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfYW5kbm90KVxufVxuXG4vLyAocHVibGljKSB0aGlzIF4gKDE8PG4pXG5mdW5jdGlvbiBibkZsaXBCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfeG9yKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbmZ1bmN0aW9uIGJucEFkZFRvKGEsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGkgPSAwLFxuICAgIGMgPSAwLFxuICAgIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgYyArPSBzZWxmW2ldICsgYVtpXVxuICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgYyA+Pj0gc2VsZi5EQlxuICB9XG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBjICs9IGEuc1xuICAgIHdoaWxlIChpIDwgc2VsZi50KSB7XG4gICAgICBjICs9IHNlbGZbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgKz0gc2VsZi5zXG4gIH0gZWxzZSB7XG4gICAgYyArPSBzZWxmLnNcbiAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgYyArPSBhW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IGEuc1xuICB9XG4gIHIucyA9IChjIDwgMCkgPyAtMSA6IDBcbiAgaWYgKGMgPiAwKSByW2krK10gPSBjXG4gIGVsc2UgaWYgKGMgPCAtMSkgcltpKytdID0gc2VsZi5EViArIGNcbiAgci50ID0gaVxuICByLmNsYW1wKClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYWRkVG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAtIGFcbmZ1bmN0aW9uIGJuU3VidHJhY3QoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5zdWJUbyhhLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzICogYVxuZnVuY3Rpb24gYm5NdWx0aXBseShhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLm11bHRpcGx5VG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpc14yXG5mdW5jdGlvbiBiblNxdWFyZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuc3F1YXJlVG8ocilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuZGl2UmVtVG8oYSwgciwgbnVsbClcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG4gIHZhciBxID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIHEsIHIpXG4gIHJldHVybiBuZXcgQXJyYXkocSwgcilcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyAqPSBuLCB0aGlzID49IDAsIDEgPCBuIDwgRFZcbmZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG4gIHRoaXNbdGhpcy50XSA9IHRoaXMuYW0oMCwgbiAtIDEsIHRoaXMsIDAsIDAsIHRoaXMudClcbiAgKyt0aGlzLnRcbiAgdGhpcy5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbmZ1bmN0aW9uIGJucERBZGRPZmZzZXQobiwgdykge1xuICBpZiAobiA9PSAwKSByZXR1cm5cbiAgd2hpbGUgKHRoaXMudCA8PSB3KSB0aGlzW3RoaXMudCsrXSA9IDBcbiAgdGhpc1t3XSArPSBuXG4gIHdoaWxlICh0aGlzW3ddID49IHRoaXMuRFYpIHtcbiAgICB0aGlzW3ddIC09IHRoaXMuRFZcbiAgICBpZiAoKyt3ID49IHRoaXMudCkgdGhpc1t0aGlzLnQrK10gPSAwXG4gICAgKyt0aGlzW3ddXG4gIH1cbn1cblxuLy8gQSBcIm51bGxcIiByZWR1Y2VyXG5mdW5jdGlvbiBOdWxsRXhwKCkge31cblxuZnVuY3Rpb24gbk5vcCh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIG5NdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxufVxuXG5mdW5jdGlvbiBuU3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG59XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wXG5OdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBuTm9wXG5OdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUb1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG9cblxuLy8gKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7XG4gIHJldHVybiB0aGlzLmV4cChlLCBuZXcgTnVsbEV4cCgpKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSwgbiwgcikge1xuICB2YXIgaSA9IE1hdGgubWluKHRoaXMudCArIGEudCwgbilcbiAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICByLnQgPSBpXG4gIHdoaWxlIChpID4gMCkgclstLWldID0gMFxuICB2YXIgalxuICBmb3IgKGogPSByLnQgLSB0aGlzLnQ7IGkgPCBqOyArK2kpIHJbaSArIHRoaXMudF0gPSB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIHRoaXMudClcbiAgZm9yIChqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCBuIC0gaSlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlVcHBlclRvKGEsIG4sIHIpIHtcbiAgLS1uXG4gIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gblxuICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gTWF0aC5tYXgobiAtIHRoaXMudCwgMCk7IGkgPCBhLnQ7ICsraSlcbiAgICByW3RoaXMudCArIGkgLSBuXSA9IHRoaXMuYW0obiAtIGksIGFbaV0sIHIsIDAsIDAsIHRoaXMudCArIGkgLSBuKVxuICByLmNsYW1wKClcbiAgci5kclNoaWZ0VG8oMSwgcilcbn1cblxuLy8gQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxuZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gIC8vIHNldHVwIEJhcnJldHRcbiAgdGhpcy5yMiA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5xMyA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIgKiBtLnQsIHRoaXMucjIpXG4gIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKVxuICB0aGlzLm0gPSBtXG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbiAgaWYgKHgucyA8IDAgfHwgeC50ID4gMiAqIHRoaXMubS50KSByZXR1cm4geC5tb2QodGhpcy5tKVxuICBlbHNlIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkgcmV0dXJuIHhcbiAgZWxzZSB7XG4gICAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgeC5jb3B5VG8ocilcbiAgICB0aGlzLnJlZHVjZShyKVxuICAgIHJldHVybiByXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7XG4gIHJldHVybiB4XG59XG5cbi8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHguZHJTaGlmdFRvKHNlbGYubS50IC0gMSwgc2VsZi5yMilcbiAgaWYgKHgudCA+IHNlbGYubS50ICsgMSkge1xuICAgIHgudCA9IHNlbGYubS50ICsgMVxuICAgIHguY2xhbXAoKVxuICB9XG4gIHNlbGYubXUubXVsdGlwbHlVcHBlclRvKHNlbGYucjIsIHNlbGYubS50ICsgMSwgc2VsZi5xMylcbiAgc2VsZi5tLm11bHRpcGx5TG93ZXJUbyhzZWxmLnEzLCBzZWxmLm0udCArIDEsIHNlbGYucjIpXG4gIHdoaWxlICh4LmNvbXBhcmVUbyhzZWxmLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLCBzZWxmLm0udCArIDEpXG4gIHguc3ViVG8oc2VsZi5yMiwgeClcbiAgd2hpbGUgKHguY29tcGFyZVRvKHNlbGYubSkgPj0gMCkgeC5zdWJUbyhzZWxmLm0sIHgpXG59XG5cbi8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuZnVuY3Rpb24gYmFycmV0dFNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG4vLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbkJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydFxuQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydFxuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZVxuQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG9cbkJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvXG5cbi8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbmZ1bmN0aW9uIGJuTW9kUG93KGUsIG0pIHtcbiAgdmFyIGkgPSBlLmJpdExlbmd0aCgpLFxuICAgIGssIHIgPSBuYnYoMSksXG4gICAgelxuICBpZiAoaSA8PSAwKSByZXR1cm4gclxuICBlbHNlIGlmIChpIDwgMTgpIGsgPSAxXG4gIGVsc2UgaWYgKGkgPCA0OCkgayA9IDNcbiAgZWxzZSBpZiAoaSA8IDE0NCkgayA9IDRcbiAgZWxzZSBpZiAoaSA8IDc2OCkgayA9IDVcbiAgZWxzZSBrID0gNlxuICBpZiAoaSA8IDgpXG4gICAgeiA9IG5ldyBDbGFzc2ljKG0pXG4gIGVsc2UgaWYgKG0uaXNFdmVuKCkpXG4gICAgeiA9IG5ldyBCYXJyZXR0KG0pXG4gIGVsc2VcbiAgICB6ID0gbmV3IE1vbnRnb21lcnkobSlcblxuICAvLyBwcmVjb21wdXRhdGlvblxuICB2YXIgZyA9IG5ldyBBcnJheSgpLFxuICAgIG4gPSAzLFxuICAgIGsxID0gayAtIDEsXG4gICAga20gPSAoMSA8PCBrKSAtIDFcbiAgZ1sxXSA9IHouY29udmVydCh0aGlzKVxuICBpZiAoayA+IDEpIHtcbiAgICB2YXIgZzIgPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgei5zcXJUbyhnWzFdLCBnMilcbiAgICB3aGlsZSAobiA8PSBrbSkge1xuICAgICAgZ1tuXSA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgICAgIHoubXVsVG8oZzIsIGdbbiAtIDJdLCBnW25dKVxuICAgICAgbiArPSAyXG4gICAgfVxuICB9XG5cbiAgdmFyIGogPSBlLnQgLSAxLFxuICAgIHcsIGlzMSA9IHRydWUsXG4gICAgcjIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHRcbiAgaSA9IG5iaXRzKGVbal0pIC0gMVxuICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgaWYgKGkgPj0gazEpIHcgPSAoZVtqXSA+PiAoaSAtIGsxKSkgJiBrbVxuICAgIGVsc2Uge1xuICAgICAgdyA9IChlW2pdICYgKCgxIDw8IChpICsgMSkpIC0gMSkpIDw8IChrMSAtIGkpXG4gICAgICBpZiAoaiA+IDApIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpXG4gICAgfVxuXG4gICAgbiA9IGtcbiAgICB3aGlsZSAoKHcgJiAxKSA9PSAwKSB7XG4gICAgICB3ID4+PSAxXG4gICAgICAtLW5cbiAgICB9XG4gICAgaWYgKChpIC09IG4pIDwgMCkge1xuICAgICAgaSArPSB0aGlzLkRCXG4gICAgICAtLWpcbiAgICB9XG4gICAgaWYgKGlzMSkgeyAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICAgICBnW3ddLmNvcHlUbyhyKVxuICAgICAgaXMxID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgIHouc3FyVG8ociwgcjIpXG4gICAgICAgIHouc3FyVG8ocjIsIHIpXG4gICAgICAgIG4gLT0gMlxuICAgICAgfVxuICAgICAgaWYgKG4gPiAwKSB6LnNxclRvKHIsIHIyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHQgPSByXG4gICAgICAgIHIgPSByMlxuICAgICAgICByMiA9IHRcbiAgICAgIH1cbiAgICAgIHoubXVsVG8ocjIsIGdbd10sIHIpXG4gICAgfVxuXG4gICAgd2hpbGUgKGogPj0gMCAmJiAoZVtqXSAmICgxIDw8IGkpKSA9PSAwKSB7XG4gICAgICB6LnNxclRvKHIsIHIyKVxuICAgICAgdCA9IHJcbiAgICAgIHIgPSByMlxuICAgICAgcjIgPSB0XG4gICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICBpID0gdGhpcy5EQiAtIDFcbiAgICAgICAgLS1qXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB6LnJldmVydChyKVxufVxuXG4vLyAocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xuICB2YXIgeCA9ICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzLmNsb25lKClcbiAgdmFyIHkgPSAoYS5zIDwgMCkgPyBhLm5lZ2F0ZSgpIDogYS5jbG9uZSgpXG4gIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICB2YXIgdCA9IHhcbiAgICB4ID0geVxuICAgIHkgPSB0XG4gIH1cbiAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpLFxuICAgIGcgPSB5LmdldExvd2VzdFNldEJpdCgpXG4gIGlmIChnIDwgMCkgcmV0dXJuIHhcbiAgaWYgKGkgPCBnKSBnID0gaVxuICBpZiAoZyA+IDApIHtcbiAgICB4LnJTaGlmdFRvKGcsIHgpXG4gICAgeS5yU2hpZnRUbyhnLCB5KVxuICB9XG4gIHdoaWxlICh4LnNpZ251bSgpID4gMCkge1xuICAgIGlmICgoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLCB4KVxuICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeS5yU2hpZnRUbyhpLCB5KVxuICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICB4LnN1YlRvKHksIHgpXG4gICAgICB4LnJTaGlmdFRvKDEsIHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHkuc3ViVG8oeCwgeSlcbiAgICAgIHkuclNoaWZ0VG8oMSwgeSlcbiAgICB9XG4gIH1cbiAgaWYgKGcgPiAwKSB5LmxTaGlmdFRvKGcsIHkpXG4gIHJldHVybiB5XG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbiAgaWYgKG4gPD0gMCkgcmV0dXJuIDBcbiAgdmFyIGQgPSB0aGlzLkRWICUgbixcbiAgICByID0gKHRoaXMucyA8IDApID8gbiAtIDEgOiAwXG4gIGlmICh0aGlzLnQgPiAwKVxuICAgIGlmIChkID09IDApIHIgPSB0aGlzWzBdICUgblxuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkgciA9IChkICogciArIHRoaXNbaV0pICUgblxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xuICB2YXIgYWMgPSBtLmlzRXZlbigpXG4gIGlmICh0aGlzLnNpZ251bSgpID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKVxuICBpZiAoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVST1xuICB2YXIgdSA9IG0uY2xvbmUoKSxcbiAgICB2ID0gdGhpcy5jbG9uZSgpXG4gIHZhciBhID0gbmJ2KDEpLFxuICAgIGIgPSBuYnYoMCksXG4gICAgYyA9IG5idigwKSxcbiAgICBkID0gbmJ2KDEpXG4gIHdoaWxlICh1LnNpZ251bSgpICE9IDApIHtcbiAgICB3aGlsZSAodS5pc0V2ZW4oKSkge1xuICAgICAgdS5yU2hpZnRUbygxLCB1KVxuICAgICAgaWYgKGFjKSB7XG4gICAgICAgIGlmICghYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkge1xuICAgICAgICAgIGEuYWRkVG8odGhpcywgYSlcbiAgICAgICAgICBiLnN1YlRvKG0sIGIpXG4gICAgICAgIH1cbiAgICAgICAgYS5yU2hpZnRUbygxLCBhKVxuICAgICAgfSBlbHNlIGlmICghYi5pc0V2ZW4oKSkgYi5zdWJUbyhtLCBiKVxuICAgICAgYi5yU2hpZnRUbygxLCBiKVxuICAgIH1cbiAgICB3aGlsZSAodi5pc0V2ZW4oKSkge1xuICAgICAgdi5yU2hpZnRUbygxLCB2KVxuICAgICAgaWYgKGFjKSB7XG4gICAgICAgIGlmICghYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkge1xuICAgICAgICAgIGMuYWRkVG8odGhpcywgYylcbiAgICAgICAgICBkLnN1YlRvKG0sIGQpXG4gICAgICAgIH1cbiAgICAgICAgYy5yU2hpZnRUbygxLCBjKVxuICAgICAgfSBlbHNlIGlmICghZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLCBkKVxuICAgICAgZC5yU2hpZnRUbygxLCBkKVxuICAgIH1cbiAgICBpZiAodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgICAgdS5zdWJUbyh2LCB1KVxuICAgICAgaWYgKGFjKSBhLnN1YlRvKGMsIGEpXG4gICAgICBiLnN1YlRvKGQsIGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHYuc3ViVG8odSwgdilcbiAgICAgIGlmIChhYykgYy5zdWJUbyhhLCBjKVxuICAgICAgZC5zdWJUbyhiLCBkKVxuICAgIH1cbiAgfVxuICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cbiAgd2hpbGUgKGQuY29tcGFyZVRvKG0pID49IDApIGQuc3ViVG8obSwgZClcbiAgd2hpbGUgKGQuc2lnbnVtKCkgPCAwKSBkLmFkZFRvKG0sIGQpXG4gIHJldHVybiBkXG59XG5cbnZhciBsb3dwcmltZXMgPSBbXG4gIDIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLFxuICA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLFxuICAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLFxuICAyMzksIDI0MSwgMjUxLCAyNTcsIDI2MywgMjY5LCAyNzEsIDI3NywgMjgxLCAyODMsIDI5MywgMzA3LCAzMTEsIDMxMywgMzE3LFxuICAzMzEsIDMzNywgMzQ3LCAzNDksIDM1MywgMzU5LCAzNjcsIDM3MywgMzc5LCAzODMsIDM4OSwgMzk3LCA0MDEsIDQwOSwgNDE5LFxuICA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLFxuICA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LCA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LFxuICA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLFxuICA3MDksIDcxOSwgNzI3LCA3MzMsIDczOSwgNzQzLCA3NTEsIDc1NywgNzYxLCA3NjksIDc3MywgNzg3LCA3OTcsIDgwOSwgODExLFxuICA4MjEsIDgyMywgODI3LCA4MjksIDgzOSwgODUzLCA4NTcsIDg1OSwgODYzLCA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLFxuICA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3XG5dXG5cbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV1cblxuLy8gKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG4gIHZhciBpLCB4ID0gdGhpcy5hYnMoKVxuICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIGlmICh4WzBdID09IGxvd3ByaW1lc1tpXSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoeC5pc0V2ZW4oKSkgcmV0dXJuIGZhbHNlXG4gIGkgPSAxXG4gIHdoaWxlIChpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgIHZhciBtID0gbG93cHJpbWVzW2ldLFxuICAgICAgaiA9IGkgKyAxXG4gICAgd2hpbGUgKGogPCBsb3dwcmltZXMubGVuZ3RoICYmIG0gPCBscGxpbSkgbSAqPSBsb3dwcmltZXNbaisrXVxuICAgIG0gPSB4Lm1vZEludChtKVxuICAgIHdoaWxlIChpIDwgaikgaWYgKG0gJSBsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4geC5taWxsZXJSYWJpbih0KVxufVxuXG4vLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xuICB2YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKVxuICB2YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpXG4gIGlmIChrIDw9IDApIHJldHVybiBmYWxzZVxuICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoaylcbiAgdCA9ICh0ICsgMSkgPj4gMVxuICBpZiAodCA+IGxvd3ByaW1lcy5sZW5ndGgpIHQgPSBsb3dwcmltZXMubGVuZ3RoXG4gIHZhciBhID0gbmV3IEJpZ0ludGVnZXIobnVsbClcbiAgdmFyIGosIGJhc2VzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBqID0gbG93cHJpbWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxvd3ByaW1lcy5sZW5ndGgpXVxuICAgICAgaWYgKGJhc2VzLmluZGV4T2YoaikgPT0gLTEpIGJyZWFrXG4gICAgfVxuICAgIGJhc2VzLnB1c2goailcbiAgICBhLmZyb21JbnQoailcbiAgICB2YXIgeSA9IGEubW9kUG93KHIsIHRoaXMpXG4gICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICB2YXIgaiA9IDFcbiAgICAgIHdoaWxlIChqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgIHkgPSB5Lm1vZFBvd0ludCgyLCB0aGlzKVxuICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHkuY29tcGFyZVRvKG4xKSAhPSAwKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gcHJvdGVjdGVkXG5wcm90by5jaHVua1NpemUgPSBibnBDaHVua1NpemVcbnByb3RvLnRvUmFkaXggPSBibnBUb1JhZGl4XG5wcm90by5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXhcbnByb3RvLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyXG5wcm90by5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG9cbnByb3RvLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdFxucHJvdG8uYWRkVG8gPSBibnBBZGRUb1xucHJvdG8uZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5XG5wcm90by5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldFxucHJvdG8ubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvXG5wcm90by5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG9cbnByb3RvLm1vZEludCA9IGJucE1vZEludFxucHJvdG8ubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpblxuXG4vLyBwdWJsaWNcbnByb3RvLmNsb25lID0gYm5DbG9uZVxucHJvdG8uaW50VmFsdWUgPSBibkludFZhbHVlXG5wcm90by5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZVxucHJvdG8uc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZVxucHJvdG8uc2lnbnVtID0gYm5TaWdOdW1cbnByb3RvLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheVxucHJvdG8uZXF1YWxzID0gYm5FcXVhbHNcbnByb3RvLm1pbiA9IGJuTWluXG5wcm90by5tYXggPSBibk1heFxucHJvdG8uYW5kID0gYm5BbmRcbnByb3RvLm9yID0gYm5PclxucHJvdG8ueG9yID0gYm5Yb3JcbnByb3RvLmFuZE5vdCA9IGJuQW5kTm90XG5wcm90by5ub3QgPSBibk5vdFxucHJvdG8uc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnRcbnByb3RvLnNoaWZ0UmlnaHQgPSBiblNoaWZ0UmlnaHRcbnByb3RvLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0XG5wcm90by5iaXRDb3VudCA9IGJuQml0Q291bnRcbnByb3RvLnRlc3RCaXQgPSBiblRlc3RCaXRcbnByb3RvLnNldEJpdCA9IGJuU2V0Qml0XG5wcm90by5jbGVhckJpdCA9IGJuQ2xlYXJCaXRcbnByb3RvLmZsaXBCaXQgPSBibkZsaXBCaXRcbnByb3RvLmFkZCA9IGJuQWRkXG5wcm90by5zdWJ0cmFjdCA9IGJuU3VidHJhY3RcbnByb3RvLm11bHRpcGx5ID0gYm5NdWx0aXBseVxucHJvdG8uZGl2aWRlID0gYm5EaXZpZGVcbnByb3RvLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyXG5wcm90by5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlclxucHJvdG8ubW9kUG93ID0gYm5Nb2RQb3dcbnByb3RvLm1vZEludmVyc2UgPSBibk1vZEludmVyc2VcbnByb3RvLnBvdyA9IGJuUG93XG5wcm90by5nY2QgPSBibkdDRFxucHJvdG8uaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWVcblxuLy8gSlNCTi1zcGVjaWZpYyBleHRlbnNpb25cbnByb3RvLnNxdWFyZSA9IGJuU3F1YXJlXG5cbi8vIGNvbnN0YW50c1xuQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApXG5CaWdJbnRlZ2VyLk9ORSA9IG5idigxKVxuQmlnSW50ZWdlci52YWx1ZU9mID0gbmJ2XG5cbm1vZHVsZS5leHBvcnRzID0gQmlnSW50ZWdlclxuIiwiLy8gRklYTUU6IEtpbmQgb2YgYSB3ZWlyZCB3YXkgdG8gdGhyb3cgZXhjZXB0aW9ucywgY29uc2lkZXIgcmVtb3ZpbmdcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCcuL2JpZ2knKVxuXG4vKipcbiAqIFR1cm5zIGEgYnl0ZSBhcnJheSBpbnRvIGEgYmlnIGludGVnZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGludGVycHJldCBhIGJ5dGUgYXJyYXkgYXMgYSBiaWcgaW50ZWdlciBpbiBiaWdcbiAqIGVuZGlhbiBub3RhdGlvbi5cbiAqL1xuQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQgPSBmdW5jdGlvbihieXRlQXJyYXkpIHtcbiAgLy8gQmlnSW50ZWdlciBleHBlY3RzIGEgREVSIGludGVnZXIgY29uZm9ybWFudCBieXRlIGFycmF5XG4gIGlmIChieXRlQXJyYXlbMF0gJiAweDgwKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXS5jb25jYXQoYnl0ZUFycmF5KSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihieXRlQXJyYXkpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZyBpbnRlZ2VyLlxuICpcbiAqIFRoaXMgcmV0dXJucyB0aGUgYWJzb2x1dGUgb2YgdGhlIGNvbnRhaW5lZCB2YWx1ZSBpbiBiaWcgZW5kaWFuXG4gKiBmb3JtLiBBIHZhbHVlIG9mIHplcm8gcmVzdWx0cyBpbiBhbiBlbXB0eSBhcnJheS5cbiAqL1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlVbnNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnl0ZUFycmF5ID0gdGhpcy50b0J5dGVBcnJheSgpXG4gIHJldHVybiBieXRlQXJyYXlbMF0gPT09IDAgPyBieXRlQXJyYXkuc2xpY2UoMSkgOiBieXRlQXJyYXlcbn1cblxuQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVBcnJheSkge1xuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnl0ZUFycmF5KVxufVxuXG4vKlxuICogQ29udmVydHMgQmlnSW50ZWdlciB0byBhIERFUiBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIFRoZSBmb3JtYXQgZm9yIHRoaXMgdmFsdWUgdXNlcyB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgYXMgYSBzaWduXG4gKiBiaXQuICBJZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZSBpbnRlZ2VyIGlzXG4gKiBwb3NpdGl2ZSwgYSAweDAwIGlzIHByZXBlbmRlZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIDAgPT4gICAgIDB4MDBcbiAqICAgICAgMSA9PiAgICAgMHgwMVxuICogICAgIC0xID0+ICAgICAweGZmXG4gKiAgICAxMjcgPT4gICAgIDB4N2ZcbiAqICAgLTEyNyA9PiAgICAgMHg4MVxuICogICAgMTI4ID0+ICAgMHgwMDgwXG4gKiAgIC0xMjggPT4gICAgIDB4ODBcbiAqICAgIDI1NSA9PiAgIDB4MDBmZlxuICogICAtMjU1ID0+ICAgMHhmZjAxXG4gKiAgMTYzMDAgPT4gICAweDNmYWNcbiAqIC0xNjMwMCA9PiAgIDB4YzA1NFxuICogIDYyMzAwID0+IDB4MDBmMzVjXG4gKiAtNjIzMDAgPT4gMHhmZjBjYTRcbiovXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0RFUkludGVnZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheVxuXG5CaWdJbnRlZ2VyLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gQmlnSW50ZWdlciBleHBlY3RzIGEgREVSIGludGVnZXIgY29uZm9ybWFudCBieXRlIGFycmF5XG4gIGlmIChidWZmZXJbMF0gJiAweDgwKSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ1ZmZlcilcblxuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMF0uY29uY2F0KGJ5dGVBcnJheSkpXG4gIH1cblxuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnVmZmVyKVxufVxuXG5CaWdJbnRlZ2VyLmZyb21IZXggPSBmdW5jdGlvbihoZXgpIHtcbiAgaWYgKGhleCA9PT0gJycpIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cblxuICBhc3NlcnQuZXF1YWwoaGV4LCBoZXgubWF0Y2goL15bQS1GYS1mMC05XSsvKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gIGFzc2VydC5lcXVhbChoZXgubGVuZ3RoICUgMiwgMCwgJ0luY29tcGxldGUgaGV4JylcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGhleCwgMTYpXG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICB2YXIgYnl0ZUFycmF5ID0gdGhpcy50b0J5dGVBcnJheVVuc2lnbmVkKClcbiAgdmFyIHplcm9zID0gW11cblxuICB2YXIgcGFkZGluZyA9IHNpemUgLSBieXRlQXJyYXkubGVuZ3RoXG4gIHdoaWxlICh6ZXJvcy5sZW5ndGggPCBwYWRkaW5nKSB6ZXJvcy5wdXNoKDApXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIoemVyb3MuY29uY2F0KGJ5dGVBcnJheSkpXG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oc2l6ZSkge1xuICByZXR1cm4gdGhpcy50b0J1ZmZlcihzaXplKS50b1N0cmluZygnaGV4Jylcbn1cbiIsInZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnLi9iaWdpJylcblxuLy9hZGRvbnNcbnJlcXVpcmUoJy4vY29udmVydCcpXG5cbm1vZHVsZS5leHBvcnRzID0gQmlnSW50ZWdlciIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJiaWdpQDEuNC4yXCIsXG4gICAgICBcIi9ob21lL3NpZ3ZlL0Rldi9CaXRzaGFyZXMvYml0c2hhcmVzanNcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcImJpZ2lAMS40LjJcIixcbiAgXCJfaWRcIjogXCJiaWdpQDEuNC4yXCIsXG4gIFwiX2luQnVuZGxlXCI6IGZhbHNlLFxuICBcIl9pbnRlZ3JpdHlcIjogXCJzaGExLW5HWmFsZmlMaXdqOEJjL1hNZlZoaFoxeVdDVT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvYmlnaVwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiLFxuICAgIFwicmVnaXN0cnlcIjogdHJ1ZSxcbiAgICBcInJhd1wiOiBcImJpZ2lAMS40LjJcIixcbiAgICBcIm5hbWVcIjogXCJiaWdpXCIsXG4gICAgXCJlc2NhcGVkTmFtZVwiOiBcImJpZ2lcIixcbiAgICBcInJhd1NwZWNcIjogXCIxLjQuMlwiLFxuICAgIFwic2F2ZVNwZWNcIjogbnVsbCxcbiAgICBcImZldGNoU3BlY1wiOiBcIjEuNC4yXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCIsXG4gICAgXCIvZWN1cnZlXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9iaWdpLy0vYmlnaS0xLjQuMi50Z3pcIixcbiAgXCJfc3BlY1wiOiBcIjEuNC4yXCIsXG4gIFwiX3doZXJlXCI6IFwiL2hvbWUvc2lndmUvRGV2L0JpdHNoYXJlcy9iaXRzaGFyZXNqc1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQmlnIGludGVnZXJzLlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjb3ZlcmFsbHNcIjogXCJeMi4xMS4yXCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcIl4wLjMuNVwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuNS4xXCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjEuMFwiLFxuICAgIFwibW9jaGlmeVwiOiBcIl4yLjEuMFwiXG4gIH0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kjcmVhZG1lXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY3J5cHRvZ3JhcGh5XCIsXG4gICAgXCJtYXRoXCIsXG4gICAgXCJiaXRjb2luXCIsXG4gICAgXCJhcmJpdHJhcnlcIixcbiAgICBcInByZWNpc2lvblwiLFxuICAgIFwiYXJpdGhtZXRpY1wiLFxuICAgIFwiYmlnXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJpbnRcIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiYmlnaW50ZWdlclwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJiaWdudW1iZXJcIixcbiAgICBcImRlY2ltYWxcIixcbiAgICBcImZsb2F0XCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9saWIvaW5kZXguanNcIixcbiAgXCJuYW1lXCI6IFwiYmlnaVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaS5naXRcIixcbiAgICBcInR5cGVcIjogXCJnaXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnJvd3Nlci10ZXN0XCI6IFwibW9jaGlmeSAtLXdkIC1SIHNwZWNcIixcbiAgICBcImNvdmVyYWdlXCI6IFwiaXN0YW5idWwgY292ZXIgLi9ub2RlX21vZHVsZXMvLmJpbi9fbW9jaGEgLS0gLS1yZXBvcnRlciBsaXN0IHRlc3QvKi5qc1wiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwibnBtIHJ1bi1zY3JpcHQgY292ZXJhZ2UgJiYgbm9kZSAuL25vZGVfbW9kdWxlcy8uYmluL2NvdmVyYWxscyA8IGNvdmVyYWdlL2xjb3YuaW5mb1wiLFxuICAgIFwianNoaW50XCI6IFwianNoaW50IC0tY29uZmlnIGpzaGludC5qc29uIGxpYi8qLmpzIDsgdHJ1ZVwiLFxuICAgIFwidGVzdFwiOiBcIl9tb2NoYSAtLSB0ZXN0LyouanNcIixcbiAgICBcInVuaXRcIjogXCJtb2NoYVwiXG4gIH0sXG4gIFwidGVzdGxpbmdcIjoge1xuICAgIFwiZmlsZXNcIjogXCJ0ZXN0LyouanNcIixcbiAgICBcImhhcm5lc3NcIjogXCJtb2NoYVwiLFxuICAgIFwiYnJvd3NlcnNcIjogW1xuICAgICAgXCJpZS85Li5sYXRlc3RcIixcbiAgICAgIFwiZmlyZWZveC9sYXRlc3RcIixcbiAgICAgIFwiY2hyb21lL2xhdGVzdFwiLFxuICAgICAgXCJzYWZhcmkvNi4wLi5sYXRlc3RcIixcbiAgICAgIFwiaXBob25lLzYuMC4ubGF0ZXN0XCIsXG4gICAgICBcImFuZHJvaWQtYnJvd3Nlci80LjIuLmxhdGVzdFwiXG4gICAgXVxuICB9LFxuICBcInZlcnNpb25cIjogXCIxLjQuMlwiXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuTWFuYWdlciA9IGV4cG9ydHMuQ2hhaW5Db25maWcgPSBleHBvcnRzLkFwaXMgPSB1bmRlZmluZWQ7XG5cbnZhciBfQXBpSW5zdGFuY2VzID0gcmVxdWlyZShcIi4vc3JjL0FwaUluc3RhbmNlc1wiKTtcblxudmFyIF9BcGlJbnN0YW5jZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpSW5zdGFuY2VzKTtcblxudmFyIF9Db25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL3NyYy9Db25uZWN0aW9uTWFuYWdlclwiKTtcblxudmFyIF9Db25uZWN0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db25uZWN0aW9uTWFuYWdlcik7XG5cbnZhciBfQ2hhaW5Db25maWcgPSByZXF1aXJlKFwiLi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbnZhciBfQ2hhaW5Db25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2hhaW5Db25maWcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLkFwaXMgPSBfQXBpSW5zdGFuY2VzMi5kZWZhdWx0O1xuZXhwb3J0cy5DaGFpbkNvbmZpZyA9IF9DaGFpbkNvbmZpZzIuZGVmYXVsdDtcbmV4cG9ydHMuTWFuYWdlciA9IF9Db25uZWN0aW9uTWFuYWdlcjIuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9DaGFpbldlYlNvY2tldCA9IHJlcXVpcmUoXCIuL0NoYWluV2ViU29ja2V0XCIpO1xuXG52YXIgX0NoYWluV2ViU29ja2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoYWluV2ViU29ja2V0KTtcblxudmFyIF9HcmFwaGVuZUFwaSA9IHJlcXVpcmUoXCIuL0dyYXBoZW5lQXBpXCIpO1xuXG52YXIgX0dyYXBoZW5lQXBpMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyYXBoZW5lQXBpKTtcblxudmFyIF9DaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuL0NoYWluQ29uZmlnXCIpO1xuXG52YXIgX0NoYWluQ29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoYWluQ29uZmlnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLy8gdmFyIHsgTGlzdCB9ID0gcmVxdWlyZShcImltbXV0YWJsZVwiKTtcblxuXG5pZiAoZ2xvYmFsKSB7XG4gICAgZ2xvYmFsLmluc3QgPSBcIlwiO1xufSBlbHNlIHtcbiAgICB2YXIgX2luc3QgPSB2b2lkIDA7XG59O1xudmFyIGF1dG9SZWNvbm5lY3QgPSBmYWxzZTsgLy8gYnkgZGVmYXVsdCBkb24ndCB1c2UgcmVjb25uZWN0aW5nLXdlYnNvY2tldFxuLyoqXG4gICAgQ29uZmlndXJlOiBjb25maWd1cmUgYXMgZm9sbG93cyBgQXBpcy5pbnN0YW5jZShcIndzOi8vbG9jYWxob3N0OjgwOTBcIikuaW5pdF9wcm9taXNlYC4gIFRoaXMgcmV0dXJucyBhIHByb21pc2UsIG9uY2UgcmVzb2x2ZWQgdGhlIGNvbm5lY3Rpb24gaXMgcmVhZHkuXG5cbiAgICBJbXBvcnQ6IGltcG9ydCB7IEFwaXMgfSBmcm9tIFwiQGdyYXBoZW5lL2NoYWluXCJcblxuICAgIFNob3J0LWhhbmQ6IEFwaXMuZGIoXCJtZXRob2RcIiwgXCJwYXJtMVwiLCAyLCAzLCAuLi4pLiAgUmV0dXJucyBhIHByb21pc2Ugd2l0aCByZXN1bHRzLlxuXG4gICAgQWRkaXRpb25hbCB1c2FnZTogQXBpcy5pbnN0YW5jZSgpLmRiX2FwaSgpLmV4ZWMoXCJtZXRob2RcIiwgW1wibWV0aG9kXCIsIFwicGFybTFcIiwgMiwgMywgLi4uXSkuICBSZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHJlc3VsdHMuXG4qL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgICBzZXRScGNDb25uZWN0aW9uU3RhdHVzQ2FsbGJhY2s6IGZ1bmN0aW9uIHNldFJwY0Nvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnN0YXR1c0NiID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChpbnN0KSBpbnN0LnNldFJwY0Nvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgICBAYXJnIHtib29sZWFufSBhdXRvIG1lYW5zIGF1dG9tYXRpYyByZWNvbm5lY3QgaWYgcG9zc2libGUoIGJyb3dzZXIgY2FzZSksIGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgc2V0QXV0b1JlY29ubmVjdDogZnVuY3Rpb24gc2V0QXV0b1JlY29ubmVjdChhdXRvKSB7XG4gICAgICAgIGF1dG9SZWNvbm5lY3QgPSBhdXRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgICAgQGFyZyB7c3RyaW5nfSBjcyBpcyBvbmx5IHByb3ZpZGVkIGluIHRoZSBmaXJzdCBjYWxsXG4gICAgICAgIEByZXR1cm4ge0FwaXN9IHNpbmdsZXRvbiAuLiBDaGVjayBBcGlzLmluc3RhbmNlKCkuaW5pdF9wcm9taXNlIHRvIGtub3cgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB2YXIgY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwid3M6Ly9sb2NhbGhvc3Q6ODA5MFwiO1xuICAgICAgICB2YXIgY29ubmVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGNvbm5lY3RUaW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA0MDAwO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9wdGlvbmFsQXBpcyA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgdmFyIGNsb3NlQ2IgPSBhcmd1bWVudHNbNF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3QgPSBuZXcgQXBpc0luc3RhbmNlKCk7XG4gICAgICAgICAgICBpbnN0LnNldFJwY0Nvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayhfdGhpcy5zdGF0dXNDYik7XG5cbiAgICAgICAgICAgIGlmIChpbnN0ICYmIGNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBpbnN0LmNvbm5lY3QoY3MsIGNvbm5lY3RUaW1lb3V0LCBvcHRpb25hbEFwaXMsIGNsb3NlQ2IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZTogZnVuY3Rpb24gaW5zdGFuY2UoKSB7XG4gICAgICAgIHZhciBjcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJ3czovL2xvY2FsaG9zdDo4MDkwXCI7XG4gICAgICAgIHZhciBjb25uZWN0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY29ubmVjdFRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDQwMDA7XG4gICAgICAgIHZhciBvcHRpb25hbEFwaXMgPSBhcmd1bWVudHNbM107XG4gICAgICAgIHZhciBjbG9zZUNiID0gYXJndW1lbnRzWzRdO1xuXG4gICAgICAgIGlmICghaW5zdCkge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBBcGlzSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGluc3Quc2V0UnBjQ29ubmVjdGlvblN0YXR1c0NhbGxiYWNrKHRoaXMuc3RhdHVzQ2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3QgJiYgY29ubmVjdCkge1xuICAgICAgICAgICAgaW5zdC5jb25uZWN0KGNzLCBjb25uZWN0VGltZW91dCwgb3B0aW9uYWxBcGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2VDYikgaW5zdC5jbG9zZUNiID0gY2xvc2VDYjtcbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiBjaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gQXBpcy5pbnN0YW5jZSgpLmNoYWluX2lkO1xuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgIGluc3QuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIGRiOiAobWV0aG9kLCAuLi5hcmdzKSA9PiBBcGlzLmluc3RhbmNlKCkuZGJfYXBpKCkuZXhlYyhtZXRob2QsIHRvU3RyaW5ncyhhcmdzKSksXG4gICAgLy8gbmV0d29yazogKG1ldGhvZCwgLi4uYXJncykgPT4gQXBpcy5pbnN0YW5jZSgpLm5ldHdvcmtfYXBpKCkuZXhlYyhtZXRob2QsIHRvU3RyaW5ncyhhcmdzKSksXG4gICAgLy8gaGlzdG9yeTogKG1ldGhvZCwgLi4uYXJncykgPT4gQXBpcy5pbnN0YW5jZSgpLmhpc3RvcnlfYXBpKCkuZXhlYyhtZXRob2QsIHRvU3RyaW5ncyhhcmdzKSksXG4gICAgLy8gY3J5cHRvOiAobWV0aG9kLCAuLi5hcmdzKSA9PiBBcGlzLmluc3RhbmNlKCkuY3J5cHRvX2FwaSgpLmV4ZWMobWV0aG9kLCB0b1N0cmluZ3MoYXJncykpXG4gICAgLy8gb3JkZXJzOiAobWV0aG9kLCAuLi5hcmdzKSA9PiBBcGlzLmluc3RhbmNlKCkub3JkZXJzX2FwaSgpLmV4ZWMobWV0aG9kLCB0b1N0cmluZ3MoYXJncykpXG59O1xuXG52YXIgQXBpc0luc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwaXNJbnN0YW5jZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFwaXNJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgLyoqIEBhcmcge3N0cmluZ30gY29ubmVjdGlvbiAuLiAqL1xuICAgIEFwaXNJbnN0YW5jZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoY3MsIGNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRpb25hbEFwaXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHsgZW5hYmxlQ3J5cHRvOiBmYWxzZSwgZW5hYmxlT3JkZXJzOiBmYWxzZSB9O1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiSU5GT1xcdEFwaUluc3RhbmNlc1xcdGNvbm5lY3RcXHRcIiwgY3MpO1xuICAgICAgICB0aGlzLnVybCA9IGNzO1xuICAgICAgICB2YXIgcnBjX3VzZXIgPSBcIlwiLFxuICAgICAgICAgICAgcnBjX3Bhc3N3b3JkID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiBjcy5pbmRleE9mKFwid3NzOi8vXCIpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VjdXJlIGRvbWFpbnMgcmVxdWlyZSB3c3MgY29ubmVjdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLndzX3JwYykge1xuICAgICAgICAgICAgdGhpcy53c19ycGMuc3RhdHVzQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3NfcnBjID0gbmV3IF9DaGFpbldlYlNvY2tldDIuZGVmYXVsdChjcywgdGhpcy5zdGF0dXNDYiwgY29ubmVjdFRpbWVvdXQsIGF1dG9SZWNvbm5lY3QsIGZ1bmN0aW9uIChjbG9zZWQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuX2RiICYmICFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX2RiLmV4ZWMoJ2dldF9vYmplY3RzJywgW1snMi4xLjAnXV0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluaXRfcHJvbWlzZSA9IHRoaXMud3NfcnBjLmxvZ2luKHJwY191c2VyLCBycGNfcGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gQVBJIG5vZGU6XCIsIGNzKTtcbiAgICAgICAgICAgIF90aGlzMi5fZGIgPSBuZXcgX0dyYXBoZW5lQXBpMi5kZWZhdWx0KF90aGlzMi53c19ycGMsIFwiZGF0YWJhc2VcIik7XG4gICAgICAgICAgICBfdGhpczIuX25ldCA9IG5ldyBfR3JhcGhlbmVBcGkyLmRlZmF1bHQoX3RoaXMyLndzX3JwYywgXCJuZXR3b3JrX2Jyb2FkY2FzdFwiKTtcbiAgICAgICAgICAgIF90aGlzMi5faGlzdCA9IG5ldyBfR3JhcGhlbmVBcGkyLmRlZmF1bHQoX3RoaXMyLndzX3JwYywgXCJoaXN0b3J5XCIpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsQXBpcy5lbmFibGVPcmRlcnMpIF90aGlzMi5fb3JkZXJzID0gbmV3IF9HcmFwaGVuZUFwaTIuZGVmYXVsdChfdGhpczIud3NfcnBjLCBcIm9yZGVyc1wiKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25hbEFwaXMuZW5hYmxlQ3J5cHRvKSBfdGhpczIuX2NyeXB0ID0gbmV3IF9HcmFwaGVuZUFwaTIuZGVmYXVsdChfdGhpczIud3NfcnBjLCBcImNyeXB0b1wiKTtcbiAgICAgICAgICAgIHZhciBkYl9wcm9taXNlID0gX3RoaXMyLl9kYi5pbml0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vY3J5cHRvbm9tZXgvZ3JhcGhlbmUvd2lraS9jaGFpbi1sb2NrZWQtdHhcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9kYi5leGVjKFwiZ2V0X2NoYWluX2lkXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChfY2hhaW5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmNoYWluX2lkID0gX2NoYWluX2lkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX0NoYWluQ29uZmlnMi5kZWZhdWx0LnNldENoYWluSWQoX2NoYWluX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZyhcImNoYWluX2lkMVwiLHRoaXMuY2hhaW5faWQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzMi53c19ycGMub25fcmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMyLndzX3JwYykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIF90aGlzMi53c19ycGMubG9naW4oXCJcIiwgXCJcIikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5fZGIuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5zdGF0dXNDYikgX3RoaXMyLnN0YXR1c0NiKFwicmVjb25uZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9uZXQuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuX2hpc3QuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxBcGlzLmVuYWJsZU9yZGVycykgX3RoaXMyLl9vcmRlcnMuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxBcGlzLmVuYWJsZUNyeXB0bykgX3RoaXMyLl9jcnlwdC5pbml0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMyLndzX3JwYy5vbl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5jbG9zZUNiKSBfdGhpczIuY2xvc2VDYigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBpbml0UHJvbWlzZXMgPSBbZGJfcHJvbWlzZSwgX3RoaXMyLl9uZXQuaW5pdCgpLCBfdGhpczIuX2hpc3QuaW5pdCgpXTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsQXBpcy5lbmFibGVPcmRlcnMpIGluaXRQcm9taXNlcy5wdXNoKF90aGlzMi5fb3JkZXJzLmluaXQoKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWxBcGlzLmVuYWJsZUNyeXB0bykgaW5pdFByb21pc2VzLnB1c2goX3RoaXMyLl9jcnlwdC5pbml0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGluaXRQcm9taXNlcyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY3MsIFwiRmFpbGVkIHRvIGluaXRpYWxpemUgd2l0aCBlcnJvclwiLCBlcnIgJiYgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jbG9zZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgQXBpc0luc3RhbmNlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy53c19ycGMgJiYgdGhpcy53c19ycGMud3MucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3NfcnBjLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLndzX3JwYyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53c19ycGMgPSBudWxsO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIEFwaXNJbnN0YW5jZS5wcm90b3R5cGUuZGJfYXBpID0gZnVuY3Rpb24gZGJfYXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGI7XG4gICAgfTtcblxuICAgIEFwaXNJbnN0YW5jZS5wcm90b3R5cGUubmV0d29ya19hcGkgPSBmdW5jdGlvbiBuZXR3b3JrX2FwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldDtcbiAgICB9O1xuXG4gICAgQXBpc0luc3RhbmNlLnByb3RvdHlwZS5oaXN0b3J5X2FwaSA9IGZ1bmN0aW9uIGhpc3RvcnlfYXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlzdDtcbiAgICB9O1xuXG4gICAgQXBpc0luc3RhbmNlLnByb3RvdHlwZS5jcnlwdG9fYXBpID0gZnVuY3Rpb24gY3J5cHRvX2FwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyeXB0O1xuICAgIH07XG5cbiAgICBBcGlzSW5zdGFuY2UucHJvdG90eXBlLm9yZGVyc19hcGkgPSBmdW5jdGlvbiBvcmRlcnNfYXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXJzO1xuICAgIH07XG5cbiAgICBBcGlzSW5zdGFuY2UucHJvdG90eXBlLnNldFJwY0Nvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayA9IGZ1bmN0aW9uIHNldFJwY0Nvbm5lY3Rpb25TdGF0dXNDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnN0YXR1c0NiID0gY2FsbGJhY2s7XG4gICAgfTtcblxuICAgIHJldHVybiBBcGlzSW5zdGFuY2U7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX3RoaXMgPSB2b2lkIDA7XG5cbnZhciBlY2NfY29uZmlnID0ge1xuICAgIGFkZHJlc3NfcHJlZml4OiBwcm9jZXNzLmVudi5ucG1fY29uZmlnX19ncmFwaGVuZV9lY2NfZGVmYXVsdF9hZGRyZXNzX3ByZWZpeCB8fCBcIkdQSFwiXG59O1xuXG5fdGhpcyA9IHtcbiAgICBjb3JlX2Fzc2V0OiBcIkNPUkVcIixcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJHUEhcIixcbiAgICBleHBpcmVfaW5fc2VjczogMTUsXG4gICAgZXhwaXJlX2luX3NlY3NfcHJvcG9zYWw6IDI0ICogNjAgKiA2MCxcbiAgICByZXZpZXdfaW5fc2Vjc19jb21taXR0ZWU6IDI0ICogNjAgKiA2MCxcbiAgICBuZXR3b3Jrczoge1xuICAgICAgICBCaXRTaGFyZXM6IHtcbiAgICAgICAgICAgIGNvcmVfYXNzZXQ6IFwiQlRTXCIsXG4gICAgICAgICAgICBhZGRyZXNzX3ByZWZpeDogXCJCVFNcIixcbiAgICAgICAgICAgIGNoYWluX2lkOiBcIjQwMThkNzg0NGM3OGY2YTZjNDFjNmE1NTJiODk4MDIyMzEwZmM1ZGVjMDZkYTQ2N2VlNzkwNWE4ZGFkNTEyYzhcIlxuICAgICAgICB9LFxuICAgICAgICBNdXNlOiB7XG4gICAgICAgICAgICBjb3JlX2Fzc2V0OiBcIk1VU0VcIixcbiAgICAgICAgICAgIGFkZHJlc3NfcHJlZml4OiBcIk1VU0VcIixcbiAgICAgICAgICAgIGNoYWluX2lkOiBcIjQ1YWQyZDNmOWVmOTJhNDliNTVjMjIyN2ViMDYxMjNmNjEzYmIzNWRkMDhiZDg3NmYyYWVhMjE5MjVhNjdhNjdcIlxuICAgICAgICB9LFxuICAgICAgICBUZXN0OiB7XG4gICAgICAgICAgICBjb3JlX2Fzc2V0OiBcIlRFU1RcIixcbiAgICAgICAgICAgIGFkZHJlc3NfcHJlZml4OiBcIlRFU1RcIixcbiAgICAgICAgICAgIGNoYWluX2lkOiBcIjM5ZjVlMmVkZTFmOGJjMWEzYTU0YTc5MTQ0MTRlMzc3OWUzMzE5M2YxZjU2OTM1MTBlNzNjYjdhODc2MTc0NDdcIlxuICAgICAgICB9LFxuICAgICAgICBPYmVsaXNrOiB7XG4gICAgICAgICAgICBjb3JlX2Fzc2V0OiBcIkdPVlwiLFxuICAgICAgICAgICAgYWRkcmVzc19wcmVmaXg6IFwiRkVXXCIsXG4gICAgICAgICAgICBjaGFpbl9pZDogXCIxY2ZkZTdjMzg4YjllOGFjMDY0NjJkNjhhYWRiZDk2NmI1OGY4ODc5NzYzN2Q5YWY4MDViNDU2MGIwZTk2NjFlXCJcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogU2V0IGEgZmV3IHByb3BlcnRpZXMgZm9yIGtub3duIGNoYWluIElEcy4gKi9cbiAgICBzZXRDaGFpbklkOiBmdW5jdGlvbiBzZXRDaGFpbklkKGNoYWluX2lkKSB7XG5cbiAgICAgICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgICAgICBsZW4gPSB2b2lkIDAsXG4gICAgICAgICAgICBuZXR3b3JrID0gdm9pZCAwLFxuICAgICAgICAgICAgbmV0d29ya19uYW1lID0gdm9pZCAwLFxuICAgICAgICAgICAgcmVmID0gdm9pZCAwO1xuICAgICAgICByZWYgPSBPYmplY3Qua2V5cyhfdGhpcy5uZXR3b3Jrcyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIG5ldHdvcmtfbmFtZSA9IHJlZltpXTtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBfdGhpcy5uZXR3b3Jrc1tuZXR3b3JrX25hbWVdO1xuXG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbl9pZCA9PT0gY2hhaW5faWQpIHtcblxuICAgICAgICAgICAgICAgIF90aGlzLm5ldHdvcmtfbmFtZSA9IG5ldHdvcmtfbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrLmFkZHJlc3NfcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gbmV0d29yay5hZGRyZXNzX3ByZWZpeDtcbiAgICAgICAgICAgICAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IG5ldHdvcmsuYWRkcmVzc19wcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJJTkZPICAgIENvbmZpZ3VyZWQgZm9yXCIsIG5ldHdvcmtfbmFtZSwgXCI6XCIsIG5ldHdvcmsuY29yZV9hc3NldCwgXCJcXG5cIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX25hbWU6IG5ldHdvcmtfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLm5ldHdvcmtfbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGNoYWluIGlkICh0aGlzIG1heSBiZSBhIHRlc3RuZXQpXCIsIGNoYWluX2lkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF90aGlzLmNvcmVfYXNzZXQgPSBcIkNPUkVcIjtcbiAgICAgICAgX3RoaXMuYWRkcmVzc19wcmVmaXggPSBcIkdQSFwiO1xuICAgICAgICBlY2NfY29uZmlnLmFkZHJlc3NfcHJlZml4ID0gXCJHUEhcIjtcbiAgICAgICAgX3RoaXMuZXhwaXJlX2luX3NlY3MgPSAxNTtcbiAgICAgICAgX3RoaXMuZXhwaXJlX2luX3NlY3NfcHJvcG9zYWwgPSAyNCAqIDYwICogNjA7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJDaGFpbiBjb25maWcgcmVzZXRcIik7XG4gICAgfSxcblxuICAgIHNldFByZWZpeDogZnVuY3Rpb24gc2V0UHJlZml4KCkge1xuICAgICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIkdQSFwiO1xuXG4gICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gcHJlZml4O1xuICAgICAgICBlY2NfY29uZmlnLmFkZHJlc3NfcHJlZml4ID0gcHJlZml4O1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF90aGlzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFdlYlNvY2tldENsaWVudCA9IHZvaWQgMDtcbmlmICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiICYmICFwcm9jZXNzLmVudi5icm93c2VyKSB7XG4gICAgV2ViU29ja2V0Q2xpZW50ID0gcmVxdWlyZShcIndzXCIpO1xufSBlbHNlIHtcbiAgICBXZWJTb2NrZXRDbGllbnQgPSBXZWJTb2NrZXQ7XG59XG5cbnZhciBTT0NLRVRfREVCVUcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0V2ViU29ja2V0Q2xpZW50KGF1dG9SZWNvbm5lY3QpIHtcbiAgICBpZiAoIWF1dG9SZWNvbm5lY3QgJiYgdHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFdlYlNvY2tldDtcbiAgICB9XG4gICAgcmV0dXJuIFdlYlNvY2tldENsaWVudDtcbn1cblxudmFyIGtlZXBfYWxpdmVfaW50ZXJ2YWwgPSA1MDAwO1xudmFyIG1heF9zZW5kX2xpZmUgPSA1O1xudmFyIG1heF9yZWN2X2xpZmUgPSBtYXhfc2VuZF9saWZlICogMjtcblxudmFyIENoYWluV2ViU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYWluV2ViU29ja2V0KHdzX3NlcnZlciwgc3RhdHVzQ2IpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RUaW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1MDAwO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGF1dG9SZWNvbm5lY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgICAgIHZhciBrZWVwQWxpdmVDYiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhaW5XZWJTb2NrZXQpO1xuXG4gICAgICAgIHRoaXMudXJsID0gd3Nfc2VydmVyO1xuICAgICAgICB0aGlzLnN0YXR1c0NiID0gc3RhdHVzQ2I7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50X3JlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZWplY3QgPSBfdGhpcy5jdXJyZW50X3JlamVjdDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50X3JlamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciBcIiArIGNvbm5lY3RUaW1lb3V0IC8gMTAwMCArIFwic1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRfcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbl9yZWNvbm5lY3QgPSBudWxsO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbmRfbGlmZSA9IG1heF9zZW5kX2xpZmU7XG4gICAgICAgIHRoaXMucmVjdl9saWZlID0gbWF4X3JlY3ZfbGlmZTtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmVDYiA9IGtlZXBBbGl2ZUNiO1xuICAgICAgICB0aGlzLmNvbm5lY3RfcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgdmFyIFdzQ2xpZW50ID0gZ2V0V2ViU29ja2V0Q2xpZW50KGF1dG9SZWNvbm5lY3QpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cyA9IG5ldyBXc0NsaWVudCh3c19zZXJ2ZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cyA9IHsgcmVhZHlTdGF0ZTogMywgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge30gfTsgLy8gRElTQ09OTkVDVEVEXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgdXJsXCIsIHdzX3NlcnZlciwgXCIgY2xvc2VkXCIpKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5jbG9zZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgdXJsXCIsIHdzX3NlcnZlciwgXCIgY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVybFwiLCB3c19zZXJ2ZXIsIFwiIGNsb3NlZFwiKVxuICAgICAgICAgICAgICAgIC8vICAgICAvLyByZXR1cm4gdGhpcy5jdXJyZW50X3JlamVjdChFcnJvcihcIkludmFsaWQgd2Vic29ja2V0IHVybDogXCIgKyB3c19zZXJ2ZXIpKTtcbiAgICAgICAgICAgICAgICAvLyB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzQ2IpIF90aGlzLnN0YXR1c0NiKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25fcmVjb25uZWN0KSBfdGhpcy5vbl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5rZWVwYWxpdmVfdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVjdl9saWZlLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWN2X2xpZmUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihfdGhpcy51cmwgKyAnIGNvbm5lY3Rpb24gaXMgZGVhZCwgdGVybWluYXRpbmcgd3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlX3RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMua2VlcGFsaXZlX3RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmRfbGlmZS0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2VuZF9saWZlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMud3MucGluZygnJywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmtlZXBBbGl2ZUNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMua2VlcEFsaXZlQ2IoX3RoaXMuY2xvc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmRfbGlmZSA9IG1heF9zZW5kX2xpZmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50X3JlamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMua2VlcGFsaXZlX3RpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMua2VlcGFsaXZlX3RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMua2VlcGFsaXZlX3RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXNDYikgX3RoaXMuc3RhdHVzQ2IoXCJlcnJvclwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50X3JlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50X3JlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjdl9saWZlID0gbWF4X3JlY3ZfbGlmZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5saXN0ZW5lcihKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMua2VlcGFsaXZlX3RpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMua2VlcGFsaXZlX3RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMua2VlcGFsaXZlX3RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNiSWQgPSBfdGhpcy5yZXNwb25zZUNiSWQgKyAxOyBjYklkIDw9IF90aGlzLmNiSWQ7IGNiSWQgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYnNbY2JJZF0ucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXNDYikgX3RoaXMuc3RhdHVzQ2IoXCJjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jbG9zZUNiKSBfdGhpcy5fY2xvc2VDYigpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbl9jbG9zZSkgX3RoaXMub25fY2xvc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNiSWQgPSAwO1xuICAgICAgICB0aGlzLnJlc3BvbnNlQ2JJZCA9IDA7XG4gICAgICAgIHRoaXMuY2JzID0ge307XG4gICAgICAgIHRoaXMuc3VicyA9IHt9O1xuICAgICAgICB0aGlzLnVuc3ViID0ge307XG4gICAgfVxuXG4gICAgQ2hhaW5XZWJTb2NrZXQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiBjYWxsKHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy53cy5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWJzb2NrZXQgc3RhdGUgZXJyb3I6JyArIHRoaXMud3MucmVhZHlTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRob2QgPSBwYXJhbXNbMV07XG4gICAgICAgIGlmIChTT0NLRVRfREVCVUcpIGNvbnNvbGUubG9nKFwiW0NoYWluV2ViU29ja2V0XSA+LS0tLSBjYWxsIC0tLS0tPiAgXFxcImlkXFxcIjpcIiArICh0aGlzLmNiSWQgKyAxKSwgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG5cbiAgICAgICAgdGhpcy5jYklkICs9IDE7XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJzZXRfc3Vic2NyaWJlX2NhbGxiYWNrXCIgfHwgbWV0aG9kID09PSBcInN1YnNjcmliZV90b19tYXJrZXRcIiB8fCBtZXRob2QgPT09IFwiYnJvYWRjYXN0X3RyYW5zYWN0aW9uX3dpdGhfY2FsbGJhY2tcIiB8fCBtZXRob2QgPT09IFwic2V0X3BlbmRpbmdfdHJhbnNhY3Rpb25fY2FsbGJhY2tcIikge1xuICAgICAgICAgICAgLy8gU3RvcmUgY2FsbGJhY2sgaW4gc3VicyBtYXBcbiAgICAgICAgICAgIHRoaXMuc3Vic1t0aGlzLmNiSWRdID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBwYXJhbXNbMl1bMF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgY2FsbGJhY2sgd2l0aCB0aGUgY2FsbGJhY2sgaWRcbiAgICAgICAgICAgIHBhcmFtc1syXVswXSA9IHRoaXMuY2JJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidW5zdWJzY3JpYmVfZnJvbV9tYXJrZXRcIiB8fCBtZXRob2QgPT09IFwidW5zdWJzY3JpYmVfZnJvbV9hY2NvdW50c1wiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1syXVswXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgcGFyYW1ldGVyIG9mIHVuc3ViIG11c3QgYmUgdGhlIG9yaWdpbmFsIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5TdWJDYiA9IHBhcmFtc1syXS5zcGxpY2UoMCwgMSlbMF07XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnN1YnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzW2lkXS5jYWxsYmFjayA9PT0gdW5TdWJDYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3ViW3RoaXMuY2JJZF0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiY2FsbFwiLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5pZCA9IHRoaXMuY2JJZDtcbiAgICAgICAgdGhpcy5zZW5kX2xpZmUgPSBtYXhfc2VuZF9saWZlO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpczIuY2JzW190aGlzMi5jYklkXSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpczIud3Muc2VuZChKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaGFpbldlYlNvY2tldC5wcm90b3R5cGUubGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihyZXNwb25zZSkge1xuICAgICAgICBpZiAoU09DS0VUX0RFQlVHKSBjb25zb2xlLmxvZyhcIltDaGFpbldlYlNvY2tldF0gPC0tLS0gcmVwbHkgLS0tLTxcIiwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcblxuICAgICAgICB2YXIgc3ViID0gZmFsc2UsXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gXCJub3RpY2VcIikge1xuICAgICAgICAgICAgc3ViID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gcmVzcG9uc2UucGFyYW1zWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYnNbcmVzcG9uc2UuaWRdO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUNiSWQgPSByZXNwb25zZS5pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5zdWJzW3Jlc3BvbnNlLmlkXS5jYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxsYmFjayAmJiAhc3ViKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYnNbcmVzcG9uc2UuaWRdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy51bnN1YltyZXNwb25zZS5pZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdWJzW3RoaXMudW5zdWJbcmVzcG9uc2UuaWRdXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy51bnN1YltyZXNwb25zZS5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgc3ViKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZS5wYXJhbXNbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiB1bmtub3duIHdlYnNvY2tldCByZXNwb25zZTogXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDaGFpbldlYlNvY2tldC5wcm90b3R5cGUubG9naW4gPSBmdW5jdGlvbiBsb2dpbih1c2VyLCBwYXNzd29yZCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0X3Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmNhbGwoWzEsIFwibG9naW5cIiwgW3VzZXIsIHBhc3N3b3JkXV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2hhaW5XZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzNC5rZWVwYWxpdmVfdGltZXIpO1xuICAgICAgICAgICAgX3RoaXM0LmtlZXBhbGl2ZV90aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF90aGlzNC5fY2xvc2VDYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpczQuX2Nsb3NlQ2IgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghX3RoaXM0LndzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXZWJzb2NrZXQgYWxyZWFkeSBjbGVhcmVkXCIsIF90aGlzNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzNC53cy50ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczQud3MudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzNC53cy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzNC53cy5yZWFkeVN0YXRlID09PSAzKSByZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDaGFpbldlYlNvY2tldDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhaW5XZWJTb2NrZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FwaUluc3RhbmNlcyA9IHJlcXVpcmUoXCIuL0FwaUluc3RhbmNlc1wiKTtcblxudmFyIF9BcGlJbnN0YW5jZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpSW5zdGFuY2VzKTtcblxudmFyIF9DaGFpbldlYlNvY2tldCA9IHJlcXVpcmUoXCIuL0NoYWluV2ViU29ja2V0XCIpO1xuXG52YXIgX0NoYWluV2ViU29ja2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NoYWluV2ViU29ja2V0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFuYWdlcihfcmVmKSB7XG4gICAgICAgIHZhciB1cmwgPSBfcmVmLnVybCxcbiAgICAgICAgICAgIHVybHMgPSBfcmVmLnVybHMsXG4gICAgICAgICAgICBhdXRvRmFsbGJhY2sgPSBfcmVmLmF1dG9GYWxsYmFjayxcbiAgICAgICAgICAgIGNsb3NlQ2IgPSBfcmVmLmNsb3NlQ2IsXG4gICAgICAgICAgICBvcHRpb25hbEFwaXMgPSBfcmVmLm9wdGlvbmFsQXBpcztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFuYWdlcik7XG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMudXJscyA9IHVybHMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvRmFsbGJhY2sgPSBhdXRvRmFsbGJhY2s7XG4gICAgICAgIHRoaXMuY2xvc2VDYiA9IGNsb3NlQ2I7XG4gICAgICAgIHRoaXMub3B0aW9uYWxBcGlzID0gb3B0aW9uYWxBcGlzIHx8IHt9O1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgTWFuYWdlci5wcm90b3R5cGUuc2V0Q2xvc2VDYiA9IGZ1bmN0aW9uIHNldENsb3NlQ2IoY2IpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNiID0gY2I7XG4gICAgfTtcblxuICAgIE1hbmFnZXIuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9BcGlJbnN0YW5jZXMyLmRlZmF1bHQuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgTWFuYWdlci5wcm90b3R5cGUubG9nRmFpbHVyZSA9IGZ1bmN0aW9uIGxvZ0ZhaWx1cmUobWV0aG9kLCB1cmwsIGVycikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogXCJcIjtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXRob2QsIFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gXCIgKyB1cmwgKyAobWVzc2FnZSA/IFwiIEVycm9yOiBcIiArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpIDogXCJcIikpO1xuICAgIH07XG5cbiAgICBNYW5hZ2VyLnByb3RvdHlwZS5fb25DbG9zZSA9IGZ1bmN0aW9uIF9vbkNsb3NlKCkge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQ2IpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDYigpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbG9zZUNiKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9GYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0V2l0aEZhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIE1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBfY29ubmVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgICB2YXIgdXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnVybDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX0FwaUluc3RhbmNlczIuZGVmYXVsdC5pbnN0YW5jZSh1cmwsIF9jb25uZWN0LCB1bmRlZmluZWQsIF90aGlzLm9wdGlvbmFsQXBpcywgX3RoaXMuX29uQ2xvc2UuYmluZChfdGhpcykpLmluaXRfcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfQXBpSW5zdGFuY2VzMi5kZWZhdWx0LmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0V2l0aEZhbGxiYWNrID0gZnVuY3Rpb24gY29ubmVjdFdpdGhGYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAgIHZhciB1cmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudXJsO1xuICAgICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICAgIHZhciByZWplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlamVjdCAmJiBpbmRleCA+IHRoaXMudXJscy5sZW5ndGgpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiVHJpZWQgXCIgKyBpbmRleCArIFwiIGNvbm5lY3Rpb25zLCBub25lIG9mIHdoaWNoIHdvcmtlZDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnVybHMuY29uY2F0KHRoaXMudXJsKSkpKTtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24gZmFsbGJhY2soZXJyLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubG9nRmFpbHVyZShcImNvbm5lY3RXaXRoRmFsbGJhY2tcIiwgdXJsLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jb25uZWN0V2l0aEZhbGxiYWNrKGNvbm5lY3QsIF90aGlzMi51cmxzW2luZGV4XSwgaW5kZXggKyAxLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzb2x2ZSAmJiByZWplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoY29ubmVjdCwgdXJsKS50aGVuKHJlc29sdmUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFjayhlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmNvbm5lY3QoY29ubmVjdCwgdW5kZWZpbmVkKS50aGVuKHJlc29sdmUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2soZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWFuYWdlci5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrQ29ubmVjdGlvbnMoKSB7XG4gICAgICAgIHZhciBycGNfdXNlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJcIjtcbiAgICAgICAgdmFyIHJwY19wYXNzd29yZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIHJlamVjdCA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgICB2YXIgY29ubmVjdGlvblN0YXJ0VGltZXMgPSB7fTtcbiAgICAgICAgdmFyIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbiBjaGVja0Z1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxMaXN0ID0gX3RoaXMzLnVybHMuY29uY2F0KF90aGlzMy51cmwpO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Qcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICBmdWxsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgICAgICAvKiBVc2UgZGVmYXVsdCB0aW1lb3V0IGFuZCBubyByZWNvbm5lY3Rpbmctd2Vic29ja2V0ICovXG4gICAgICAgICAgICAgICAgdmFyIGNvbm4gPSBuZXcgX0NoYWluV2ViU29ja2V0Mi5kZWZhdWx0KHVybCwgZnVuY3Rpb24gKCkge30sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWVzW3VybF0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUHJvbWlzZXMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uLmxvZ2luKHJwY191c2VyLCBycGNfcGFzc3dvcmQpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKF9yZXN1bHQgPSB7fSwgX3Jlc3VsdFt1cmxdID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBjb25uZWN0aW9uU3RhcnRUaW1lc1t1cmxdLCBfcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczMubG9nRmFpbHVyZShcImNoZWNrQ29ubmVjdGlvbnNcIiwgdXJsLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PT0gX3RoaXMzLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy51cmwgPSBfdGhpczMudXJsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnVybHMgPSBfdGhpczMudXJscy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgIT09IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoY29ubmVjdGlvblByb21pc2VzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhKCk7XG4gICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsID0gcmVzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFhO1xuICAgICAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYSlbMF0gLSBPYmplY3QudmFsdWVzKGIpWzBdO1xuICAgICAgICAgICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoZiwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGZba2V5XSA9IGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDaGVja2VkIFwiICsgcmVzLmxlbmd0aCArIFwiIGNvbm5lY3Rpb25zLCBcIiArIChyZXMubGVuZ3RoIC0gT2JqZWN0LmtleXMoZmluYWwpLmxlbmd0aCkgKyBcIiBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmluYWwpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuY2hlY2tDb25uZWN0aW9ucyhycGNfdXNlciwgcnBjX3Bhc3N3b3JkLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc29sdmUgJiYgcmVqZWN0KSB7XG4gICAgICAgICAgICBjaGVja0Z1bmN0aW9uKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoY2hlY2tGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgR3JhcGhlbmVBcGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhlbmVBcGkod3NfcnBjLCBhcGlfbmFtZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhlbmVBcGkpO1xuXG4gICAgICAgIHRoaXMud3NfcnBjID0gd3NfcnBjO1xuICAgICAgICB0aGlzLmFwaV9uYW1lID0gYXBpX25hbWU7XG4gICAgfVxuXG4gICAgR3JhcGhlbmVBcGkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndzX3JwYy5jYWxsKFsxLCB0aGlzLmFwaV9uYW1lLCBbXV0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiW0dyYXBoZW5lQXBpLmpzOjExXSAtLS0tLSBHcmFwaGVuZUFwaS5pbml0IC0tLS0tPlwiLCB0aGlzLmFwaV9uYW1lLCByZXNwb25zZSk7XG4gICAgICAgICAgICBzZWxmLmFwaV9pZCA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBHcmFwaGVuZUFwaS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIGV4ZWMobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3NfcnBjLmNhbGwoW3RoaXMuYXBpX2lkLCBtZXRob2QsIHBhcmFtc10pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIhISEgR3JhcGhlbmVBcGkgZXJyb3I6IFwiLCBtZXRob2QsIHBhcmFtcywgZXJyb3IsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHcmFwaGVuZUFwaTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR3JhcGhlbmVBcGk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLypcclxuIENvcHlyaWdodCAyMDEzLTIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgYnl0ZWJ1ZmZlci5qcyAoYykgMjAxNSBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBCYWNraW5nIGJ1ZmZlcjogQXJyYXlCdWZmZXIsIEFjY2Vzc29yOiBVaW50OEFycmF5XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9ieXRlYnVmZmVyLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW1wibG9uZ1wiXSwgZmFjdG9yeSk7XHJcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxyXG4gICAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgTG9uZzsgdHJ5IHsgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpOyB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShMb25nKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiQnl0ZUJ1ZmZlclwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkxvbmdcIl0pO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oTG9uZykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAY2xhc3MgVGhlIHN3aXNzIGFybXkga25pZmUgZm9yIGJpbmFyeSBkYXRhIGluIEphdmFTY3JpcHQuXHJcbiAgICAgKiBAZXhwb3J0cyBCeXRlQnVmZmVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY2FwYWNpdHkgSW5pdGlhbCBjYXBhY2l0eS4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWX0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIHZhciBCeXRlQnVmZmVyID0gZnVuY3Rpb24oY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhcGFjaXR5ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgY2FwYWNpdHkgPSBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9Bc3NlcnQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBub0Fzc2VydCA9IEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVDtcclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gY2FwYWNpdHkgfCAwO1xyXG4gICAgICAgICAgICBpZiAoY2FwYWNpdHkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHlcIik7XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9ICEhbm9Bc3NlcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYWNraW5nIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXlCdWZmZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gY2FwYWNpdHkgPT09IDAgPyBFTVBUWV9CVUZGRVIgOiBuZXcgQXJyYXlCdWZmZXIoY2FwYWNpdHkpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVaW50OEFycmF5IHV0aWxpemVkIHRvIG1hbmlwdWxhdGUgdGhlIGJhY2tpbmcgYnVmZmVyLiBCZWNvbWVzIGBudWxsYCBpZiB0aGUgYmFja2luZyBidWZmZXIgaGFzIGEgY2FwYWNpdHkgb2YgYDBgLlxyXG4gICAgICAgICAqIEB0eXBlIHs/VWludDhBcnJheX1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3ID0gY2FwYWNpdHkgPT09IDAgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnNvbHV0ZSByZWFkL3dyaXRlIG9mZnNldC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjZmxpcFxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNjbGVhclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFya2VkIG9mZnNldC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjbWFya1xyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZXNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic29sdXRlIGxpbWl0IG9mIHRoZSBjb250YWluZWQgZGF0YS4gU2V0IHRvIHRoZSBiYWNraW5nIGJ1ZmZlcidzIGNhcGFjaXR5IHVwb24gYWxsb2NhdGlvbi5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjZmxpcFxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNjbGVhclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBjYXBhY2l0eTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byB1c2UgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBiaWcgZW5kaWFuLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLCBkZWZhdWx0cyB0byBgZmFsc2VgLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vQXNzZXJ0ID0gbm9Bc3NlcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnl0ZUJ1ZmZlciB2ZXJzaW9uLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLlZFUlNJT04gPSBcIjUuMC4xXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXR0bGUgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGB0cnVlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTiA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCaWcgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkJJR19FTkRJQU4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgaW5pdGlhbCBjYXBhY2l0eSBvZiBgMTZgLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZID0gMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGVuZGlhbmVzcyBvZiBgZmFsc2VgIGZvciBiaWcgZW5kaWFuLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU4gPSBCeXRlQnVmZmVyLkJJR19FTkRJQU47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IG5vIGFzc2VydGlvbnMgZmxhZyBvZiBgZmFsc2VgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTG9uZ2AgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuIE1heSBiZSBgbnVsbGAgaWYgTG9uZy5qcyBoYXMgbm90IGJlZW4gbG9hZGVkXHJcbiAgICAgKiAgYW5kIGludDY0IHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAqIEB0eXBlIHs/TG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTG9uZyA9IExvbmcgfHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBCeXRlQnVmZmVyLnByb3RvdHlwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBCeXRlQnVmZmVyUHJvdG90eXBlID0gQnl0ZUJ1ZmZlci5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnl0ZUJ1ZmZlciBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5fX2lzQnl0ZUJ1ZmZlcl9fO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlQnVmZmVyUHJvdG90eXBlLCBcIl9faXNCeXRlQnVmZmVyX19cIiwge1xyXG4gICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGhlbHBlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshQXJyYXlCdWZmZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEVNUFRZX0JVRkZFUiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZy5mcm9tQ2hhckNvZGUgcmVmZXJlbmNlIGZvciBjb21waWxlLXRpbWUgcmVuYW1pbmcuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oLi4ubnVtYmVyKTpzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIGZ1bmN0aW9uIGZvciBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZyB0byByZWFkIGZyb21cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpOm51bWJlcnxudWxsfSBTb3VyY2UgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZVxyXG4gICAgICogIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYXJndW1lbnQgaXMgaW52YWxpZFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ1NvdXJjZShzKSB7XHJcbiAgICAgICAgdmFyIGk9MDsgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaSA8IHMubGVuZ3RoID8gcy5jaGFyQ29kZUF0KGkrKykgOiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVzdGluYXRpb24gZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcj0pOnVuZGVmaW5lZHxzdHJpbmd9IERlc3RpbmF0aW9uIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBjaGFyIGNvZGUuXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgZmluYWwgc3RyaW5nIHdoZW4gY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzLlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ0Rlc3RpbmF0aW9uKCkge1xyXG4gICAgICAgIHZhciBjcyA9IFtdLCBwcyA9IFtdOyByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBzLmpvaW4oJycpK3N0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNzKTtcclxuICAgICAgICAgICAgaWYgKGNzLmxlbmd0aCArIGFyZ3VtZW50cy5sZW5ndGggPiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgcHMucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcykpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhY2Nlc3NvciB0eXBlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgVWludDhBcnJheWAgcmVzcGVjdGl2ZWx5IGBEYXRhVmlld2AgaW4gdGhlIGJyb3dzZXIgKGNsYXNzZXMpXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYWNjZXNzb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gVWludDhBcnJheTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBhIG5ldyBCeXRlQnVmZmVyIGJhY2tlZCBieSBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBjYXBhY2l0eSBJbml0aWFsIGNhcGFjaXR5LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jYXRlbmF0ZXMgbXVsdGlwbGUgQnl0ZUJ1ZmZlcnMgaW50byBvbmUuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZz59IGJ1ZmZlcnMgQnVmZmVycyB0byBjb25jYXRlbmF0ZVxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJzYCBjb250YWlucyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIixcclxuICAgICAqICBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyIGZvciB0aGUgcmVzdWx0aW5nIEJ5dGVCdWZmZXIuIERlZmF1bHRzXHJcbiAgICAgKiAgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzIGZvciB0aGUgcmVzdWx0aW5nIEJ5dGVCdWZmZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENvbmNhdGVuYXRlZCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24oYnVmZmVycywgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9IGxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FwYWNpdHkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgaz1idWZmZXJzLmxlbmd0aCwgbGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcnNbaV0pKVxyXG4gICAgICAgICAgICAgICAgYnVmZmVyc1tpXSA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXJzW2ldLCBlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmZlcnNbaV0ubGltaXQgLSBidWZmZXJzW2ldLm9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDApIGNhcGFjaXR5ICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhcGFjaXR5ID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxyXG4gICAgICAgICAgICBiaTtcclxuICAgICAgICBpPTA7IHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgYmkgPSBidWZmZXJzW2krK107XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJpLmxpbWl0IC0gYmkub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBiYi52aWV3LnNldChiaS52aWV3LnN1YmFycmF5KGJpLm9mZnNldCwgYmkubGltaXQpLCBiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICBiYi5vZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGJiLm9mZnNldDtcclxuICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHsqfSBiYiBCeXRlQnVmZmVyIHRvIHRlc3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgaXQgaXMgYSBCeXRlQnVmZmVyLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJiKSB7XHJcbiAgICAgICAgcmV0dXJuIChiYiAmJiBiYltcIl9faXNCeXRlQnVmZmVyX19cIl0pID09PSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYmFja2luZyBidWZmZXIgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYEJ1ZmZlcmAgdW5kZXIgbm9kZS5qcywgYEFycmF5QnVmZmVyYCBpbiB0aGUgYnJvd3NlciAoY2xhc3NlcylcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci50eXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV3JhcHMgYSBidWZmZXIgb3IgYSBzdHJpbmcuIFNldHMgdGhlIGFsbG9jYXRlZCBCeXRlQnVmZmVyJ3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSB0byBgMGAgYW5kIGl0c1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSB0byB0aGUgbGVuZ3RoIG9mIHRoZSB3cmFwcGVkIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmd8IUFycmF5LjxudW1iZXI+fSBidWZmZXIgQW55dGhpbmcgdGhhdCBjYW4gYmUgd3JhcHBlZFxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0b1xyXG4gICAgICogIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBBIEJ5dGVCdWZmZXIgd3JhcHBpbmcgYGJ1ZmZlcmBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci53cmFwID0gZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCI7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tSGV4KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbVVURjgoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbURlYnVnKGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmZXIgPT09IG51bGwgfHwgdHlwZW9mIGJ1ZmZlciAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgICAgIHZhciBiYjtcclxuICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSkge1xyXG4gICAgICAgICAgICBiYiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUuY2xvbmUuY2FsbChidWZmZXIpO1xyXG4gICAgICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyAvLyBFeHRyYWN0IEFycmF5QnVmZmVyIGZyb20gVWludDhBcnJheVxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHsgLy8gQXZvaWQgcmVmZXJlbmNlcyB0byBtb3JlIHRoYW4gb25lIEVNUFRZX0JVRkZFUlxyXG4gICAgICAgICAgICAgICAgYmIuYnVmZmVyID0gYnVmZmVyLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJ1ZmZlci5ieXRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIuYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYmIudmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgeyAvLyBSZXVzZSBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYi5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJiLnZpZXcgPSBidWZmZXIuYnl0ZUxlbmd0aCA+IDAgPyBuZXcgVWludDhBcnJheShidWZmZXIpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJ1ZmZlcikgPT09IFwiW29iamVjdCBBcnJheV1cIikgeyAvLyBDcmVhdGUgZnJvbSBvY3RldHNcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihidWZmZXIubGVuZ3RoLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YnVmZmVyLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgYmIudmlld1tpXSA9IGJ1ZmZlcltpXTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7IC8vIE90aGVyd2lzZSBmYWlsXHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgYXJyYXkgYXMgYSBiaXRzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PGJvb2xlYW4+fSB2YWx1ZSBBcnJheSBvZiBib29sZWFucyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYGxlbmd0aGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJpdFNldCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIEJpdFNldDogTm90IGFuIGFycmF5XCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgIGJpdHMgPSB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxyXG4gICAgICAgICAgYml0ID0gMCxcclxuICAgICAgICAgIGs7XHJcblxyXG4gICAgICBvZmZzZXQgKz0gdGhpcy53cml0ZVZhcmludDMyKGJpdHMsb2Zmc2V0KTtcclxuXHJcbiAgICAgIHdoaWxlKGJ5dGVzLS0pIHtcclxuICAgICAgICBrID0gKCEhdmFsdWVbYml0KytdICYgMSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMikgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMykgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNCkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNikgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNyk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ5dGUoayxvZmZzZXQrKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcclxuICAgICAgICB2YXIgbSA9IDA7IGsgPSAwO1xyXG4gICAgICAgIHdoaWxlKGJpdCA8IGJpdHMpIGsgPSBrIHwgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IChtKyspKTtcclxuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBCaXRTZXQgYXMgYW4gYXJyYXkgb2YgYm9vbGVhbnMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJpdFNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cclxuICAgICAgdmFyIHJldCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCksXHJcbiAgICAgICAgICBiaXRzID0gcmV0LnZhbHVlLFxyXG4gICAgICAgICAgYnl0ZXMgPSAoYml0cyA+PiAzKSxcclxuICAgICAgICAgIGJpdCA9IDAsXHJcbiAgICAgICAgICB2YWx1ZSA9IFtdLFxyXG4gICAgICAgICAgaztcclxuXHJcbiAgICAgIG9mZnNldCArPSByZXQubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUoYnl0ZXMtLSkge1xyXG4gICAgICAgIGsgPSB0aGlzLnJlYWRCeXRlKG9mZnNldCsrKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMSk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDIpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA0KTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwOCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MTApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDIwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg0MCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4ODApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihiaXQgPCBiaXRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSAwO1xyXG4gICAgICAgIGsgPSB0aGlzLnJlYWRCeXRlKG9mZnNldCsrKTtcclxuICAgICAgICB3aGlsZShiaXQgPCBiaXRzKSB2YWx1ZVtiaXQrK10gPSAhISgoayA+PiAobSsrKSkgJiAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIitsZW5ndGgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzbGljZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBwYXlsb2FkIG9mIGJ5dGVzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI2FwcGVuZH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gd3JpdGUuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcclxuICAgICAqICB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCeXRlcyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kO1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50OFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkwICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDB4ODApIHZhbHVlID0gLSgweEZGIC0gdmFsdWUgKyAxKTsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHZhciBjYXBhY2l0eTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDggPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50ODtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDE2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODAwMCkgPT09IDB4ODAwMCkgdmFsdWUgPSAtKDB4RkZGRiAtIHZhbHVlICsgMSk7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB2YXIgY2FwYWNpdHkzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MylcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMjtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXRdICAgPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQxNiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDE2ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2O1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50MzJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk0KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQzMn0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlIHw9IDA7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MzJ9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk1KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQzMjtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDY0XHJcblxyXG4gICAgaWYgKExvbmcpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk2KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTYgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXHJcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50NjR9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvID0gMCxcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IExvbmcobG8sIGhpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ2NH0uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhciBjYXBhY2l0eTcgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NylcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk3ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk3IDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICAgICAgdmFyIGxvID0gdmFsdWUubG93LFxyXG4gICAgICAgICAgICAgICAgaGkgPSB2YWx1ZS5oaWdoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDY0fS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDY0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrOCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsbyA9IDAsXHJcbiAgICAgICAgICAgICAgICBoaSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ2NH0uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQ7XHJcblxyXG4gICAgfSAvLyBMb25nXHJcblxyXG5cclxuICAgIC8vIHR5cGVzL2Zsb2F0cy9mbG9hdDMyXHJcblxyXG4gICAgLypcclxuICAgICBpZWVlNzU0IC0gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XHJcblxyXG4gICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG5cclxuICAgICBDb3B5cmlnaHQgKGMpIEZlcm9zcyBBYm91a2hhZGlqZWhcclxuXHJcbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gICAgIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICAgICBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAgICAgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gICAgIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAgICAgYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICAgICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICAgICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAgICAgVEhFIFNPRlRXQVJFLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIElFRUU3NTQgZmxvYXQgZnJvbSBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTEVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGllZWU3NTRfcmVhZChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBuQml0cyA9IC03LFxyXG4gICAgICAgICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXHJcbiAgICAgICAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxyXG4gICAgICAgICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xyXG5cclxuICAgICAgICBpICs9IGQ7XHJcblxyXG4gICAgICAgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xyXG4gICAgICAgIHMgPj49ICgtbkJpdHMpO1xyXG4gICAgICAgIG5CaXRzICs9IGVMZW47XHJcbiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cclxuXHJcbiAgICAgICAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XHJcbiAgICAgICAgZSA+Pj0gKC1uQml0cyk7XHJcbiAgICAgICAgbkJpdHMgKz0gbUxlbjtcclxuICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICAgICAgICBpZiAoZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBlID0gMSAtIGVCaWFzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgZSA9IGUgLSBlQmlhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gSUVFRTc1NCBmbG9hdCB0byBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1MZW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXNcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpZWVlNzU0X3dyaXRlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sIGMsXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXHJcbiAgICAgICAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcclxuICAgICAgICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXHJcbiAgICAgICAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XHJcblxyXG4gICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGUgPSBlTWF4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgZS0tO1xyXG4gICAgICAgICAgICAgICAgYyAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xyXG4gICAgICAgICAgICAgICAgZSsrO1xyXG4gICAgICAgICAgICAgICAgYyAvPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZSA9IGVNYXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cclxuXHJcbiAgICAgICAgZSA9IChlIDw8IG1MZW4pIHwgbTtcclxuICAgICAgICBlTGVuICs9IG1MZW47XHJcbiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxyXG5cclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhIG51bWJlcilcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5OCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTgpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk4ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk4IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGllZWU3NTRfd3JpdGUodGhpcy52aWV3LCB2YWx1ZSwgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDIzLCA0KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0MzI7XHJcblxyXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0NjRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB2YXIgY2FwYWNpdHk5ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5OSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTkgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTkgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgaWVlZTc1NF93cml0ZSh0aGlzLnZpZXcsIHZhbHVlLCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCA1MiwgOCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSA2NGJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUZsb2F0NjR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZURvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSA2NGJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDY0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWREb3VibGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0O1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy92YXJpbnRzL3ZhcmludDMyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFUyA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UMzJfQllURVN9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiAwO1xyXG4gICAgICAgICAgICAgaWYgKHZhbHVlIDwgMSA8PCA3ICkgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDE0KSByZXR1cm4gMjtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMjEpIHJldHVybiAzO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAyOCkgcmV0dXJuIDQ7XHJcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaaWd6YWcgZW5jb2RlcyBhIHNpZ25lZCAzMmJpdCBpbnRlZ2VyIHNvIHRoYXQgaXQgY2FuIGJlIGVmZmVjdGl2ZWx5IHVzZWQgd2l0aCB2YXJpbnQgZW5jb2RpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBTaWduZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyID0gZnVuY3Rpb24obikge1xyXG4gICAgICAgIHJldHVybiAoKChuIHw9IDApIDw8IDEpIF4gKG4gPj4gMzEpKSA+Pj4gMDsgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSB6aWd6YWcgZW5jb2RlZCBzaWduZWQgMzJiaXQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIgPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuICgobiA+Pj4gMSkgXiAtKG4gJiAxKSkgfCAwOyAvLyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gMHg4MCkge1xyXG4gICAgICAgICAgICBiID0gKHZhbHVlICYgMHg3ZikgfCAweDgwO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSA3O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50MzJaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSwgb2Zmc2V0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXHJcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnQuIEhhcyBhIHByb3BlcnR5IGB0cnVuY2F0ZWQgPSB0cnVlYCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgYXZhaWxhYmxlXHJcbiAgICAgKiAgdG8gZnVsbHkgZGVjb2RlIHRoZSB2YXJpbnQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSAwLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IDAgPj4+IDAsXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQgJiYgb2Zmc2V0ID4gdGhpcy5saW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiVHJ1bmNhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgZXJyWyd0cnVuY2F0ZWQnXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107XHJcbiAgICAgICAgICAgIGlmIChjIDwgNSlcclxuICAgICAgICAgICAgICAgIHZhbHVlIHw9IChiICYgMHg3ZikgPDwgKDcqYyk7XHJcbiAgICAgICAgICAgICsrYztcclxuICAgICAgICB9IHdoaWxlICgoYiAmIDB4ODApICE9PSAwKTtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxyXG4gICAgICAgICAgICBcImxlbmd0aFwiOiBjXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCAoc2lnbmVkKSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCF7dmFsdWU6IG51bWJlciwgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZFxyXG4gICAgICogIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyWmlnWmFnID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB2YWxbXCJ2YWx1ZVwiXSA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIodmFsW1widmFsdWVcIl0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWwpO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50NjRcclxuXHJcbiAgICBpZiAoTG9uZykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTID0gMTA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkLiBDYXBwZWQgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgICAgIHZhciBwYXJ0MCA9IHZhbHVlLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAocGFydDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQxID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDAgPCAxIDw8IDE0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDAgPCAxIDw8IDcgPyAxIDogMjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgMjEgPyAzIDogNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQxIDwgMSA8PCAxNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxIDwgMSA8PCA3ID8gNSA6IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDEgPCAxIDw8IDIxID8gNyA6IDg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQyIDwgMSA8PCA3ID8gOSA6IDEwO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDY0Yml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgU2lnbmVkIGxvbmdcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmdcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0TGVmdCgxKS54b3IodmFsdWUuc2hpZnRSaWdodCg2MykpLnRvVW5zaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgemlnemFnIGVuY29kZWQgc2lnbmVkIDY0Yml0IGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ9IHZhbHVlIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmcgb3IgSmF2YVNjcmlwdCBudW1iZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMSkueG9yKHZhbHVlLmFuZChMb25nLk9ORSkudG9TaWduZWQoKS5uZWdhdGUoKSkudG9TaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCkgPj4+IDA7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5MTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTEpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTEgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTExIDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSBzaXplO1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB0aGlzLnZpZXdbb2Zmc2V0KzldID0gKHBhcnQyID4+PiAgNykgJiAweDAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5IDogdGhpcy52aWV3W29mZnNldCs4XSA9IHNpemUgIT09IDkgPyAocGFydDIgICAgICAgKSB8IDB4ODAgOiAocGFydDIgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDggOiB0aGlzLnZpZXdbb2Zmc2V0KzddID0gc2l6ZSAhPT0gOCA/IChwYXJ0MSA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMjEpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNyA6IHRoaXMudmlld1tvZmZzZXQrNl0gPSBzaXplICE9PSA3ID8gKHBhcnQxID4+PiAxNCkgfCAweDgwIDogKHBhcnQxID4+PiAxNCkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2IDogdGhpcy52aWV3W29mZnNldCs1XSA9IHNpemUgIT09IDYgPyAocGFydDEgPj4+ICA3KSB8IDB4ODAgOiAocGFydDEgPj4+ICA3KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUgOiB0aGlzLnZpZXdbb2Zmc2V0KzRdID0gc2l6ZSAhPT0gNSA/IChwYXJ0MSAgICAgICApIHwgMHg4MCA6IChwYXJ0MSAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNCA6IHRoaXMudmlld1tvZmZzZXQrM10gPSBzaXplICE9PSA0ID8gKHBhcnQwID4+PiAyMSkgfCAweDgwIDogKHBhcnQwID4+PiAyMSkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIDogdGhpcy52aWV3W29mZnNldCsyXSA9IHNpemUgIT09IDMgPyAocGFydDAgPj4+IDE0KSB8IDB4ODAgOiAocGFydDAgPj4+IDE0KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgOiB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gc2l6ZSAhPT0gMiA/IChwYXJ0MCA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gIDcpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSA6IHRoaXMudmlld1tvZmZzZXQgIF0gPSBzaXplICE9PSAxID8gKHBhcnQwICAgICAgICkgfCAweDgwIDogKHBhcnQwICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSB6aWctemFnIGVuY29kZWQgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8TG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSksIG9mZnNldCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MCA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IDAsXHJcbiAgICAgICAgICAgICAgICBiICA9IDA7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoIGIgJiAweDgwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQnVmZmVyIG92ZXJydW5cIik7IH19fX19fX19fX1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gTG9uZy5mcm9tQml0cyhwYXJ0MCB8IChwYXJ0MSA8PCAyOCksIChwYXJ0MSA+Pj4gNCkgfCAocGFydDIpIDw8IDI0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQtc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDY0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsWyd2YWx1ZSddIGluc3RhbmNlb2YgTG9uZylcclxuICAgICAgICAgICAgICAgIHZhbFtcInZhbHVlXCJdID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCh2YWxbXCJ2YWx1ZVwiXSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHZhbCA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gLy8gTG9uZ1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL2NzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzcGVjaWZpZWQgc3RyaW5nIG11c3Qgbm90IGNvbnRhaW4gYW55IE5VTExcclxuICAgICAqICBjaGFyYWN0ZXJzIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBjb250YWluZWQgaW4gYHN0cmAgKyAxIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUNTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyLCBzbzpcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGsrMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEyICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBrKzE7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gMDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzdHJpbmcgcmVhZCBtdXN0IG5vdCBjb250YWluIGFueSBOVUxMIGNoYXJhY3RlcnNcclxuICAgICAqICBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgdGVtcDtcclxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyIGl0c2VsZiwgc286XHJcbiAgICAgICAgdmFyIHNkLCBiID0gLTE7XHJcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA8IFwiK3RoaXMubGltaXQpO1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTtcclxuICAgICAgICAgICAgcmV0dXJuIGIgPT09IDAgPyBudWxsIDogYjtcclxuICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogc2QoKSxcclxuICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL2lzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxlbmd0aCBhcyB1aW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjd3JpdGVWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICBrO1xyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpLCB0aGlzLm5vQXNzZXJ0KVsxXTtcclxuICAgICAgICBvZmZzZXQgKz0gNCtrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEzKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEzIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQraztcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0ICsgNCArIGspXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiID09IFwiKyhvZmZzZXQrNCtrKSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZElTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnJlYWRVVEY4U3RyaW5nKGxlbiwgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTLCBvZmZzZXQgKz0gNCk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0clsnbGVuZ3RoJ107XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyWydzdHJpbmcnXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IHN0clsnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdXRmOHN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cmljcyByZXByZXNlbnRpbmcgbnVtYmVyIG9mIFVURjggY2hhcmFjdGVycy4gRXZhbHVhdGVzIHRvIGBjYC5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTID0gJ2MnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cmljcyByZXByZXNlbnRpbmcgbnVtYmVyIG9mIGJ5dGVzLiBFdmFsdWF0ZXMgdG8gYGJgLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMgPSAnYic7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaztcclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSBrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE0KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTQgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE0IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGs7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVVEY4U3RyaW5nfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVN0cmluZyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggY2hhcmFjdGVycyBvZiBhIHN0cmluZy4gSmF2YVNjcmlwdCBpdHNlbGYgdXNlcyBVVEYtMTYsIHNvIHRoYXQgYSBzdHJpbmcnc1xyXG4gICAgICogIGBsZW5ndGhgIHByb3BlcnR5IGRvZXMgbm90IHJlZmxlY3QgaXRzIGFjdHVhbCBVVEY4IHNpemUgaWYgaXQgY29udGFpbnMgY29kZSBwb2ludHMgbGFyZ2VyIHRoYW4gMHhGRkZGLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOENoYXJzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzBdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBieXRlc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHJldHVybiB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyBvZiBhIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlU3RyaW5nID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgY2hhcmFjdGVycyBvciBieXRlcyB0byByZWFkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBtZXRyaWNzIE1ldHJpY3Mgc3BlY2lmeWluZyB3aGF0IGBsZW5ndGhgIGlzIG1lYW50IHRvIGNvdW50LiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlN9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVURjhTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgsIG1ldHJpY3MsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0cmljcyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gbWV0cmljcztcclxuICAgICAgICAgICAgbWV0cmljcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0cmljcyA9PT0gJ3VuZGVmaW5lZCcpIG1ldHJpY3MgPSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlM7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIitsZW5ndGgrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIGxlbmd0aCB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIHNkO1xyXG4gICAgICAgIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMpIHsgLy8gVGhlIHNhbWUgZm9yIG5vZGUgYW5kIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKTtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW5ndGggJiYgb2Zmc2V0IDwgdGhpcy5saW1pdCA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICArK2k7IHV0ZnguVVRGOHRvVVRGMTYoY3AsIHNkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2krXCIgPT0gXCIrbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgbGVuZ3RoID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiK2xlbmd0aCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBrID0gb2Zmc2V0ICsgbGVuZ3RoO1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCA8IGsgPyB0aGlzLnZpZXdbb2Zmc2V0KytdIDogbnVsbDtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCksIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBrKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrayk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmluZyc6IHNkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIG1ldHJpY3M6IFwiK21ldHJpY3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVURjhTdHJpbmd9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWV0cmljcyBNZXRyaWNzIHNwZWNpZnlpbmcgd2hhdCBgbmAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSU30uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVVRGOFN0cmluZztcclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL3ZzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIGssIGw7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xyXG4gICAgICAgIGwgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGspO1xyXG4gICAgICAgIG9mZnNldCArPSBsK2s7XG4gICAgICAgIHZhciBjYXBhY2l0eTE1ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTUpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTUgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gbCtrO1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy53cml0ZVZhcmludDMyKGssIG9mZnNldCk7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0K2srbClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCtrK2wpKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBsZW5ndGggYXMgdmFyaW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3JlYWRWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnJlYWRWYXJpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnJlYWRVVEY4U3RyaW5nKGxlblsndmFsdWUnXSwgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTLCBvZmZzZXQgKz0gbGVuWydsZW5ndGgnXSk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0clsnbGVuZ3RoJ107XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyWydzdHJpbmcnXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IHN0clsnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgc29tZSBkYXRhIHRvIHRoaXMgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVoaW5kIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZSBhcHBlbmRlZFxyXG4gICAgICogIGRhdGEncyBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmd9IHNvdXJjZSBEYXRhIHRvIGFwcGVuZC4gSWYgYHNvdXJjZWAgaXMgYSBCeXRlQnVmZmVyLCBpdHMgb2Zmc2V0c1xyXG4gICAgICogIHdpbGwgYmUgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIGF0LiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBBIHJlbGF0aXZlIGA8MDEgMDI+MDMuYXBwZW5kKDwwNCAwNT4pYCB3aWxsIHJlc3VsdCBpbiBgPDAxIDAyIDA0IDA1PiwgMDQgMDV8YFxyXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDwwMSAwMj4wMy5hcHBlbmQoMDQgMDU+LCAxKWAgd2lsbCByZXN1bHQgaW4gYDwwMSAwND4wNSwgMDQgMDV8YFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSlcclxuICAgICAgICAgICAgc291cmNlID0gQnl0ZUJ1ZmZlci53cmFwKHNvdXJjZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2UubGltaXQgLSBzb3VyY2Uub2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gYXBwZW5kXHJcbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTYgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE2ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0KTtcclxuICAgICAgICBzb3VyY2Uub2Zmc2V0ICs9IGxlbmd0aDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhbm90aGVyIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGF0IGFuZCBhZnRlciB0aGVcclxuICAgICAgICBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZSBsZW5ndGggb2YgdGhpcyBCeXRlQnVmZmVyJ3MgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIGFwcGVuZCB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI2FwcGVuZFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24odGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB0YXJnZXQuYXBwZW5kKHRoaXMsIG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhc3NlcnRpb25zIG9mIGFyZ3VtZW50IHR5cGVzIGFuZCBvZmZzZXRzLiBBc3NlcnRpb25zIGFyZSBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IHlvdSBjYW4gb3B0IHRvXHJcbiAgICAgKiAgZGlzYWJsZSB0aGVtIGlmIHlvdXIgY29kZSBhbHJlYWR5IG1ha2VzIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIHZhbGlkLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhc3NlcnQgYHRydWVgIHRvIGVuYWJsZSBhc3NlcnRpb25zLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24oYXNzZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5ub0Fzc2VydCA9ICFhc3NlcnQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY2FwYWNpdHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgYmFja2luZyBidWZmZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDYXBhY2l0eSBvZiB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoaXMgQnl0ZUJ1ZmZlcidzIG9mZnNldHMgYnkgc2V0dGluZyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IHRvIGAwYCBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIHRoZVxyXG4gICAgICogIGJhY2tpbmcgYnVmZmVyJ3MgY2FwYWNpdHkuIERpc2NhcmRzIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhpcyBCeXRlQnVmZmVyLCBwcmVzZXQgd2l0aCB0aGlzIEJ5dGVCdWZmZXIncyB2YWx1ZXMgZm9yIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0sXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29weSBXaGV0aGVyIHRvIGNvcHkgdGhlIGJhY2tpbmcgYnVmZmVyIG9yIHRvIHJldHVybiBhbm90aGVyIHZpZXcgb24gdGhlIHNhbWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmVkIGluc3RhbmNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihjb3B5KSB7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgIGlmIChjb3B5KSB7XHJcbiAgICAgICAgICAgIGJiLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgYmIudmlldyA9IG5ldyBVaW50OEFycmF5KGJiLmJ1ZmZlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmIuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgICAgIGJiLnZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xyXG4gICAgICAgIGJiLmxpbWl0ID0gdGhpcy5saW1pdDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFjdHMgdGhpcyBCeXRlQnVmZmVyIHRvIGJlIGJhY2tlZCBieSBhIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn0gb2YgaXRzIGNvbnRlbnRzJyBsZW5ndGguIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXNcclxuICAgICAqICBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS4gV2lsbCBzZXQgYG9mZnNldCA9IDBgIGFuZCBgbGltaXQgPSBjYXBhY2l0eWAgYW5kXHJcbiAgICAgKiAgYWRhcHQge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSB0byB0aGUgc2FtZSByZWxhdGl2ZSBwb3NpdGlvbiBpZiBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBzdGFydCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPT09IDAgJiYgZW5kID09PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gQWxyZWFkeSBjb21wYWN0ZWRcclxuICAgICAgICB2YXIgbGVuID0gZW5kIC0gYmVnaW47XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEVNUFRZX0JVRkZFUjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xyXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGVuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ29weVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IGVuZCAtIGJlZ2luLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICBiYi5saW1pdCA9IGNhcGFjaXR5O1xyXG4gICAgICAgIGlmIChiYi5tYXJrZWRPZmZzZXQgPj0gMCkgYmIubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgIHRoaXMuY29weVRvKGJiLCAwLCBiZWdpbiwgZW5kKTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHRhcmdldE9mZnNldCBPZmZzZXQgdG8gY29weSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHRoZSB0YXJnZXQncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiAgYnkgdGhlIG51bWJlciBvZiBieXRlcyBjb3BpZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gc291cmNlT2Zmc2V0IE9mZnNldCB0byBzdGFydCBjb3B5aW5nIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZVxyXG4gICAgICogIG51bWJlciBvZiBieXRlcyBjb3BpZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gc291cmNlTGltaXQgT2Zmc2V0IHRvIGVuZCBjb3B5aW5nIGZyb20sIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRPZmZzZXQsIHNvdXJjZU9mZnNldCwgc291cmNlTGltaXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUsXHJcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldDogTm90IGEgQnl0ZUJ1ZmZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gKHRhcmdldFJlbGF0aXZlID0gdHlwZW9mIHRhcmdldE9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpID8gdGFyZ2V0Lm9mZnNldCA6IHRhcmdldE9mZnNldCB8IDA7XHJcbiAgICAgICAgc291cmNlT2Zmc2V0ID0gKHJlbGF0aXZlID0gdHlwZW9mIHNvdXJjZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5vZmZzZXQgOiBzb3VyY2VPZmZzZXQgfCAwO1xyXG4gICAgICAgIHNvdXJjZUxpbWl0ID0gdHlwZW9mIHNvdXJjZUxpbWl0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMubGltaXQgOiBzb3VyY2VMaW1pdCB8IDA7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXRPZmZzZXQgPCAwIHx8IHRhcmdldE9mZnNldCA+IHRhcmdldC5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgdGFyZ2V0IHJhbmdlOiAwIDw9IFwiK3RhcmdldE9mZnNldCtcIiA8PSBcIit0YXJnZXQuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGlmIChzb3VyY2VPZmZzZXQgPCAwIHx8IHNvdXJjZUxpbWl0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc291cmNlIHJhbmdlOiAwIDw9IFwiK3NvdXJjZU9mZnNldCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZUxpbWl0IC0gc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7IC8vIE5vdGhpbmcgdG8gY29weVxyXG5cclxuICAgICAgICB0YXJnZXQuZW5zdXJlQ2FwYWNpdHkodGFyZ2V0T2Zmc2V0ICsgbGVuKTtcclxuXHJcbiAgICAgICAgdGFyZ2V0LnZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShzb3VyY2VPZmZzZXQsIHNvdXJjZUxpbWl0KSwgdGFyZ2V0T2Zmc2V0KTtcclxuXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgaWYgKHRhcmdldFJlbGF0aXZlKSB0YXJnZXQub2Zmc2V0ICs9IGxlbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgc3VyZSB0aGF0IHRoaXMgQnl0ZUJ1ZmZlciBpcyBiYWNrZWQgYnkgYSB7QGxpbmsgQnl0ZUJ1ZmZlciNidWZmZXJ9IG9mIGF0IGxlYXN0IHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkuIElmIHRoZVxyXG4gICAgICogIGN1cnJlbnQgY2FwYWNpdHkgaXMgZXhjZWVkZWQsIGl0IHdpbGwgYmUgZG91YmxlZC4gSWYgZG91YmxlIHRoZSBjdXJyZW50IGNhcGFjaXR5IGlzIGxlc3MgdGhhbiB0aGUgcmVxdWlyZWQgY2FwYWNpdHksXHJcbiAgICAgKiAgdGhlIHJlcXVpcmVkIGNhcGFjaXR5IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IFJlcXVpcmVkIGNhcGFjaXR5XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmIChjdXJyZW50IDwgY2FwYWNpdHkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZSgoY3VycmVudCAqPSAyKSA+IGNhcGFjaXR5ID8gY3VycmVudCA6IGNhcGFjaXR5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVyd3JpdGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZS4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSBCeXRlIHZhbHVlIHRvIGZpbGwgd2l0aC4gSWYgZ2l2ZW4gYXMgYSBzdHJpbmcsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLiBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBgc29tZUJ5dGVCdWZmZXIuY2xlYXIoKS5maWxsKDApYCBmaWxscyB0aGUgZW50aXJlIGJhY2tpbmcgYnVmZmVyIHdpdGggemVyb2VzXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA+PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGZpbGxcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHRoaXMudmlld1tiZWdpbisrXSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgPSBiZWdpbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIEJ5dGVCdWZmZXIgcmVhZHkgZm9yIGEgbmV3IHNlcXVlbmNlIG9mIHdyaXRlIG9yIHJlbGF0aXZlIHJlYWQgb3BlcmF0aW9ucy4gU2V0cyBgbGltaXQgPSBvZmZzZXRgIGFuZFxyXG4gICAgICogIGBvZmZzZXQgPSAwYC4gTWFrZSBzdXJlIGFsd2F5cyB0byBmbGlwIGEgQnl0ZUJ1ZmZlciB3aGVuIGFsbCByZWxhdGl2ZSByZWFkIG9yIHdyaXRlIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMubGltaXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyBhbiBvZmZzZXQgb24gdGhpcyBCeXRlQnVmZmVyIHRvIGJlIHVzZWQgbGF0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gbWFyay4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZXNldFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICBvZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogb2Zmc2V0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW4gYHRydWVgIGZvciBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIsIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGl0dGxlRW5kaWFuICE9PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpdHRsZUVuZGlhbjogTm90IGEgYm9vbGVhblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSAhIWxpdHRsZUVuZGlhbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2hlcyAodG8pIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLkxFID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0eXBlb2YgbGl0dGxlRW5kaWFuICE9PSAndW5kZWZpbmVkJyA/ICEhbGl0dGxlRW5kaWFuIDogdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2hlcyAodG8pIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJpZ0VuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGxpdHRsZSBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLkJFID0gZnVuY3Rpb24oYmlnRW5kaWFuKSB7XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0eXBlb2YgYmlnRW5kaWFuICE9PSAndW5kZWZpbmVkJyA/ICFiaWdFbmRpYW4gOiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByZXBlbmRzIHNvbWUgZGF0YSB0byB0aGlzIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGVcclxuICAgICAqICBwcmVwZW5kZWQgZGF0YSdzIGxlbmd0aC4gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdmFpbGFibGUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgYG9mZnNldGAsIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogIHdpbGwgYmUgcmVzaXplZCBhbmQgaXRzIGNvbnRlbnRzIG1vdmVkIGFjY29yZGluZ2x5LlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnxzdHJpbmd8IUFycmF5QnVmZmVyfSBzb3VyY2UgRGF0YSB0byBwcmVwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXQgd2lsbCBiZVxyXG4gICAgICogIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBwcmVwZW5kZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQGV4YW1wbGUgQSByZWxhdGl2ZSBgMDA8MDEgMDIgMDM+LnByZXBlbmQoPDA0IDA1PilgIHJlc3VsdHMgaW4gYDwwNCAwNSAwMSAwMiAwMz4sIDA0IDA1fGBcclxuICAgICAqIEBleGFtcGxlIEFuIGFic29sdXRlIGAwMDwwMSAwMiAwMz4ucHJlcGVuZCg8MDQgMDU+LCAyKWAgcmVzdWx0cyBpbiBgMDQ8MDUgMDIgMDM+LCAwNCAwNXxgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSlcclxuICAgICAgICAgICAgc291cmNlID0gQnl0ZUJ1ZmZlci53cmFwKHNvdXJjZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHZhciBsZW4gPSBzb3VyY2UubGltaXQgLSBzb3VyY2Uub2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW4gPD0gMCkgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gcHJlcGVuZFxyXG4gICAgICAgIHZhciBkaWZmID0gbGVuIC0gb2Zmc2V0O1xyXG4gICAgICAgIGlmIChkaWZmID4gMCkgeyAvLyBOb3QgZW5vdWdoIHNwYWNlIGJlZm9yZSBvZmZzZXQsIHNvIHJlc2l6ZSArIG1vdmVcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoICsgZGlmZik7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgdmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KG9mZnNldCwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksIGxlbik7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgKz0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy5saW1pdCArPSBkaWZmO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gZGlmZjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXlWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXcuc2V0KHNvdXJjZS52aWV3LnN1YmFycmF5KHNvdXJjZS5vZmZzZXQsIHNvdXJjZS5saW1pdCksIG9mZnNldCAtIGxlbik7XHJcblxyXG4gICAgICAgIHNvdXJjZS5vZmZzZXQgPSBzb3VyY2UubGltaXQ7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKVxyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgdGhpcyBCeXRlQnVmZmVyIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZVxyXG4gICAgICogIHByZXBlbmRlZCBkYXRhJ3MgbGVuZ3RoLiBJZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBgb2Zmc2V0YCwgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBwcmVwZW5kIGF0LiBXaWxsIHVzZSBhbmQgZGVjcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcHJlcGVuZGVkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNwcmVwZW5kXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJlcGVuZFRvID0gZnVuY3Rpb24odGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB0YXJnZXQucHJlcGVuZCh0aGlzLCBvZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJpbnRzIGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpPX0gb3V0IE91dHB1dCBmdW5jdGlvbiB0byBjYWxsLCBkZWZhdWx0cyB0byBjb25zb2xlLmxvZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnByaW50RGVidWcgPSBmdW5jdGlvbihvdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG91dCAhPT0gJ2Z1bmN0aW9uJykgb3V0ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcclxuICAgICAgICBvdXQoXHJcbiAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKStcIlxcblwiK1xyXG4gICAgICAgICAgICBcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIitcclxuICAgICAgICAgICAgdGhpcy50b0RlYnVnKC8qIGNvbHVtbnMgKi8gdHJ1ZSlcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgcmVhZGFibGUgYnl0ZXMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSwgc28gdGhpcyByZXR1cm5zIGBsaW1pdCAtIG9mZnNldGAuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZW1haW5pbmcgcmVhZGFibGUgYnl0ZXMuIE1heSBiZSBuZWdhdGl2ZSBpZiBgb2Zmc2V0ID4gbGltaXRgLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlbWFpbmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0IC0gdGhpcy5vZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhpcyBCeXRlQnVmZmVyJ3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS4gSWYgYW4gb2Zmc2V0IGhhcyBiZWVuIG1hcmtlZCB0aHJvdWdoIHtAbGluayBCeXRlQnVmZmVyI21hcmt9XHJcbiAgICAgKiAgYmVmb3JlLCBgb2Zmc2V0YCB3aWxsIGJlIHNldCB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9LCB3aGljaCB3aWxsIHRoZW4gYmUgZGlzY2FyZGVkLiBJZiBubyBvZmZzZXQgaGFzIGJlZW5cclxuICAgICAqICBtYXJrZWQsIHNldHMgYG9mZnNldCA9IDBgLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjbWFya1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm1hcmtlZE9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEgYnVmZmVyIG9mIGF0IGxlYXN0IHRoZSBnaXZlbiBjYXBhY2l0eS4gV2lsbCBkbyBub3RoaW5nIGlmIGFscmVhZHkgdGhhdFxyXG4gICAgICogIGxhcmdlIG9yIGxhcmdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSBDYXBhY2l0eSByZXF1aXJlZFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBjYXBhY2l0eWAgaXMgbm90IGEgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgY2FwYWNpdHkgPCAwYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgIT09ICdudW1iZXInIHx8IGNhcGFjaXR5ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiBcIitjYXBhY2l0eStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgY2FwYWNpdHkgfD0gMDtcbiAgICAgICAgICAgIGlmIChjYXBhY2l0eSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogMCA8PSBcIitjYXBhY2l0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgY2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgdmlldy5zZXQodGhpcy52aWV3KTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJzZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBzdGFydCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gcmV2ZXJzZVxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcy52aWV3LnN1YmFycmF5KGJlZ2luLCBlbmQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNraXBzIHRoZSBuZXh0IGBsZW5ndGhgIGJ5dGVzLiBUaGlzIHdpbGwganVzdCBhZHZhbmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byBza2lwLiBNYXkgYWxzbyBiZSBuZWdhdGl2ZSB0byBtb3ZlIHRoZSBvZmZzZXQgYmFjay5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IDAgPD0gXCIrdGhpcy5vZmZzZXQrXCIgKyBcIitsZW5ndGgrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNsaWNlcyB0aGlzIEJ5dGVCdWZmZXIgYnkgY3JlYXRpbmcgYSBjbG9uZWQgaW5zdGFuY2Ugd2l0aCBgb2Zmc2V0ID0gYmVnaW5gIGFuZCBgbGltaXQgPSBlbmRgLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENsb25lIG9mIHRoaXMgQnl0ZUJ1ZmZlciB3aXRoIHNsaWNpbmcgYXBwbGllZCwgYmFja2VkIGJ5IHRoZSBzYW1lIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJiID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIGJiLm9mZnNldCA9IGJlZ2luO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gZW5kO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZUNvcHkgSWYgYHRydWVgIHJldHVybnMgYSBjb3B5LCBvdGhlcndpc2UgcmV0dXJucyBhIHZpZXcgcmVmZXJlbmNpbmcgdGhlIHNhbWUgbWVtb3J5IGlmXHJcbiAgICAgKiAgcG9zc2libGUuIERlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQXJyYXlCdWZmZXJ9IENvbnRlbnRzIGFzIGFuIEFycmF5QnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihmb3JjZUNvcHkpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQsXHJcbiAgICAgICAgICAgIGxpbWl0ID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpbWl0OiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGxpbWl0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGxpbWl0IHx8IGxpbWl0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitvZmZzZXQrXCIgPD0gXCIrbGltaXQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBJdCdzIG5vdCBwb3NzaWJsZSB0byBoYXZlIGFub3RoZXIgQXJyYXlCdWZmZXIgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeSBhcyB0aGUgYmFja2luZyBidWZmZXIuIFRoaXMgaXNcclxuICAgICAgICAvLyBwb3NzaWJsZSB3aXRoIFVpbnQ4QXJyYXkjc3ViYXJyYXkgb25seSwgYnV0IHdlIGhhdmUgdG8gcmV0dXJuIGFuIEFycmF5QnVmZmVyIGJ5IGNvbnRyYWN0LiBTbzpcclxuICAgICAgICBpZiAoIWZvcmNlQ29weSAmJiBvZmZzZXQgPT09IDAgJiYgbGltaXQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsaW1pdClcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxpbWl0IC0gb2Zmc2V0KTtcclxuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIpLnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikuc3ViYXJyYXkob2Zmc2V0LCBsaW1pdCksIDApO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhdyBidWZmZXIgY29tcGFjdGVkIHRvIGNvbnRhaW4gdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN0b0J1ZmZlcn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlQ29weSBJZiBgdHJ1ZWAgcmV0dXJucyBhIGNvcHksIG90aGVyd2lzZSByZXR1cm5zIGEgdmlldyByZWZlcmVuY2luZyB0aGUgc2FtZSBtZW1vcnkuXHJcbiAgICAgKiAgRGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIE91dHB1dCBlbmNvZGluZy4gUmV0dXJucyBhbiBpbmZvcm1hdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgb21pdHRlZCBidXQgYWxzbyBhbGxvd3NcclxuICAgICAqICBkaXJlY3QgY29udmVyc2lvbiB0byBcInV0ZjhcIiwgXCJoZXhcIiwgXCJiYXNlNjRcIiBhbmQgXCJiaW5hcnlcIiBlbmNvZGluZy4gXCJkZWJ1Z1wiIHJldHVybnMgYSBoZXggcmVwcmVzZW50YXRpb24gd2l0aFxyXG4gICAgICogIGhpZ2hsaWdodGVkIG9mZnNldHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgZW5jb2RpbmdgIGlzIGludmFsaWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIHJldHVybiBcIkJ5dGVCdWZmZXJBQihvZmZzZXQ9XCIrdGhpcy5vZmZzZXQrXCIsbWFya2VkT2Zmc2V0PVwiK3RoaXMubWFya2VkT2Zmc2V0K1wiLGxpbWl0PVwiK3RoaXMubGltaXQrXCIsY2FwYWNpdHk9XCIrdGhpcy5jYXBhY2l0eSgpK1wiKVwiO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiLFxyXG4gICAgICAgICAgICBiZWdpbiA9IGVuY29kaW5nLFxyXG4gICAgICAgICAgICBlbmQgPSBiZWdpbjtcclxuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1VURjgoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQmFzZTY0KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiaGV4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CaW5hcnkoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EZWJ1ZygpO1xyXG4gICAgICAgICAgICBjYXNlIFwiY29sdW1uc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2x1bW5zKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBseGl2LWVtYmVkZGFibGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIGx4aXYtZW1iZWRkYWJsZSAoYykgMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gICAgICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9seGl2IGZvciBkZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIHZhciBseGl2ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGx4aXYgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICogQGV4cG9ydHMgbHhpdlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBseGl2ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJhY3RlciBjb2RlcyBmb3Igb3V0cHV0LlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFvdXQgPSBbXHJcbiAgICAgICAgICAgIDY1LCA2NiwgNjcsIDY4LCA2OSwgNzAsIDcxLCA3MiwgNzMsIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLFxyXG4gICAgICAgICAgICA4MSwgODIsIDgzLCA4NCwgODUsIDg2LCA4NywgODgsIDg5LCA5MCwgOTcsIDk4LCA5OSwgMTAwLCAxMDEsIDEwMixcclxuICAgICAgICAgICAgMTAzLCAxMDQsIDEwNSwgMTA2LCAxMDcsIDEwOCwgMTA5LCAxMTAsIDExMSwgMTEyLCAxMTMsIDExNCwgMTE1LCAxMTYsIDExNywgMTE4LFxyXG4gICAgICAgICAgICAxMTksIDEyMCwgMTIxLCAxMjIsIDQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0MywgNDdcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFyYWN0ZXIgY29kZXMgZm9yIGlucHV0LlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgaz1hb3V0Lmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgIGFpblthb3V0W2ldXSA9IGk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgYnl0ZXMgdG8gYmFzZTY0IGNoYXIgY29kZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWZcclxuICAgICAgICAgKiAgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGVuY29kZWQgY2hhclxyXG4gICAgICAgICAqICBjb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYuZW5jb2RlID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGIsIHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICgoYiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZHN0KGFvdXRbKGI+PjIpJjB4M2ZdKTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiYweDMpPDw0O1xyXG4gICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCB8PSAoYj4+NCkmMHhmO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0Wyh0fCgoYj4+NCkmMHhmKSkmMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAoYiYweGYpPDwyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYiA9IHNyYygpKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj42KSYweDMpKSYweDNmXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W2ImMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbdCYweDNmXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdCg2MSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoNjEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCg2MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGJhc2U2NCBjaGFyIGNvZGVzIHRvIGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGUuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgY2hhcmFjdGVyIGNvZGUgaXMgaW52YWxpZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYuZGVjb2RlID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGMsIHQxLCB0MjtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbChjKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgY2hhcmFjdGVyIGNvZGU6IFwiK2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdDEgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQxID09PSAndW5kZWZpbmVkJykgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQyID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDIgPT09ICd1bmRlZmluZWQnKSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgodDE8PDIpPj4+MHwodDImMHgzMCk+PjQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0MSA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gNjEpIGJyZWFrOyBlbHNlIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoKHQyJjB4Zik8PDQpPj4+MHwodDEmMHgzYyk+PjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KCgodDEmMHgzKTw8Nik+Pj4wfHQyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgc3RyaW5nIGlzIHZhbGlkIGJhc2U2NC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB0ZXN0XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICAgICAgICAgKi9cclxuICAgICAgICBseGl2LnRlc3QgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGx4aXY7XHJcbiAgICB9KCk7XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2Jhc2U2NFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgYmVnaW5gIG9yIGBlbmRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0Jhc2U2NCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7IGVuZCA9IGVuZCB8IDA7XHJcbiAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBlbmQgPiB0aGlzLmNhcGFjaXR5IHx8IGJlZ2luID4gZW5kKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiYmVnaW4sIGVuZFwiKTtcclxuICAgICAgICB2YXIgc2Q7IGx4aXYuZW5jb2RlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVnaW4gPCBlbmQgPyB0aGlzLnZpZXdbYmVnaW4rK10gOiBudWxsO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpKTtcclxuICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJzdHJcIik7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoc3RyLmxlbmd0aC80KjMsIGxpdHRsZUVuZGlhbiksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIGx4aXYuZGVjb2RlKHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmIubGltaXQgPSBpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGEgYmluYXJ5IHN0cmluZyB0byBiYXNlNjQgbGlrZSBgd2luZG93LmJ0b2FgIGRvZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEJpbmFyeSBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LmJ0b2FcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5idG9hID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShzdHIpLnRvQmFzZTY0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBiaW5hcnkgbGlrZSBgd2luZG93LmF0b2JgIGRvZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYjY0IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmluYXJ5IHN0cmluZ1xyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LmF0b2JcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hdG9iID0gZnVuY3Rpb24oYjY0KSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NChiNjQpLnRvQmluYXJ5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9iaW5hcnlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyIHRvIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nLCB0aGF0IGlzIHVzaW5nIG9ubHkgY2hhcmFjdGVycyAweDAwLTB4RkYgYXMgYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQmluYXJ5ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBiZWdpbiB8PSAwOyBlbmQgfD0gMDtcclxuICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA+IHRoaXMuY2FwYWNpdHkoKSB8fCBiZWdpbiA+IGVuZClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImJlZ2luLCBlbmRcIik7XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHZhciBjaGFycyA9IFtdLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICBjaGFycy5wdXNoKHRoaXMudmlld1tiZWdpbisrXSk7XHJcbiAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggPj0gMTAyNClcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNoYXJzKSksXHJcbiAgICAgICAgICAgICAgICBjaGFycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJykgKyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcywgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcclxuICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBjaGFyQ29kZSxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihrLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID4gMHhmZilcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJpbGxlZ2FsIGNoYXIgY29kZTogXCIrY2hhckNvZGUpO1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBjaGFyQ29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBrO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2RlYnVnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzLiBPZmZzZXQgc3ltYm9scyBhcmU6XHJcbiAgICAgKiAqIGA8YCA6IG9mZnNldCxcclxuICAgICAqICogYCdgIDogbWFya2VkT2Zmc2V0LFxyXG4gICAgICogKiBgPmAgOiBsaW1pdCxcclxuICAgICAqICogYHxgIDogb2Zmc2V0IGFuZCBsaW1pdCxcclxuICAgICAqICogYFtgIDogb2Zmc2V0IGFuZCBtYXJrZWRPZmZzZXQsXHJcbiAgICAgKiAqIGBdYCA6IG1hcmtlZE9mZnNldCBhbmQgbGltaXQsXHJcbiAgICAgKiAqIGAhYCA6IG9mZnNldCwgbWFya2VkT2Zmc2V0IGFuZCBsaW1pdFxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29sdW1ucyBJZiBgdHJ1ZWAgcmV0dXJucyB0d28gY29sdW1ucyBoZXggKyBhc2NpaSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IERlYnVnIHN0cmluZyBvciBhcnJheSBvZiBsaW5lcyBpZiBgYXNBcnJheSA9IHRydWVgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBgPjAwJzAxIDAyPDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYGxpbWl0PTAsIG1hcmtlZE9mZnNldD0xLCBvZmZzZXQ9M2BcclxuICAgICAqIEBleGFtcGxlIGAwMFswMSAwMiAwMz5gIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PW1hcmtlZE9mZnNldD0xLCBsaW1pdD00YFxyXG4gICAgICogQGV4YW1wbGUgYDAwfDAxIDAyIDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYG9mZnNldD1saW1pdD0xLCBtYXJrZWRPZmZzZXQ9LTFgXHJcbiAgICAgKiBAZXhhbXBsZSBgfGAgY29udGFpbnMgemVybyBieXRlcyB3aXRoIGBvZmZzZXQ9bGltaXQ9MCwgbWFya2VkT2Zmc2V0PS0xYFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvRGVidWcgPSBmdW5jdGlvbihjb2x1bW5zKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMSxcclxuICAgICAgICAgICAgayA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIGIsXHJcbiAgICAgICAgICAgIGhleCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGFzYyA9IFwiXCIsXHJcbiAgICAgICAgICAgIG91dCA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYiA8IDB4MTApIGhleCArPSBcIjBcIitiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBoZXggKz0gYi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIGFzYyArPSBiID4gMzIgJiYgYiA8IDEyNyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoYikgOiAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgJSAxNiA9PT0gMCAmJiBpICE9PSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGhleC5sZW5ndGggPCAzKjE2KzMpIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaGV4K2FzYytcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFzYyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMub2Zmc2V0ICYmIGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIiFcIiA6IFwifFwiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSB0aGlzLm9mZnNldClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiW1wiIDogXCI8XCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIl1cIiA6IFwiPlwiO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIidcIiA6IChjb2x1bW5zIHx8IChpICE9PSAwICYmIGkgIT09IGspID8gXCIgXCIgOiBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbHVtbnMgJiYgaGV4ICE9PSBcIiBcIikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMylcclxuICAgICAgICAgICAgICAgIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgb3V0ICs9IGhleCArIGFzYyArIFwiXFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2x1bW5zID8gb3V0IDogaGV4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBzdHJpbmcgd2l0aCBtYXJrZWQgb2Zmc2V0cyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIERlYnVnIHN0cmluZyB0byBkZWNvZGUgKG5vdCBiZSBnZW5lcmF0ZWQgd2l0aCBgY29sdW1ucyA9IHRydWVgKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjdG9EZWJ1Z1xyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21EZWJ1ZyA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigoKGsrMSkvMyl8MCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgY2gsIGIsXHJcbiAgICAgICAgICAgIHJzID0gZmFsc2UsIC8vIFJlcXVpcmUgc3ltYm9sIG5leHRcclxuICAgICAgICAgICAgaG8gPSBmYWxzZSwgaG0gPSBmYWxzZSwgaGwgPSBmYWxzZSwgLy8gQWxyZWFkeSBoYXMgb2Zmc2V0IChobyksIG1hcmtlZE9mZnNldCAoaG0pLCBsaW1pdCAoaGwpP1xyXG4gICAgICAgICAgICBmYWlsID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoID0gc3RyLmNoYXJBdChpKyspKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobSB8fCBobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHBhcnNlSW50KGNoK3N0ci5jaGFyQXQoaSsrKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLnZpZXdbaisrXSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWlsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghaG8gfHwgIWhsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE1pc3Npbmcgb2Zmc2V0IG9yIGxpbWl0XCIpO1xyXG4gICAgICAgICAgICBpZiAoajxiYi5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIraitcIiA8IFwiK2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9oZXhcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGJlZ2luID0gdHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogYmVnaW47XHJcbiAgICAgICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmxpbWl0IDogZW5kO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W2JlZ2luKytdO1xyXG4gICAgICAgICAgICBpZiAoYiA8IDB4MTApXHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChcIjBcIiwgYi50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICBlbHNlIG91dC5wdXNoKGIudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUhleCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggJSAyICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoKGsgLyAyKSB8IDAsIGxpdHRsZUVuZGlhbiksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBqPTA7IGk8azsgaSs9Mikge1xyXG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpKzIpLCAxNik7XHJcbiAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1oZXggY2hhcmFjdGVyc1wiKTtcclxuICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdXRmeC1lbWJlZGRhYmxlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB1dGZ4LWVtYmVkZGFibGUgKGMpIDIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICAgICAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vdXRmeCBmb3IgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICB2YXIgdXRmeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB1dGZ4IG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB1dGZ4ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gdmFsaWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguTUFYX0NPREVQT0lOVCA9IDB4MTBGRkZGO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIFVURjggY29kZSBwb2ludHMgdG8gVVRGOCBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCkgfCBudW1iZXJ9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UsIGVpdGhlciBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmVuY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjcCA9IHNyYyxcclxuICAgICAgICAgICAgICAgIHNyYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgICAgICAgICAgd2hpbGUgKGNwICE9PSBudWxsIHx8IChjcCA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNwIDwgMHg4MClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoY3AmMHg3Rik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCA8IDB4ODAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDFGKXwweEMwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3AgPCAweDEwMDAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgwRil8MHhFMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjE4KSYweDA3KXwweEYwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTIpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBVVEY4IGJ5dGVzIHRvIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcclxuICAgICAgICAgKiAgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ29kZSBwb2ludHMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBkZWNvZGVkIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGFzdCBzZXF1ZW5jZSBpcyB0cnVuY2F0ZWQuIEhhcyBhbiBhcnJheSBwcm9wZXJ0eSBgYnl0ZXNgIGhvbGRpbmcgdGhlXHJcbiAgICAgICAgICogIHJlbWFpbmluZyBieXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmRlY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYywgZCwgZmFpbCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiLnNsaWNlKDAsIGIuaW5kZXhPZihudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoYi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGVyci5uYW1lID0gXCJUcnVuY2F0ZWRFcnJvclwiO1xyXG4gICAgICAgICAgICAgICAgZXJyWydieXRlcyddID0gYjtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKChhID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGEmMHg4MCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhFMCkgPT09IDB4QzApXHJcbiAgICAgICAgICAgICAgICAgICAgKChiID0gc3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDFGKTw8NikgfCAoYiYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEYwKSA9PT0gMHhFMClcclxuICAgICAgICAgICAgICAgICAgICAoKGI9c3JjKCkpID09PSBudWxsIHx8IChjPXNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYiwgY10pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgwRik8PDEyKSB8ICgoYiYweDNGKTw8NikgfCAoYyYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEY4KSA9PT0gMHhGMClcclxuICAgICAgICAgICAgICAgICAgICAoKGI9c3JjKCkpID09PSBudWxsIHx8IChjPXNyYygpKSA9PT0gbnVsbCB8fCAoZD1zcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGIsIGMgLGRdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MDcpPDwxOCkgfCAoKGImMHgzRik8PDEyKSB8ICgoYyYweDNGKTw8NikgfCAoZCYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0aW5nIGJ5dGU6IFwiK2EpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgVVRGMTYgY2hhcmFjdGVycyB0byBVVEY4IGNvZGUgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENvZGUgcG9pbnRzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNvZGVcclxuICAgICAgICAgKiAgcG9pbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5VVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjMSwgYzIgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjMSA9IGMyICE9PSBudWxsID8gYzIgOiBzcmMoKSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzEgPj0gMHhEODAwICYmIGMxIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYzIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMyID49IDB4REMwMCAmJiBjMiA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoYzEtMHhEODAwKSoweDQwMCtjMi0weERDMDArMHgxMDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMiA9IG51bGw7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHN0KGMxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IG51bGwpIGRzdChjMik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgVVRGOCBjb2RlIHBvaW50cyB0byBVVEYxNiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiAgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0IG9yIGEgc2luZ2xlIG51bWVyaWMgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGNvbnZlcnRlZCBjaGFyIGNvZGUuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBjb2RlIHBvaW50IGlzIG91dCBvZiByYW5nZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguVVRGOHRvVVRGMTYgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjcCA9IHNyYywgc3JjID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChjcCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY3AgLT0gMHgxMDAwMCxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwPj4xMCkrMHhEODAwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJTB4NDAwKSsweERDMDApO1xyXG4gICAgICAgICAgICAgICAgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYW5kIGVuY29kZXMgVVRGMTYgY2hhcmFjdGVycyB0byBVVEY4IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5IGBudWxsYFxyXG4gICAgICAgICAqICBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHV0ZnguVVRGMTZ0b1VURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgdXRmeC5lbmNvZGVVVEY4KGNwLCBkc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGFuZCBjb252ZXJ0cyBVVEY4IGJ5dGVzIHRvIFVURjE2IGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcclxuICAgICAgICAgKiAgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGNvbnZlcnRlZCBjaGFyIGNvZGUuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGFzdCBzZXF1ZW5jZSBpcyB0cnVuY2F0ZWQuIEhhcyBhbiBhcnJheSBwcm9wZXJ0eSBgYnl0ZXNgIGhvbGRpbmcgdGhlIHJlbWFpbmluZyBieXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgIHV0ZnguVVRGOHRvVVRGMTYoY3AsIGRzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIFVURjggY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3AgVVRGOCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZUNvZGVQb2ludCA9IGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBVVEY4IGNvZGUgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKX0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50IHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZVVURjggPSBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICAgICAgdmFyIGNwLCBsPTA7XHJcbiAgICAgICAgICAgIHdoaWxlICgoY3AgPSBzcmMoKSkgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBsICs9IChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBjb2RlIHBvaW50cyByZXNwZWN0aXZlbHkgVVRGOCBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBVVEYxNiBjaGFyIGNvZGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKX0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBUaGUgbnVtYmVyIG9mIFVURjggY29kZSBwb2ludHMgYXQgaW5kZXggMCBhbmQgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkIGF0IGluZGV4IDEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOCA9IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgICAgICB2YXIgbj0wLCBsPTA7XHJcbiAgICAgICAgICAgIHV0ZnguVVRGMTZ0b1VURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgKytuOyBsICs9IChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFtuLGxdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB1dGZ4O1xyXG4gICAgfSgpO1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy91dGY4XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIGFuIFVURjggZW5jb2RlZFxyXG4gICAgICogIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvVVRGOCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNkOyB0cnkge1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZ2luIDwgZW5kID8gdGhpcy52aWV3W2JlZ2luKytdIDogbnVsbDtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGJlZ2luICE9PSBlbmQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2JlZ2luK1wiICE9IFwiK2VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21VVEY4ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydClcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcih1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpLCB0cnVlKVsxXSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgYmIudmlld1tpKytdID0gYjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYi5saW1pdCA9IGk7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQnl0ZUJ1ZmZlcjtcclxufSk7XHJcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbikge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaCAoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBuZXcgTUQ1KClcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cbiIsInZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBNRDUoKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG5cbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIHZhciBoYXNoID0gYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYShhbGcpXG4gICAga2V5ID0gaGFzaC51cGRhdGUoa2V5KS5kaWdlc3QoKVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG4gIHRoaXMuX2hhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgdGhpcy5faGFzaC51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhtYWMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBoYXNoID0gdGhpcy5fYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYSh0aGlzLl9hbGcpXG4gIHJldHVybiBoYXNoLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjIChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSB7XG4gICAgcmV0dXJuIG5ldyBIbWFjKCdybWQxNjAnLCBrZXkpXG4gIH1cbiAgaWYgKGFsZyA9PT0gJ21kNScpIHtcbiAgICByZXR1cm4gbmV3IExlZ2FjeShtZDUsIGtleSlcbiAgfVxuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBibG9ja3NpemUgPSA2NFxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGFsZyhrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gW2lwYWRdXG59XG5cbmluaGVyaXRzKEhtYWMsIEJhc2UpXG5cbkhtYWMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnB1c2goZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2FsZyhCdWZmZXIuY29uY2F0KHRoaXMuX2hhc2gpKVxuICByZXR1cm4gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQoW3RoaXMuX29wYWQsIGhdKSlcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZXZwa2RmXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPT0gbW9kZUNyZWF0b3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuaW5pdCh0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICB2YXIgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsIG9mIE9iamVjdC5jcmVhdGVcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge307XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkhleDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7IiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50JylcblxuZnVuY3Rpb24gQ3VydmUgKHAsIGEsIGIsIEd4LCBHeSwgbiwgaCkge1xuICB0aGlzLnAgPSBwXG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLkcgPSBQb2ludC5mcm9tQWZmaW5lKHRoaXMsIEd4LCBHeSlcbiAgdGhpcy5uID0gblxuICB0aGlzLmggPSBoXG5cbiAgdGhpcy5pbmZpbml0eSA9IG5ldyBQb2ludCh0aGlzLCBudWxsLCBudWxsLCBCaWdJbnRlZ2VyLlpFUk8pXG5cbiAgLy8gcmVzdWx0IGNhY2hpbmdcbiAgdGhpcy5wT3ZlckZvdXIgPSBwLmFkZChCaWdJbnRlZ2VyLk9ORSkuc2hpZnRSaWdodCgyKVxuXG4gIC8vIGRldGVybWluZSBzaXplIG9mIHAgaW4gYnl0ZXNcbiAgdGhpcy5wTGVuZ3RoID0gTWF0aC5mbG9vcigodGhpcy5wLmJpdExlbmd0aCgpICsgNykgLyA4KVxufVxuXG5DdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIChpc09kZCwgeCkge1xuICB2YXIgYWxwaGEgPSB4LnBvdygzKS5hZGQodGhpcy5hLm11bHRpcGx5KHgpKS5hZGQodGhpcy5iKS5tb2QodGhpcy5wKVxuICB2YXIgYmV0YSA9IGFscGhhLm1vZFBvdyh0aGlzLnBPdmVyRm91ciwgdGhpcy5wKSAvLyBYWFg6IG5vdCBjb21wYXRpYmxlIHdpdGggYWxsIGN1cnZlc1xuXG4gIHZhciB5ID0gYmV0YVxuICBpZiAoYmV0YS5pc0V2ZW4oKSBeICFpc09kZCkge1xuICAgIHkgPSB0aGlzLnAuc3VidHJhY3QoeSkgLy8gLXkgJSBwXG4gIH1cblxuICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh0aGlzLCB4LCB5KVxufVxuXG5DdXJ2ZS5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIChRKSB7XG4gIGlmIChRID09PSB0aGlzLmluZmluaXR5KSByZXR1cm4gdHJ1ZVxuXG4gIHJldHVybiBRLnouc2lnbnVtKCkgPT09IDAgJiYgUS55LnNpZ251bSgpICE9PSAwXG59XG5cbkN1cnZlLnByb3RvdHlwZS5pc09uQ3VydmUgPSBmdW5jdGlvbiAoUSkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KFEpKSByZXR1cm4gdHJ1ZVxuXG4gIHZhciB4ID0gUS5hZmZpbmVYXG4gIHZhciB5ID0gUS5hZmZpbmVZXG4gIHZhciBhID0gdGhpcy5hXG4gIHZhciBiID0gdGhpcy5iXG4gIHZhciBwID0gdGhpcy5wXG5cbiAgLy8gQ2hlY2sgdGhhdCB4USBhbmQgeVEgYXJlIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMCwgcCAtIDFdXG4gIGlmICh4LnNpZ251bSgpIDwgMCB8fCB4LmNvbXBhcmVUbyhwKSA+PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKHkuc2lnbnVtKCkgPCAwIHx8IHkuY29tcGFyZVRvKHApID49IDApIHJldHVybiBmYWxzZVxuXG4gIC8vIGFuZCBjaGVjayB0aGF0IHleMiA9IHheMyArIGF4ICsgYiAobW9kIHApXG4gIHZhciBsaHMgPSB5LnNxdWFyZSgpLm1vZChwKVxuICB2YXIgcmhzID0geC5wb3coMykuYWRkKGEubXVsdGlwbHkoeCkpLmFkZChiKS5tb2QocClcbiAgcmV0dXJuIGxocy5lcXVhbHMocmhzKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICpcbiAqIFNlZSBTRUMgMSwgc2VjdGlvbiAzLjIuMi4xOiBFbGxpcHRpYyBDdXJ2ZSBQdWJsaWMgS2V5IFZhbGlkYXRpb24gUHJpbWl0aXZlXG4gKi9cbkN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChRKSB7XG4gIC8vIENoZWNrIFEgIT0gT1xuICBhc3NlcnQoIXRoaXMuaXNJbmZpbml0eShRKSwgJ1BvaW50IGlzIGF0IGluZmluaXR5JylcbiAgYXNzZXJ0KHRoaXMuaXNPbkN1cnZlKFEpLCAnUG9pbnQgaXMgbm90IG9uIHRoZSBjdXJ2ZScpXG5cbiAgLy8gQ2hlY2sgblEgPSBPICh3aGVyZSBRIGlzIGEgc2NhbGFyIG11bHRpcGxlIG9mIEcpXG4gIHZhciBuUSA9IFEubXVsdGlwbHkodGhpcy5uKVxuICBhc3NlcnQodGhpcy5pc0luZmluaXR5KG5RKSwgJ1BvaW50IGlzIG5vdCBhIHNjYWxhciBtdWx0aXBsZSBvZiBHJylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwic2VjcDEyOHIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiLFxuICAgIFwiYVwiOiBcImZmZmZmZmZkZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiZTg3NTc5YzExMDc5ZjQzZGQ4MjQ5OTNjMmNlZTVlZDNcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZTAwMDAwMDAwNzVhMzBkMWI5MDM4YTExNVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjE2MWZmNzUyOGI4OTliMmQwYzI4NjA3Y2E1MmM1Yjg2XCIsXG4gICAgXCJHeVwiOiBcImNmNWFjODM5NWJhZmViMTNjMDJkYTI5MmRkZWQ3YTgzXCJcbiAgfSxcbiAgXCJzZWNwMTYwazFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmFjNzNcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjA3XCIsXG4gICAgXCJuXCI6IFwiMDEwMDAwMDAwMDAwMDAwMDAwMDAwMWI4ZmExNmRmYWI5YWNhMTZiNmIzXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiM2I0YzM4MmNlMzdhYTE5MmE0MDE5ZTc2MzAzNmY0ZjVkZDRkN2ViYlwiLFxuICAgIFwiR3lcIjogXCI5MzhjZjkzNTMxOGZkY2VkNmJjMjgyODY1MzE3MzNjM2YwM2M0ZmVlXCJcbiAgfSxcbiAgXCJzZWNwMTYwcjFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2ZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiMWM5N2JlZmM1NGJkN2E4YjY1YWNmODlmODFkNGQ0YWRjNTY1ZmE0NVwiLFxuICAgIFwiblwiOiBcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFmNGM4ZjkyN2FlZDNjYTc1MjI1N1wiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjRhOTZiNTY4OGVmNTczMjg0NjY0Njk4OTY4YzM4YmI5MTNjYmZjODJcIixcbiAgICBcIkd5XCI6IFwiMjNhNjI4NTUzMTY4OTQ3ZDU5ZGNjOTEyMDQyMzUxMzc3YWM1ZmIzMlwiXG4gIH0sXG4gIFwic2VjcDE5MmsxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmVlMzdcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjAzXCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMjZmMmZjMTcwZjY5NDY2YTc0ZGVmZDhkXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiZGI0ZmYxMGVjMDU3ZTlhZTI2YjA3ZDAyODBiN2Y0MzQxZGE1ZDFiMWVhZTA2YzdkXCIsXG4gICAgXCJHeVwiOiBcIjliMmYyZjZkOWM1NjI4YTc4NDQxNjNkMDE1YmU4NjM0NDA4MmFhODhkOTVlMmY5ZFwiXG4gIH0sXG4gIFwic2VjcDE5MnIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmZmZmZmZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmZmZmZmZmZmZmZmNcIixcbiAgICBcImJcIjogXCI2NDIxMDUxOWU1OWM4MGU3MGZhN2U5YWI3MjI0MzA0OWZlYjhkZWVjYzE0NmI5YjFcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY5OWRlZjgzNjE0NmJjOWIxYjRkMjI4MzFcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCIxODhkYTgwZWIwMzA5MGY2N2NiZjIwZWI0M2ExODgwMGY0ZmYwYWZkODJmZjEwMTJcIixcbiAgICBcIkd5XCI6IFwiMDcxOTJiOTVmZmM4ZGE3ODYzMTAxMWVkNmIyNGNkZDU3M2Y5NzdhMTFlNzk0ODExXCJcbiAgfSxcbiAgXCJzZWNwMjU2azFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmZcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjA3XCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OThcIixcbiAgICBcIkd5XCI6IFwiNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiXG4gIH0sXG4gIFwic2VjcDI1NnIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIsXG4gICAgXCJhXCI6IFwiZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1wiLFxuICAgIFwiYlwiOiBcIjVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGJcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiNmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NlwiLFxuICAgIFwiR3lcIjogXCI0ZmUzNDJlMmZlMWE3ZjliOGVlN2ViNGE3YzBmOWUxNjJiY2UzMzU3NmIzMTVlY2VjYmI2NDA2ODM3YmY1MWY1XCJcbiAgfVxufVxuIiwidmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpXG52YXIgQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJylcblxudmFyIGdldEN1cnZlQnlOYW1lID0gcmVxdWlyZSgnLi9uYW1lcycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDdXJ2ZTogQ3VydmUsXG4gIFBvaW50OiBQb2ludCxcbiAgZ2V0Q3VydmVCeU5hbWU6IGdldEN1cnZlQnlOYW1lXG59XG4iLCJ2YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG52YXIgQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJylcblxuZnVuY3Rpb24gZ2V0Q3VydmVCeU5hbWUgKG5hbWUpIHtcbiAgdmFyIGN1cnZlID0gY3VydmVzW25hbWVdXG4gIGlmICghY3VydmUpIHJldHVybiBudWxsXG5cbiAgdmFyIHAgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5wLCAxNilcbiAgdmFyIGEgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5hLCAxNilcbiAgdmFyIGIgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5iLCAxNilcbiAgdmFyIG4gPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5uLCAxNilcbiAgdmFyIGggPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5oLCAxNilcbiAgdmFyIEd4ID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuR3gsIDE2KVxuICB2YXIgR3kgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5HeSwgMTYpXG5cbiAgcmV0dXJuIG5ldyBDdXJ2ZShwLCBhLCBiLCBHeCwgR3ksIG4sIGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VydmVCeU5hbWVcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgVEhSRUUgPSBCaWdJbnRlZ2VyLnZhbHVlT2YoMylcblxuZnVuY3Rpb24gUG9pbnQgKGN1cnZlLCB4LCB5LCB6KSB7XG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCh6LCB1bmRlZmluZWQsICdNaXNzaW5nIFogY29vcmRpbmF0ZScpXG5cbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlXG4gIHRoaXMueCA9IHhcbiAgdGhpcy55ID0geVxuICB0aGlzLnogPSB6XG4gIHRoaXMuX3pJbnYgPSBudWxsXG5cbiAgdGhpcy5jb21wcmVzc2VkID0gdHJ1ZVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCAnekludicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3pJbnYgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3pJbnYgPSB0aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3pJbnZcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ2FmZmluZVgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLngubXVsdGlwbHkodGhpcy56SW52KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCAnYWZmaW5lWScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueS5tdWx0aXBseSh0aGlzLnpJbnYpLm1vZCh0aGlzLmN1cnZlLnApXG4gIH1cbn0pXG5cblBvaW50LmZyb21BZmZpbmUgPSBmdW5jdGlvbiAoY3VydmUsIHgsIHkpIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgeCwgeSwgQmlnSW50ZWdlci5PTkUpXG59XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSByZXR1cm4gdHJ1ZVxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gdGhpcy5jdXJ2ZS5pc0luZmluaXR5KG90aGVyKVxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KG90aGVyKSkgcmV0dXJuIHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKVxuXG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB2YXIgdSA9IG90aGVyLnkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgaWYgKHUuc2lnbnVtKCkgIT09IDApIHJldHVybiBmYWxzZVxuXG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2YXIgdiA9IG90aGVyLngubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIHYuc2lnbnVtKCkgPT09IDBcbn1cblxuUG9pbnQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHkgPSB0aGlzLmN1cnZlLnAuc3VidHJhY3QodGhpcy55KVxuXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5jdXJ2ZSwgdGhpcy54LCB5LCB0aGlzLnopXG59XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYikge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gYlxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KGIpKSByZXR1cm4gdGhpc1xuXG4gIHZhciB4MSA9IHRoaXMueFxuICB2YXIgeTEgPSB0aGlzLnlcbiAgdmFyIHgyID0gYi54XG4gIHZhciB5MiA9IGIueVxuXG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB2YXIgdSA9IHkyLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QoeTEubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8gdiA9IFgyICogWjEgLSBYMSAqIFoyXG4gIHZhciB2ID0geDIubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh4MS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIGlmICh2LnNpZ251bSgpID09PSAwKSB7XG4gICAgaWYgKHUuc2lnbnVtKCkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnR3aWNlKCkgLy8gdGhpcyA9PSBiLCBzbyBkb3VibGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5pbmZpbml0eSAvLyB0aGlzID0gLWIsIHNvIGluZmluaXR5XG4gIH1cblxuICB2YXIgdjIgPSB2LnNxdWFyZSgpXG4gIHZhciB2MyA9IHYyLm11bHRpcGx5KHYpXG4gIHZhciB4MXYyID0geDEubXVsdGlwbHkodjIpXG4gIHZhciB6dTIgPSB1LnNxdWFyZSgpLm11bHRpcGx5KHRoaXMueilcblxuICAvLyB4MyA9IHYgKiAoejIgKiAoejEgKiB1XjIgLSAyICogeDEgKiB2XjIpIC0gdl4zKVxuICB2YXIgeDMgPSB6dTIuc3VidHJhY3QoeDF2Mi5zaGlmdExlZnQoMSkpLm11bHRpcGx5KGIueikuc3VidHJhY3QodjMpLm11bHRpcGx5KHYpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHkzID0gejIgKiAoMyAqIHgxICogdSAqIHZeMiAtIHkxICogdl4zIC0gejEgKiB1XjMpICsgdSAqIHZeM1xuICB2YXIgeTMgPSB4MXYyLm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh1KS5zdWJ0cmFjdCh5MS5tdWx0aXBseSh2MykpLnN1YnRyYWN0KHp1Mi5tdWx0aXBseSh1KSkubXVsdGlwbHkoYi56KS5hZGQodS5tdWx0aXBseSh2MykpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHozID0gdl4zICogejEgKiB6MlxuICB2YXIgejMgPSB2My5tdWx0aXBseSh0aGlzLnopLm11bHRpcGx5KGIueikubW9kKHRoaXMuY3VydmUucClcblxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMuY3VydmUsIHgzLCB5MywgejMpXG59XG5cblBvaW50LnByb3RvdHlwZS50d2ljZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIHRoaXNcbiAgaWYgKHRoaXMueS5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHlcblxuICB2YXIgeDEgPSB0aGlzLnhcbiAgdmFyIHkxID0gdGhpcy55XG5cbiAgdmFyIHkxejEgPSB5MS5tdWx0aXBseSh0aGlzLnopLm1vZCh0aGlzLmN1cnZlLnApXG4gIHZhciB5MXNxejEgPSB5MXoxLm11bHRpcGx5KHkxKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB2YXIgYSA9IHRoaXMuY3VydmUuYVxuXG4gIC8vIHcgPSAzICogeDFeMiArIGEgKiB6MV4yXG4gIHZhciB3ID0geDEuc3F1YXJlKCkubXVsdGlwbHkoVEhSRUUpXG5cbiAgaWYgKGEuc2lnbnVtKCkgIT09IDApIHtcbiAgICB3ID0gdy5hZGQodGhpcy56LnNxdWFyZSgpLm11bHRpcGx5KGEpKVxuICB9XG5cbiAgdyA9IHcubW9kKHRoaXMuY3VydmUucClcbiAgLy8geDMgPSAyICogeTEgKiB6MSAqICh3XjIgLSA4ICogeDEgKiB5MV4yICogejEpXG4gIHZhciB4MyA9IHcuc3F1YXJlKCkuc3VidHJhY3QoeDEuc2hpZnRMZWZ0KDMpLm11bHRpcGx5KHkxc3F6MSkpLnNoaWZ0TGVmdCgxKS5tdWx0aXBseSh5MXoxKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB5MyA9IDQgKiB5MV4yICogejEgKiAoMyAqIHcgKiB4MSAtIDIgKiB5MV4yICogejEpIC0gd14zXG4gIHZhciB5MyA9IHcubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHgxKS5zdWJ0cmFjdCh5MXNxejEuc2hpZnRMZWZ0KDEpKS5zaGlmdExlZnQoMikubXVsdGlwbHkoeTFzcXoxKS5zdWJ0cmFjdCh3LnBvdygzKSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8gejMgPSA4ICogKHkxICogejEpXjNcbiAgdmFyIHozID0geTF6MS5wb3coMykuc2hpZnRMZWZ0KDMpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmN1cnZlLCB4MywgeTMsIHozKVxufVxuXG4vLyBTaW1wbGUgTkFGIChOb24tQWRqYWNlbnQgRm9ybSkgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG4vLyBUT0RPOiBtb2R1bGFyaXplIHRoZSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG1cblBvaW50LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChrKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiB0aGlzXG4gIGlmIChrLnNpZ251bSgpID09PSAwKSByZXR1cm4gdGhpcy5jdXJ2ZS5pbmZpbml0eVxuXG4gIHZhciBlID0ga1xuICB2YXIgaCA9IGUubXVsdGlwbHkoVEhSRUUpXG5cbiAgdmFyIG5lZyA9IHRoaXMubmVnYXRlKClcbiAgdmFyIFIgPSB0aGlzXG5cbiAgZm9yICh2YXIgaSA9IGguYml0TGVuZ3RoKCkgLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgdmFyIGhCaXQgPSBoLnRlc3RCaXQoaSlcbiAgICB2YXIgZUJpdCA9IGUudGVzdEJpdChpKVxuXG4gICAgUiA9IFIudHdpY2UoKVxuXG4gICAgaWYgKGhCaXQgIT09IGVCaXQpIHtcbiAgICAgIFIgPSBSLmFkZChoQml0ID8gdGhpcyA6IG5lZylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUlxufVxuXG4vLyBDb21wdXRlIHRoaXMqaiArIHgqayAoc2ltdWx0YW5lb3VzIG11bHRpcGxpY2F0aW9uKVxuUG9pbnQucHJvdG90eXBlLm11bHRpcGx5VHdvID0gZnVuY3Rpb24gKGosIHgsIGspIHtcbiAgdmFyIGkgPSBNYXRoLm1heChqLmJpdExlbmd0aCgpLCBrLmJpdExlbmd0aCgpKSAtIDFcbiAgdmFyIFIgPSB0aGlzLmN1cnZlLmluZmluaXR5XG4gIHZhciBib3RoID0gdGhpcy5hZGQoeClcblxuICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgdmFyIGpCaXQgPSBqLnRlc3RCaXQoaSlcbiAgICB2YXIga0JpdCA9IGsudGVzdEJpdChpKVxuXG4gICAgUiA9IFIudHdpY2UoKVxuXG4gICAgaWYgKGpCaXQpIHtcbiAgICAgIGlmIChrQml0KSB7XG4gICAgICAgIFIgPSBSLmFkZChib3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUiA9IFIuYWRkKHRoaXMpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrQml0KSB7XG4gICAgICBSID0gUi5hZGQoeClcbiAgICB9XG4gICAgLS1pXG4gIH1cblxuICByZXR1cm4gUlxufVxuXG5Qb2ludC5wcm90b3R5cGUuZ2V0RW5jb2RlZCA9IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gIGlmIChjb21wcmVzc2VkID09IG51bGwpIGNvbXByZXNzZWQgPSB0aGlzLmNvbXByZXNzZWRcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIEJ1ZmZlci5hbGxvYygxLCAwKSAvLyBJbmZpbml0eSBwb2ludCBlbmNvZGVkIGlzIHNpbXBseSAnMDAnXG5cbiAgdmFyIHggPSB0aGlzLmFmZmluZVhcbiAgdmFyIHkgPSB0aGlzLmFmZmluZVlcbiAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmN1cnZlLnBMZW5ndGhcbiAgdmFyIGJ1ZmZlclxuXG4gIC8vIDB4MDIvMHgwMyB8IFhcbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSArIGJ5dGVMZW5ndGgpXG4gICAgYnVmZmVyLndyaXRlVUludDgoeS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzLCAwKVxuXG4gIC8vIDB4MDQgfCBYIHwgWVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxICsgYnl0ZUxlbmd0aCArIGJ5dGVMZW5ndGgpXG4gICAgYnVmZmVyLndyaXRlVUludDgoMHgwNCwgMClcblxuICAgIHkudG9CdWZmZXIoYnl0ZUxlbmd0aCkuY29weShidWZmZXIsIDEgKyBieXRlTGVuZ3RoKVxuICB9XG5cbiAgeC50b0J1ZmZlcihieXRlTGVuZ3RoKS5jb3B5KGJ1ZmZlciwgMSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cblBvaW50LmRlY29kZUZyb20gPSBmdW5jdGlvbiAoY3VydmUsIGJ1ZmZlcikge1xuICB2YXIgdHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoMClcbiAgdmFyIGNvbXByZXNzZWQgPSAodHlwZSAhPT0gNClcblxuICB2YXIgYnl0ZUxlbmd0aCA9IE1hdGguZmxvb3IoKGN1cnZlLnAuYml0TGVuZ3RoKCkgKyA3KSAvIDgpXG4gIHZhciB4ID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgxLCAxICsgYnl0ZUxlbmd0aCkpXG5cbiAgdmFyIFFcbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCwgYnl0ZUxlbmd0aCArIDEsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpXG4gICAgYXNzZXJ0KHR5cGUgPT09IDB4MDIgfHwgdHlwZSA9PT0gMHgwMywgJ0ludmFsaWQgc2VxdWVuY2UgdGFnJylcblxuICAgIHZhciBpc09kZCA9ICh0eXBlID09PSAweDAzKVxuICAgIFEgPSBjdXJ2ZS5wb2ludEZyb21YKGlzT2RkLCB4KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLCAxICsgYnl0ZUxlbmd0aCArIGJ5dGVMZW5ndGgsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpXG5cbiAgICB2YXIgeSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSArIGJ5dGVMZW5ndGgpKVxuICAgIFEgPSBQb2ludC5mcm9tQWZmaW5lKGN1cnZlLCB4LCB5KVxuICB9XG5cbiAgUS5jb21wcmVzc2VkID0gY29tcHJlc3NlZFxuICByZXR1cm4gUVxufVxuXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiAnKElORklOSVRZKSdcblxuICByZXR1cm4gJygnICsgdGhpcy5hZmZpbmVYLnRvU3RyaW5nKCkgKyAnLCcgKyB0aGlzLmFmZmluZVkudG9TdHJpbmcoKSArICcpJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgdGhpcy5fbGVuZ3RoID0gWzAsIDAsIDAsIDBdXG5cbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcblxuSGFzaEJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgaWYgKGVuY29kaW5nICE9PSAnYnVmZmVyJykgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZylcbiAgICB0aGlzLnVwZGF0ZShjaHVuaylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZGlnZXN0KCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nIHx8ICdiaW5hcnknKVxuXG4gIC8vIGNvbnN1bWUgZGF0YVxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgb2Zmc2V0ID0gMFxuICB3aGlsZSAodGhpcy5fYmxvY2tPZmZzZXQgKyBkYXRhLmxlbmd0aCAtIG9mZnNldCA+PSB0aGlzLl9ibG9ja1NpemUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG4gIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXVxuXG4gIC8vIHVwZGF0ZSBsZW5ndGhcbiAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gZGF0YS5sZW5ndGggKiA4OyBjYXJyeSA+IDA7ICsraikge1xuICAgIHRoaXMuX2xlbmd0aFtqXSArPSBjYXJyeVxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXG4gICAgaWYgKGNhcnJ5ID4gMCkgdGhpcy5fbGVuZ3RoW2pdIC09IDB4MDEwMDAwMDAwMCAqIGNhcnJ5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuXG4gIHZhciBkaWdlc3QgPSB0aGlzLl9kaWdlc3QoKVxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIGxvbmcuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2xvbmcuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBmYWN0b3J5KCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJMb25nXCJdID0gZmFjdG9yeSgpO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAgICAgKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICAgICAqIEBleHBvcnRzIExvbmdcclxuICAgICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuICAgIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbiAgICAvLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuICAgIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuICAgIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbiAgICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuICAgIC8vXHJcbiAgICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbiAgICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuICAgIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4gICAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4gICAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4gICAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gICAgLy9cclxuICAgIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4gICAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcclxuICAgICAgICB2YWx1ZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgICAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgLyogaXMgY29tcGF0aWJsZSAqLyBpbnN0YW5jZW9mIExvbmcpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsKTtcclxuICAgICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdmFsLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbiAgICAvLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLlVPTkUgPSBVT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuICcwJztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gICAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAgICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbihsZSkge1xyXG4gICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgIGxvICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgaGkgICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+IDI0KSAmIDB4ZmZcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgKGhpID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgIGhpICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDI0KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgbG8gICAgICAgICAmIDB4ZmZcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBMb25nO1xyXG59KTtcclxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaEJhc2UgPSByZXF1aXJlKCdoYXNoLWJhc2UnKVxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxuZnVuY3Rpb24gTUQ1ICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxufVxuXG5pbmhlcml0cyhNRDUsIEhhc2hCYXNlKVxuXG5NRDUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBNID0gQVJSQVkxNlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIE1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcblxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZDc2YWE0NzgsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxXSwgMHhlOGM3Yjc1NiwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsyXSwgMHgyNDIwNzBkYiwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVszXSwgMHhjMWJkY2VlZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs0XSwgMHhmNTdjMGZhZiwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzVdLCAweDQ3ODdjNjJhLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzZdLCAweGE4MzA0NjEzLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzddLCAweGZkNDY5NTAxLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzhdLCAweDY5ODA5OGQ4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bOV0sIDB4OGI0NGY3YWYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZmY1YmIxLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzExXSwgMHg4OTVjZDdiZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVsxMl0sIDB4NmI5MDExMjIsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxM10sIDB4ZmQ5ODcxOTMsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTRdLCAweGE2Nzk0MzhlLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzE1XSwgMHg0OWI0MDgyMSwgMjIpXG5cbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzFdLCAweGY2MWUyNTYyLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bNl0sIDB4YzA0MGIzNDAsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxMV0sIDB4MjY1ZTVhNTEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMF0sIDB4ZTliNmM3YWEsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bNV0sIDB4ZDYyZjEwNWQsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxMF0sIDB4MDI0NDE0NTMsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxNV0sIDB4ZDhhMWU2ODEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bNF0sIDB4ZTdkM2ZiYzgsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bOV0sIDB4MjFlMWNkZTYsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxNF0sIDB4YzMzNzA3ZDYsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVszXSwgMHhmNGQ1MGQ4NywgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs4XSwgMHg0NTVhMTRlZCwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxM10sIDB4YTllM2U5MDUsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsyXSwgMHhmY2VmYTNmOCwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzddLCAweDY3NmYwMmQ5LCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzEyXSwgMHg4ZDJhNGM4YSwgMjApXG5cbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzVdLCAweGZmZmEzOTQyLCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bOF0sIDB4ODc3MWY2ODEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTFdLCAweDZkOWQ2MTIyLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzE0XSwgMHhmZGU1MzgwYywgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxXSwgMHhhNGJlZWE0NCwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzRdLCAweDRiZGVjZmE5LCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzddLCAweGY2YmI0YjYwLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzEwXSwgMHhiZWJmYmM3MCwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxM10sIDB4Mjg5YjdlYzYsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVswXSwgMHhlYWExMjdmYSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVszXSwgMHhkNGVmMzA4NSwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVs2XSwgMHgwNDg4MWQwNSwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs5XSwgMHhkOWQ0ZDAzOSwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzEyXSwgMHhlNmRiOTllNSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxNV0sIDB4MWZhMjdjZjgsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMl0sIDB4YzRhYzU2NjUsIDIzKVxuXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVswXSwgMHhmNDI5MjI0NCwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzddLCAweDQzMmFmZjk3LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzE0XSwgMHhhYjk0MjNhNywgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs1XSwgMHhmYzkzYTAzOSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVsxMl0sIDB4NjU1YjU5YzMsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVszXSwgMHg4ZjBjY2M5MiwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxMF0sIDB4ZmZlZmY0N2QsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMV0sIDB4ODU4NDVkZDEsIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bOF0sIDB4NmZhODdlNGYsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVsxNV0sIDB4ZmUyY2U2ZTAsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTMwMTQzMTQsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMTNdLCAweDRlMDgxMWExLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzRdLCAweGY3NTM3ZTgyLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTFdLCAweGJkM2FmMjM1LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzJdLCAweDJhZDdkMmJiLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzldLCAweGViODZkMzkxLCAyMSlcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYikgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkKSB8IDBcbn1cblxuTUQ1LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDE2KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbkYgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuRyAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5IIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5JIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYyBeIChiIHwgKH5kKSkpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTUQ1XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIgKHZhbCwgcHJlZml4KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkgJiYgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHByZWZpeCArICcgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2NrU2l6ZSlcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB0aGlzLl9sZW5ndGggPSBbMCwgMCwgMCwgMF1cblxuICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhIYXNoQmFzZSwgVHJhbnNmb3JtKVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIoZGF0YSwgJ0RhdGEnKVxuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgLy8gY29uc3VtZSBkYXRhXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBvZmZzZXQgPSAwXG4gIHdoaWxlICh0aGlzLl9ibG9ja09mZnNldCArIGRhdGEubGVuZ3RoIC0gb2Zmc2V0ID49IHRoaXMuX2Jsb2NrU2l6ZSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9ibG9ja09mZnNldDsgaSA8IHRoaXMuX2Jsb2NrU2l6ZTspIGJsb2NrW2krK10gPSBkYXRhW29mZnNldCsrXVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cbiAgd2hpbGUgKG9mZnNldCA8IGRhdGEubGVuZ3RoKSBibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IGRhdGFbb2Zmc2V0KytdXG5cbiAgLy8gdXBkYXRlIGxlbmd0aFxuICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBkYXRhLmxlbmd0aCAqIDg7IGNhcnJ5ID4gMDsgKytqKSB7XG4gICAgdGhpcy5fbGVuZ3RoW2pdICs9IGNhcnJ5XG4gICAgY2FycnkgPSAodGhpcy5fbGVuZ3RoW2pdIC8gMHgwMTAwMDAwMDAwKSB8IDBcbiAgICBpZiAoY2FycnkgPiAwKSB0aGlzLl9sZW5ndGhbal0gLT0gMHgwMTAwMDAwMDAwICogY2FycnlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICB2YXIgZGlnZXN0ID0gdGhpcy5fZGlnZXN0KClcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIGRpZ2VzdCA9IGRpZ2VzdC50b1N0cmluZyhlbmNvZGluZylcblxuICAvLyByZXNldCBzdGF0ZVxuICB0aGlzLl9ibG9jay5maWxsKDApXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkgdGhpcy5fbGVuZ3RoW2ldID0gMFxuXG4gIHJldHVybiBkaWdlc3Rcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX2RpZ2VzdCBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hCYXNlXG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9IEJ1ZmZlci5pc0J1ZmZlcihjaHVuayk7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcblxuZnVuY3Rpb24gUklQRU1EMTYwICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxufVxuXG5pbmhlcml0cyhSSVBFTUQxNjAsIEhhc2hCYXNlKVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gbmV3IEFycmF5KDE2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIG1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYWwgPSB0aGlzLl9hXG4gIHZhciBibCA9IHRoaXMuX2JcbiAgdmFyIGNsID0gdGhpcy5fY1xuICB2YXIgZGwgPSB0aGlzLl9kXG4gIHZhciBlbCA9IHRoaXMuX2VcblxuICAvLyBNaiA9IDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVcbiAgLy8gSyA9IDB4MDAwMDAwMDBcbiAgLy8gU2ogPSAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhcbiAgYWwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzBdLCAweDAwMDAwMDAwLCAxMSk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4xKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVsxXSwgMHgwMDAwMDAwMCwgMTQpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMShkbCwgZWwsIGFsLCBibCwgY2wsIG1bMl0sIDB4MDAwMDAwMDAsIDE1KTsgYWwgPSByb3RsKGFsLCAxMClcbiAgY2wgPSBmbjEoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzNdLCAweDAwMDAwMDAwLCAxMik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm4xKGJsLCBjbCwgZGwsIGVsLCBhbCwgbVs0XSwgMHgwMDAwMDAwMCwgNSk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4xKGFsLCBibCwgY2wsIGRsLCBlbCwgbVs1XSwgMHgwMDAwMDAwMCwgOCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4xKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs2XSwgMHgwMDAwMDAwMCwgNyk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4xKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVs3XSwgMHgwMDAwMDAwMCwgOSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4xKGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHgwMDAwMDAwMCwgMTEpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMShibCwgY2wsIGRsLCBlbCwgYWwsIG1bOV0sIDB4MDAwMDAwMDAsIDEzKTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzEwXSwgMHgwMDAwMDAwMCwgMTQpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMShlbCwgYWwsIGJsLCBjbCwgZGwsIG1bMTFdLCAweDAwMDAwMDAwLCAxNSk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4xKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVsxMl0sIDB4MDAwMDAwMDAsIDYpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMShjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTNdLCAweDAwMDAwMDAwLCA3KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjEoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzE0XSwgMHgwMDAwMDAwMCwgOSk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4xKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxNV0sIDB4MDAwMDAwMDAsIDgpOyBjbCA9IHJvdGwoY2wsIDEwKVxuXG4gIC8vIE1qID0gNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOFxuICAvLyBLID0gMHg1YTgyNzk5OVxuICAvLyBTaiA9IDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMlxuICBlbCA9IGZuMihlbCwgYWwsIGJsLCBjbCwgZGwsIG1bN10sIDB4NWE4Mjc5OTksIDcpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMihkbCwgZWwsIGFsLCBibCwgY2wsIG1bNF0sIDB4NWE4Mjc5OTksIDYpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMihjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTNdLCAweDVhODI3OTk5LCA4KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjIoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzFdLCAweDVhODI3OTk5LCAxMyk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxMF0sIDB4NWE4Mjc5OTksIDExKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjIoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzZdLCAweDVhODI3OTk5LCA5KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjIoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzE1XSwgMHg1YTgyNzk5OSwgNyk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4yKGNsLCBkbCwgZWwsIGFsLCBibCwgbVszXSwgMHg1YTgyNzk5OSwgMTUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMihibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTJdLCAweDVhODI3OTk5LCA3KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzBdLCAweDVhODI3OTk5LCAxMik7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4yKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs5XSwgMHg1YTgyNzk5OSwgMTUpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMihkbCwgZWwsIGFsLCBibCwgY2wsIG1bNV0sIDB4NWE4Mjc5OTksIDkpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMihjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMl0sIDB4NWE4Mjc5OTksIDExKTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjIoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzE0XSwgMHg1YTgyNzk5OSwgNyk7IGRsID0gcm90bChkbCwgMTApXG4gIGFsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgbVsxMV0sIDB4NWE4Mjc5OTksIDEzKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjIoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzhdLCAweDVhODI3OTk5LCAxMik7IGJsID0gcm90bChibCwgMTApXG5cbiAgLy8gTWogPSAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyXG4gIC8vIEsgPSAweDZlZDllYmExXG4gIC8vIFNqID0gMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1XG4gIGRsID0gZm4zKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVszXSwgMHg2ZWQ5ZWJhMSwgMTEpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMyhjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTBdLCAweDZlZDllYmExLCAxMyk7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm4zKGJsLCBjbCwgZGwsIGVsLCBhbCwgbVsxNF0sIDB4NmVkOWViYTEsIDYpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuMyhhbCwgYmwsIGNsLCBkbCwgZWwsIG1bNF0sIDB4NmVkOWViYTEsIDcpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMyhlbCwgYWwsIGJsLCBjbCwgZGwsIG1bOV0sIDB4NmVkOWViYTEsIDE0KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjMoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzE1XSwgMHg2ZWQ5ZWJhMSwgOSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm4zKGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHg2ZWQ5ZWJhMSwgMTMpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMyhibCwgY2wsIGRsLCBlbCwgYWwsIG1bMV0sIDB4NmVkOWViYTEsIDE1KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjMoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzJdLCAweDZlZDllYmExLCAxNCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm4zKGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs3XSwgMHg2ZWQ5ZWJhMSwgOCk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm4zKGRsLCBlbCwgYWwsIGJsLCBjbCwgbVswXSwgMHg2ZWQ5ZWJhMSwgMTMpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuMyhjbCwgZGwsIGVsLCBhbCwgYmwsIG1bNl0sIDB4NmVkOWViYTEsIDYpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuMyhibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTNdLCAweDZlZDllYmExLCA1KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjMoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzExXSwgMHg2ZWQ5ZWJhMSwgMTIpOyBjbCA9IHJvdGwoY2wsIDEwKVxuICBlbCA9IGZuMyhlbCwgYWwsIGJsLCBjbCwgZGwsIG1bNV0sIDB4NmVkOWViYTEsIDcpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuMyhkbCwgZWwsIGFsLCBibCwgY2wsIG1bMTJdLCAweDZlZDllYmExLCA1KTsgYWwgPSByb3RsKGFsLCAxMClcblxuICAvLyBNaiA9IDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDJcbiAgLy8gSyA9IDB4OGYxYmJjZGNcbiAgLy8gU2ogPSAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTJcbiAgY2wgPSBmbjQoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzFdLCAweDhmMWJiY2RjLCAxMSk7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm40KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVs5XSwgMHg4ZjFiYmNkYywgMTIpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMTFdLCAweDhmMWJiY2RjLCAxNCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm40KGVsLCBhbCwgYmwsIGNsLCBkbCwgbVsxMF0sIDB4OGYxYmJjZGMsIDE1KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjQoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzBdLCAweDhmMWJiY2RjLCAxNCk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm40KGNsLCBkbCwgZWwsIGFsLCBibCwgbVs4XSwgMHg4ZjFiYmNkYywgMTUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuNChibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTJdLCAweDhmMWJiY2RjLCA5KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzRdLCAweDhmMWJiY2RjLCA4KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjQoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzEzXSwgMHg4ZjFiYmNkYywgOSk7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm40KGRsLCBlbCwgYWwsIGJsLCBjbCwgbVszXSwgMHg4ZjFiYmNkYywgMTQpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuNChjbCwgZGwsIGVsLCBhbCwgYmwsIG1bN10sIDB4OGYxYmJjZGMsIDUpOyBlbCA9IHJvdGwoZWwsIDEwKVxuICBibCA9IGZuNChibCwgY2wsIGRsLCBlbCwgYWwsIG1bMTVdLCAweDhmMWJiY2RjLCA2KTsgZGwgPSByb3RsKGRsLCAxMClcbiAgYWwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCBtWzE0XSwgMHg4ZjFiYmNkYywgOCk7IGNsID0gcm90bChjbCwgMTApXG4gIGVsID0gZm40KGVsLCBhbCwgYmwsIGNsLCBkbCwgbVs1XSwgMHg4ZjFiYmNkYywgNik7IGJsID0gcm90bChibCwgMTApXG4gIGRsID0gZm40KGRsLCBlbCwgYWwsIGJsLCBjbCwgbVs2XSwgMHg4ZjFiYmNkYywgNSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm40KGNsLCBkbCwgZWwsIGFsLCBibCwgbVsyXSwgMHg4ZjFiYmNkYywgMTIpOyBlbCA9IHJvdGwoZWwsIDEwKVxuXG4gIC8vIE1qID0gNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuICAvLyBLID0gMHhhOTUzZmQ0ZVxuICAvLyBTaiA9IDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuICBibCA9IGZuNShibCwgY2wsIGRsLCBlbCwgYWwsIG1bNF0sIDB4YTk1M2ZkNGUsIDkpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMF0sIDB4YTk1M2ZkNGUsIDE1KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzVdLCAweGE5NTNmZDRlLCA1KTsgYmwgPSByb3RsKGJsLCAxMClcbiAgZGwgPSBmbjUoZGwsIGVsLCBhbCwgYmwsIGNsLCBtWzldLCAweGE5NTNmZDRlLCAxMSk7IGFsID0gcm90bChhbCwgMTApXG4gIGNsID0gZm41KGNsLCBkbCwgZWwsIGFsLCBibCwgbVs3XSwgMHhhOTUzZmQ0ZSwgNik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm41KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVsxMl0sIDB4YTk1M2ZkNGUsIDgpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bMl0sIDB4YTk1M2ZkNGUsIDEzKTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzEwXSwgMHhhOTUzZmQ0ZSwgMTIpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuNShkbCwgZWwsIGFsLCBibCwgY2wsIG1bMTRdLCAweGE5NTNmZDRlLCA1KTsgYWwgPSByb3RsKGFsLCAxMClcbiAgY2wgPSBmbjUoY2wsIGRsLCBlbCwgYWwsIGJsLCBtWzFdLCAweGE5NTNmZDRlLCAxMik7IGVsID0gcm90bChlbCwgMTApXG4gIGJsID0gZm41KGJsLCBjbCwgZGwsIGVsLCBhbCwgbVszXSwgMHhhOTUzZmQ0ZSwgMTMpOyBkbCA9IHJvdGwoZGwsIDEwKVxuICBhbCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIG1bOF0sIDB4YTk1M2ZkNGUsIDE0KTsgY2wgPSByb3RsKGNsLCAxMClcbiAgZWwgPSBmbjUoZWwsIGFsLCBibCwgY2wsIGRsLCBtWzExXSwgMHhhOTUzZmQ0ZSwgMTEpOyBibCA9IHJvdGwoYmwsIDEwKVxuICBkbCA9IGZuNShkbCwgZWwsIGFsLCBibCwgY2wsIG1bNl0sIDB4YTk1M2ZkNGUsIDgpOyBhbCA9IHJvdGwoYWwsIDEwKVxuICBjbCA9IGZuNShjbCwgZGwsIGVsLCBhbCwgYmwsIG1bMTVdLCAweGE5NTNmZDRlLCA1KTsgZWwgPSByb3RsKGVsLCAxMClcbiAgYmwgPSBmbjUoYmwsIGNsLCBkbCwgZWwsIGFsLCBtWzEzXSwgMHhhOTUzZmQ0ZSwgNik7IGRsID0gcm90bChkbCwgMTApXG5cbiAgdmFyIGFyID0gdGhpcy5fYVxuICB2YXIgYnIgPSB0aGlzLl9iXG4gIHZhciBjciA9IHRoaXMuX2NcbiAgdmFyIGRyID0gdGhpcy5fZFxuICB2YXIgZXIgPSB0aGlzLl9lXG5cbiAgLy8gTSdqID0gNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMlxuICAvLyBLJyA9IDB4NTBhMjhiZTZcbiAgLy8gUydqID0gOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2XG4gIGFyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgbVs1XSwgMHg1MGEyOGJlNiwgOCk7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm41KGVyLCBhciwgYnIsIGNyLCBkciwgbVsxNF0sIDB4NTBhMjhiZTYsIDkpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuNShkciwgZXIsIGFyLCBiciwgY3IsIG1bN10sIDB4NTBhMjhiZTYsIDkpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNShjciwgZHIsIGVyLCBhciwgYnIsIG1bMF0sIDB4NTBhMjhiZTYsIDExKTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjUoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzldLCAweDUwYTI4YmU2LCAxMyk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgbVsyXSwgMHg1MGEyOGJlNiwgMTUpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuNShlciwgYXIsIGJyLCBjciwgZHIsIG1bMTFdLCAweDUwYTI4YmU2LCAxNSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm41KGRyLCBlciwgYXIsIGJyLCBjciwgbVs0XSwgMHg1MGEyOGJlNiwgNSk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm41KGNyLCBkciwgZXIsIGFyLCBiciwgbVsxM10sIDB4NTBhMjhiZTYsIDcpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuNShiciwgY3IsIGRyLCBlciwgYXIsIG1bNl0sIDB4NTBhMjhiZTYsIDcpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTVdLCAweDUwYTI4YmU2LCA4KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjUoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDUwYTI4YmU2LCAxMSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm41KGRyLCBlciwgYXIsIGJyLCBjciwgbVsxXSwgMHg1MGEyOGJlNiwgMTQpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNShjciwgZHIsIGVyLCBhciwgYnIsIG1bMTBdLCAweDUwYTI4YmU2LCAxNCk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm41KGJyLCBjciwgZHIsIGVyLCBhciwgbVszXSwgMHg1MGEyOGJlNiwgMTIpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTJdLCAweDUwYTI4YmU2LCA2KTsgY3IgPSByb3RsKGNyLCAxMClcblxuICAvLyBNJ2ogPSA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyXG4gIC8vIEsnID0gMHg1YzRkZDEyNFxuICAvLyBTJ2ogPSA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTFcbiAgZXIgPSBmbjQoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzZdLCAweDVjNGRkMTI0LCA5KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjQoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzExXSwgMHg1YzRkZDEyNCwgMTMpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bM10sIDB4NWM0ZGQxMjQsIDE1KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjQoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzddLCAweDVjNGRkMTI0LCA3KTsgZHIgPSByb3RsKGRyLCAxMClcbiAgYXIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCBtWzBdLCAweDVjNGRkMTI0LCAxMik7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm40KGVyLCBhciwgYnIsIGNyLCBkciwgbVsxM10sIDB4NWM0ZGQxMjQsIDgpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuNChkciwgZXIsIGFyLCBiciwgY3IsIG1bNV0sIDB4NWM0ZGQxMjQsIDkpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bMTBdLCAweDVjNGRkMTI0LCAxMSk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm40KGJyLCBjciwgZHIsIGVyLCBhciwgbVsxNF0sIDB4NWM0ZGQxMjQsIDcpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuNChhciwgYnIsIGNyLCBkciwgZXIsIG1bMTVdLCAweDVjNGRkMTI0LCA3KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjQoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDVjNGRkMTI0LCAxMik7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm40KGRyLCBlciwgYXIsIGJyLCBjciwgbVsxMl0sIDB4NWM0ZGQxMjQsIDcpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuNChjciwgZHIsIGVyLCBhciwgYnIsIG1bNF0sIDB4NWM0ZGQxMjQsIDYpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuNChiciwgY3IsIGRyLCBlciwgYXIsIG1bOV0sIDB4NWM0ZGQxMjQsIDE1KTsgZHIgPSByb3RsKGRyLCAxMClcbiAgYXIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCBtWzFdLCAweDVjNGRkMTI0LCAxMyk7IGNyID0gcm90bChjciwgMTApXG4gIGVyID0gZm40KGVyLCBhciwgYnIsIGNyLCBkciwgbVsyXSwgMHg1YzRkZDEyNCwgMTEpOyBiciA9IHJvdGwoYnIsIDEwKVxuXG4gIC8vIE0naiA9IDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTNcbiAgLy8gSycgPSAweDZkNzAzZWYzXG4gIC8vIFMnaiA9IDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNVxuICBkciA9IGZuMyhkciwgZXIsIGFyLCBiciwgY3IsIG1bMTVdLCAweDZkNzAzZWYzLCA5KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjMoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzVdLCAweDZkNzAzZWYzLCA3KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzFdLCAweDZkNzAzZWYzLCAxNSk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgbVszXSwgMHg2ZDcwM2VmMywgMTEpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMyhlciwgYXIsIGJyLCBjciwgZHIsIG1bN10sIDB4NmQ3MDNlZjMsIDgpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuMyhkciwgZXIsIGFyLCBiciwgY3IsIG1bMTRdLCAweDZkNzAzZWYzLCA2KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjMoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzZdLCAweDZkNzAzZWYzLCA2KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzldLCAweDZkNzAzZWYzLCAxNCk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgbVsxMV0sIDB4NmQ3MDNlZjMsIDEyKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjMoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzhdLCAweDZkNzAzZWYzLCAxMyk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4zKGRyLCBlciwgYXIsIGJyLCBjciwgbVsxMl0sIDB4NmQ3MDNlZjMsIDUpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMyhjciwgZHIsIGVyLCBhciwgYnIsIG1bMl0sIDB4NmQ3MDNlZjMsIDE0KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjMoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzEwXSwgMHg2ZDcwM2VmMywgMTMpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMyhhciwgYnIsIGNyLCBkciwgZXIsIG1bMF0sIDB4NmQ3MDNlZjMsIDEzKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjMoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzRdLCAweDZkNzAzZWYzLCA3KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjMoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzEzXSwgMHg2ZDcwM2VmMywgNSk7IGFyID0gcm90bChhciwgMTApXG5cbiAgLy8gTSdqID0gOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNFxuICAvLyBLJyA9IDB4N2E2ZDc2ZTlcbiAgLy8gUydqID0gMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4XG4gIGNyID0gZm4yKGNyLCBkciwgZXIsIGFyLCBiciwgbVs4XSwgMHg3YTZkNzZlOSwgMTUpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuMihiciwgY3IsIGRyLCBlciwgYXIsIG1bNl0sIDB4N2E2ZDc2ZTksIDUpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIG1bNF0sIDB4N2E2ZDc2ZTksIDgpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMihlciwgYXIsIGJyLCBjciwgZHIsIG1bMV0sIDB4N2E2ZDc2ZTksIDExKTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjIoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzNdLCAweDdhNmQ3NmU5LCAxNCk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm4yKGNyLCBkciwgZXIsIGFyLCBiciwgbVsxMV0sIDB4N2E2ZDc2ZTksIDE0KTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjIoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzE1XSwgMHg3YTZkNzZlOSwgNik7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4yKGFyLCBiciwgY3IsIGRyLCBlciwgbVswXSwgMHg3YTZkNzZlOSwgMTQpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMihlciwgYXIsIGJyLCBjciwgZHIsIG1bNV0sIDB4N2E2ZDc2ZTksIDYpOyBiciA9IHJvdGwoYnIsIDEwKVxuICBkciA9IGZuMihkciwgZXIsIGFyLCBiciwgY3IsIG1bMTJdLCAweDdhNmQ3NmU5LCA5KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjIoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzJdLCAweDdhNmQ3NmU5LCAxMik7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm4yKGJyLCBjciwgZHIsIGVyLCBhciwgbVsxM10sIDB4N2E2ZDc2ZTksIDkpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIG1bOV0sIDB4N2E2ZDc2ZTksIDEyKTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjIoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzddLCAweDdhNmQ3NmU5LCA1KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjIoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzEwXSwgMHg3YTZkNzZlOSwgMTUpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMihjciwgZHIsIGVyLCBhciwgYnIsIG1bMTRdLCAweDdhNmQ3NmU5LCA4KTsgZXIgPSByb3RsKGVyLCAxMClcblxuICAvLyBNJ2ogPSAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG4gIC8vIEsnID0gMHgwMDAwMDAwMFxuICAvLyBTJ2ogPSA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbiAgYnIgPSBmbjEoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzEyXSwgMHgwMDAwMDAwMCwgOCk7IGRyID0gcm90bChkciwgMTApXG4gIGFyID0gZm4xKGFyLCBiciwgY3IsIGRyLCBlciwgbVsxNV0sIDB4MDAwMDAwMDAsIDUpOyBjciA9IHJvdGwoY3IsIDEwKVxuICBlciA9IGZuMShlciwgYXIsIGJyLCBjciwgZHIsIG1bMTBdLCAweDAwMDAwMDAwLCAxMik7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4xKGRyLCBlciwgYXIsIGJyLCBjciwgbVs0XSwgMHgwMDAwMDAwMCwgOSk7IGFyID0gcm90bChhciwgMTApXG4gIGNyID0gZm4xKGNyLCBkciwgZXIsIGFyLCBiciwgbVsxXSwgMHgwMDAwMDAwMCwgMTIpOyBlciA9IHJvdGwoZXIsIDEwKVxuICBiciA9IGZuMShiciwgY3IsIGRyLCBlciwgYXIsIG1bNV0sIDB4MDAwMDAwMDAsIDUpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIG1bOF0sIDB4MDAwMDAwMDAsIDE0KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjEoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzddLCAweDAwMDAwMDAwLCA2KTsgYnIgPSByb3RsKGJyLCAxMClcbiAgZHIgPSBmbjEoZHIsIGVyLCBhciwgYnIsIGNyLCBtWzZdLCAweDAwMDAwMDAwLCA4KTsgYXIgPSByb3RsKGFyLCAxMClcbiAgY3IgPSBmbjEoY3IsIGRyLCBlciwgYXIsIGJyLCBtWzJdLCAweDAwMDAwMDAwLCAxMyk7IGVyID0gcm90bChlciwgMTApXG4gIGJyID0gZm4xKGJyLCBjciwgZHIsIGVyLCBhciwgbVsxM10sIDB4MDAwMDAwMDAsIDYpOyBkciA9IHJvdGwoZHIsIDEwKVxuICBhciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIG1bMTRdLCAweDAwMDAwMDAwLCA1KTsgY3IgPSByb3RsKGNyLCAxMClcbiAgZXIgPSBmbjEoZXIsIGFyLCBiciwgY3IsIGRyLCBtWzBdLCAweDAwMDAwMDAwLCAxNSk7IGJyID0gcm90bChiciwgMTApXG4gIGRyID0gZm4xKGRyLCBlciwgYXIsIGJyLCBjciwgbVszXSwgMHgwMDAwMDAwMCwgMTMpOyBhciA9IHJvdGwoYXIsIDEwKVxuICBjciA9IGZuMShjciwgZHIsIGVyLCBhciwgYnIsIG1bOV0sIDB4MDAwMDAwMDAsIDExKTsgZXIgPSByb3RsKGVyLCAxMClcbiAgYnIgPSBmbjEoYnIsIGNyLCBkciwgZXIsIGFyLCBtWzExXSwgMHgwMDAwMDAwMCwgMTEpOyBkciA9IHJvdGwoZHIsIDEwKVxuXG4gIC8vIGNoYW5nZSBzdGF0ZVxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYyArIGRsICsgZXIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2QgKyBlbCArIGFyKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fYSArIGJsICsgY3IpIHwgMFxuICB0aGlzLl9hID0gdFxufVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoMjApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZSwgMTYpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuMSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIGMgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMiAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4zIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiB8ICh+YykpIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjQgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgZCkgfCAoYyAmICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIChjIHwgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSSVBFTUQxNjBcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnVmZmVyJylcbiIsIiFmdW5jdGlvbihnbG9iYWxzKXtcbid1c2Ugc3RyaWN0J1xuXG4vLyoqKiBVTUQgQkVHSU5cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7IC8vcmVxdWlyZS5qcyAvIEFNRFxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWN1cmVSYW5kb21cbiAgfSlcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9Db21tb25KU1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlY3VyZVJhbmRvbVxufSBlbHNlIHsgLy9zY3JpcHQgLyBicm93c2VyXG4gIGdsb2JhbHMuc2VjdXJlUmFuZG9tID0gc2VjdXJlUmFuZG9tXG59XG4vLyoqKiBVTUQgRU5EXG5cbi8vb3B0aW9ucy50eXBlIGlzIHRoZSBvbmx5IHZhbGlkIG9wdGlvblxuZnVuY3Rpb24gc2VjdXJlUmFuZG9tKGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt0eXBlOiAnQXJyYXknfVxuICAvL3dlIGNoZWNrIGZvciBwcm9jZXNzLnBpZCB0byBwcmV2ZW50IGJyb3dzZXJpZnkgZnJvbSB0cmlja2luZyB1c1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MucGlkID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5vZGVSYW5kb20oY291bnQsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvXG4gICAgaWYgKCFjcnlwdG8pIHRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdpbmRvdy5jcnlwdG8uXCIpXG4gICAgcmV0dXJuIGJyb3dzZXJSYW5kb20oY291bnQsIG9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9kZVJhbmRvbShjb3VudCwgb3B0aW9ucykge1xuICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgdmFyIGJ1ZiA9IGNyeXB0by5yYW5kb21CeXRlcyhjb3VudClcblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGJ1ZilcbiAgICBjYXNlICdCdWZmZXInOlxuICAgICAgcmV0dXJuIGJ1ZlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGNvdW50KVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7IGFycltpXSA9IGJ1Zi5yZWFkVUludDgoaSkgfVxuICAgICAgcmV0dXJuIGFyclxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9ucy50eXBlICsgXCIgaXMgdW5zdXBwb3J0ZWQuXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJvd3NlclJhbmRvbShjb3VudCwgb3B0aW9ucykge1xuICB2YXIgbmF0aXZlQXJyID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpXG4gIHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0b1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycilcblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKG5hdGl2ZUFycilcbiAgICBjYXNlICdCdWZmZXInOlxuICAgICAgdHJ5IHsgdmFyIGIgPSBuZXcgQnVmZmVyKDEpIH0gY2F0Y2goZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuIFVzZSBOb2RlLmpzIG9yIEJyb3dzZXJpZnkgZm9yIGJyb3dzZXIgc3VwcG9ydC4nKX1cbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKG5hdGl2ZUFycilcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgIHJldHVybiBuYXRpdmVBcnJcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMudHlwZSArIFwiIGlzIHVuc3VwcG9ydGVkLlwiKVxuICB9XG59XG5cbnNlY3VyZVJhbmRvbS5yYW5kb21BcnJheSA9IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICByZXR1cm4gc2VjdXJlUmFuZG9tKGJ5dGVDb3VudCwge3R5cGU6ICdBcnJheSd9KVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICByZXR1cm4gc2VjdXJlUmFuZG9tKGJ5dGVDb3VudCwge3R5cGU6ICdVaW50OEFycmF5J30pXG59XG5cbnNlY3VyZVJhbmRvbS5yYW5kb21CdWZmZXIgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnQnVmZmVyJ30pXG59XG5cblxufSh0aGlzKTtcbiIsIi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxuICB0aGlzLl9zID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGwgPSB0aGlzLl9sZW4gKz0gZGF0YS5sZW5ndGhcbiAgdmFyIHMgPSB0aGlzLl9zIHx8IDBcbiAgdmFyIGYgPSAwXG4gIHZhciBidWZmZXIgPSB0aGlzLl9ibG9ja1xuXG4gIHdoaWxlIChzIDwgbCkge1xuICAgIHZhciB0ID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIGYgKyB0aGlzLl9ibG9ja1NpemUgLSAocyAlIHRoaXMuX2Jsb2NrU2l6ZSkpXG4gICAgdmFyIGNoID0gKHQgLSBmKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaDsgaSsrKSB7XG4gICAgICBidWZmZXJbKHMgJSB0aGlzLl9ibG9ja1NpemUpICsgaV0gPSBkYXRhW2kgKyBmXVxuICAgIH1cblxuICAgIHMgKz0gY2hcbiAgICBmICs9IGNoXG5cbiAgICBpZiAoKHMgJSB0aGlzLl9ibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYnVmZmVyKVxuICAgIH1cbiAgfVxuICB0aGlzLl9zID0gc1xuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgLy8gU3VwcG9zZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIE0sIGluIGJpdHMsIGlzIGxcbiAgdmFyIGwgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gQXBwZW5kIHRoZSBiaXQgMSB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZV0gPSAweDgwXG5cbiAgLy8gYW5kIHRoZW4gayB6ZXJvIGJpdHMsIHdoZXJlIGsgaXMgdGhlIHNtYWxsZXN0IG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGwgKyAxICsgaykgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplICsgMSlcblxuICBpZiAobCAlICh0aGlzLl9ibG9ja1NpemUgKiA4KSA+PSB0aGlzLl9maW5hbFNpemUgKiA4KSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIC8vIHRvIHRoaXMgYXBwZW5kIHRoZSBibG9jayB3aGljaCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIGwgd3JpdHRlbiBpbiBiaW5hcnlcbiAgLy8gVE9ETzogaGFuZGxlIGNhc2Ugd2hlcmUgbCBpcyA+IE1hdGgucG93KDIsIDI5KVxuICB0aGlzLl9ibG9jay53cml0ZUludDMyQkUobCwgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICB2YXIgaGFzaCA9IHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaykgfHwgdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYiA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZSA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcbiAgdGhpcy5faCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iaCA9IDB4YmI2N2FlODVcbiAgdGhpcy5fY2ggPSAweDNjNmVmMzcyXG4gIHRoaXMuX2RoID0gMHhhNTRmZjUzYVxuICB0aGlzLl9laCA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZmggPSAweDliMDU2ODhjXG4gIHRoaXMuX2doID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oaCA9IDB4NWJlMGNkMTlcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDhcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiXG4gIHRoaXMuX2NsID0gMHhmZTk0ZjgyYlxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjFcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxXG4gIHRoaXMuX2ZsID0gMHgyYjNlNmMxZlxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmJcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDI4IHwgeGwgPDwgNCkgXiAoeGwgPj4+IDIgfCB4IDw8IDMwKSBeICh4bCA+Pj4gNyB8IHggPDwgMjUpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxNCB8IHhsIDw8IDE4KSBeICh4ID4+PiAxOCB8IHhsIDw8IDE0KSBeICh4bCA+Pj4gOSB8IHggPDwgMjMpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNylcbn1cblxuZnVuY3Rpb24gR2FtbWEwbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNyB8IHhsIDw8IDI1KVxufVxuXG5mdW5jdGlvbiBHYW1tYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2KVxufVxuXG5mdW5jdGlvbiBHYW1tYTFsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNiB8IHhsIDw8IDI2KVxufVxuXG5mdW5jdGlvbiBnZXRDYXJyeSAoYSwgYikge1xuICByZXR1cm4gKGEgPj4+IDApIDwgKGIgPj4+IDApID8gMSA6IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGFoID0gdGhpcy5fYWggfCAwXG4gIHZhciBiaCA9IHRoaXMuX2JoIHwgMFxuICB2YXIgY2ggPSB0aGlzLl9jaCB8IDBcbiAgdmFyIGRoID0gdGhpcy5fZGggfCAwXG4gIHZhciBlaCA9IHRoaXMuX2VoIHwgMFxuICB2YXIgZmggPSB0aGlzLl9maCB8IDBcbiAgdmFyIGdoID0gdGhpcy5fZ2ggfCAwXG4gIHZhciBoaCA9IHRoaXMuX2hoIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgICBXW2kgKyAxXSA9IE0ucmVhZEludDMyQkUoaSAqIDQgKyA0KVxuICB9XG4gIGZvciAoOyBpIDwgMTYwOyBpICs9IDIpIHtcbiAgICB2YXIgeGggPSBXW2kgLSAxNSAqIDJdXG4gICAgdmFyIHhsID0gV1tpIC0gMTUgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWEwID0gR2FtbWEwKHhoLCB4bClcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHhoKVxuXG4gICAgeGggPSBXW2kgLSAyICogMl1cbiAgICB4bCA9IFdbaSAtIDIgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWExID0gR2FtbWExKHhoLCB4bClcbiAgICB2YXIgZ2FtbWExbCA9IEdhbW1hMWwoeGwsIHhoKVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpN2ggPSBXW2kgLSA3ICogMl1cbiAgICB2YXIgV2k3bCA9IFdbaSAtIDcgKiAyICsgMV1cblxuICAgIHZhciBXaTE2aCA9IFdbaSAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2kgLSAxNiAqIDIgKyAxXVxuXG4gICAgdmFyIFdpbCA9IChnYW1tYTBsICsgV2k3bCkgfCAwXG4gICAgdmFyIFdpaCA9IChnYW1tYTAgKyBXaTdoICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTBsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIGdhbW1hMWwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBnYW1tYTEgKyBnZXRDYXJyeShXaWwsIGdhbW1hMWwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgV2kxNmwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBXaTE2aCArIGdldENhcnJ5KFdpbCwgV2kxNmwpKSB8IDBcblxuICAgIFdbaV0gPSBXaWhcbiAgICBXW2kgKyAxXSA9IFdpbFxuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjA7IGogKz0gMikge1xuICAgIFdpaCA9IFdbal1cbiAgICBXaWwgPSBXW2ogKyAxXVxuXG4gICAgdmFyIG1hamggPSBtYWooYWgsIGJoLCBjaClcbiAgICB2YXIgbWFqbCA9IG1haihhbCwgYmwsIGNsKVxuXG4gICAgdmFyIHNpZ21hMGggPSBzaWdtYTAoYWgsIGFsKVxuICAgIHZhciBzaWdtYTBsID0gc2lnbWEwKGFsLCBhaClcbiAgICB2YXIgc2lnbWExaCA9IHNpZ21hMShlaCwgZWwpXG4gICAgdmFyIHNpZ21hMWwgPSBzaWdtYTEoZWwsIGVoKVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2pdICsgV1tqXVxuICAgIHZhciBLaWggPSBLW2pdXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICB2YXIgY2hoID0gQ2goZWgsIGZoLCBnaClcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgIHZhciB0MWwgPSAoaGwgKyBzaWdtYTFsKSB8IDBcbiAgICB2YXIgdDFoID0gKGhoICsgc2lnbWExaCArIGdldENhcnJ5KHQxbCwgaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgY2hsKSB8IDBcbiAgICB0MWggPSAodDFoICsgY2hoICsgZ2V0Q2FycnkodDFsLCBjaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgS2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgS2loICsgZ2V0Q2FycnkodDFsLCBLaWwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgV2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgV2loICsgZ2V0Q2FycnkodDFsLCBXaWwpKSB8IDBcblxuICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgdmFyIHQybCA9IChzaWdtYTBsICsgbWFqbCkgfCAwXG4gICAgdmFyIHQyaCA9IChzaWdtYTBoICsgbWFqaCArIGdldENhcnJ5KHQybCwgc2lnbWEwbCkpIHwgMFxuXG4gICAgaGggPSBnaFxuICAgIGhsID0gZ2xcbiAgICBnaCA9IGZoXG4gICAgZ2wgPSBmbFxuICAgIGZoID0gZWhcbiAgICBmbCA9IGVsXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgIGVoID0gKGRoICsgdDFoICsgZ2V0Q2FycnkoZWwsIGRsKSkgfCAwXG4gICAgZGggPSBjaFxuICAgIGRsID0gY2xcbiAgICBjaCA9IGJoXG4gICAgY2wgPSBibFxuICAgIGJoID0gYWhcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhaCA9ICh0MWggKyB0MmggKyBnZXRDYXJyeShhbCwgdDFsKSkgfCAwXG4gIH1cblxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgdGhpcy5fYWggPSAodGhpcy5fYWggKyBhaCArIGdldENhcnJ5KHRoaXMuX2FsLCBhbCkpIHwgMFxuICB0aGlzLl9iaCA9ICh0aGlzLl9iaCArIGJoICsgZ2V0Q2FycnkodGhpcy5fYmwsIGJsKSkgfCAwXG4gIHRoaXMuX2NoID0gKHRoaXMuX2NoICsgY2ggKyBnZXRDYXJyeSh0aGlzLl9jbCwgY2wpKSB8IDBcbiAgdGhpcy5fZGggPSAodGhpcy5fZGggKyBkaCArIGdldENhcnJ5KHRoaXMuX2RsLCBkbCkpIHwgMFxuICB0aGlzLl9laCA9ICh0aGlzLl9laCArIGVoICsgZ2V0Q2FycnkodGhpcy5fZWwsIGVsKSkgfCAwXG4gIHRoaXMuX2ZoID0gKHRoaXMuX2ZoICsgZmggKyBnZXRDYXJyeSh0aGlzLl9mbCwgZmwpKSB8IDBcbiAgdGhpcy5fZ2ggPSAodGhpcy5fZ2ggKyBnaCArIGdldENhcnJ5KHRoaXMuX2dsLCBnbCkpIHwgMFxuICB0aGlzLl9oaCA9ICh0aGlzLl9oaCArIGhoICsgZ2V0Q2FycnkodGhpcy5faGwsIGhsKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVycyAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCk7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwICsgMSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGZvciBlYWNoIGJ1ZmZlcmVkIGJ5dGUgb2YgYSAocGFydGlhbClcbi8vIGNoYXJhY3RlciBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgb3V0cHV0LlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCcucmVwZWF0KHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iXX0=
